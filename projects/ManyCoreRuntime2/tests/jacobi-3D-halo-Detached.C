// Example relaxation code to experiment with TMR transformations

// Things to do in this code:
// 1) Simplify the algorithm-based distribution.
// 2) Add support for ghost boundary halos (arbritrary width).
// 3) Hierarchy of use (nesting of MulticoreArray)
// 4) Dynamic data
// 5) Better use of OpenMP (specify parallel region "#pragma parallel")

// Use "ManyCoreArrayRuntimeSupport" as the name of this class/project...


#include<stdio.h>
#include<stdlib.h>

#include<assert.h>

#include<vector>
#include<string>

// This header file can't be found (unless John Van Zant installs the libnuma development version or the RPM).
// Note that libnuma will return a NULL pointer when ask to allocate zero bytes (C++ allocation will alternatively
// allocated memory returning a valid pointer; so the two are semantically different on minor points). We now
// handle this case to preserve the same semantics; when using libnuma we check for this case of zero bytes and 
// use the C++ allocation to get a valid pointer.
#if HAVE_NUMA_H
   #include<numa.h>
#endif

// Support for timing
#include <iostream>
#include <time.h>

// Local support for a timer better than clock().
#include "highresTimer.h"

using namespace std;

#include "stencil.h"

// *********************************************************************
// *********************************************************************
// Examples of the use of the Core<T> and MulticoreArray<T> abstractions
// *********************************************************************
// *********************************************************************

template <typename T>
void
high_level_relax ( MulticoreArray<T> & array, MulticoreArray<T> & old_array )
   {
  // The code in this function is what we expect users to want to write. However, 
  // while this code uses the same data as the transformed code, but it less efficient.

     const int arraySizeX = array.get_arraySize(0);
     const int arraySizeY = array.get_arraySize(1);
     const int arraySizeZ = array.get_arraySize(2);

  // Higher level could be:
  //    array(I) = (array(I-1) + array(I+1)) / 2.0;
  // but our current abstraction does not support this
  // (use array class (e.g. A++) for this level).

  // Use pragma to trigger compiler transformations, such as:
  // #pragma manycore
#pragma omp for
     for (int k = 1; k < arraySizeZ-1; k++)
        {
          for (int j = 1; j < arraySizeY-1; j++)
             {
               for (int i = 1; i < arraySizeX-1; i++)
                  {
#if 0
                 // 1D simple stencil (configured in 3D)
                    old_array(i,j,k) = (array(i-1,j,k) + array(i+1,j,k)) / 2.0;
#else
#if 0
                 // 2D simple stencil (configured in 3D)
                    old_array(i,j,k) = (array(i-1,j-1,k) + array(i+1,j-1,k) + array(i-1,j+1,k) + array(i+1,j+1,k)) / 4.0;
#else
                 // 3D simple stencil
                    old_array(i,j,k) = (array(i-1,j-1,k-1) + array(i+1,j-1,k-1) + array(i-1,j+1,k-1) + array(i+1,j+1,k-1) + array(i-1,j-1,k+1) + array(i+1,j-1,k+1) + array(i-1,j+1,k+1) + array(i+1,j+1,k+1)) / 8.0;
#endif
#endif
                  }
             }
        }
   }


template <typename T>
void
lower_level_relax ( MulticoreArray<T> & array, MulticoreArray<T> & old_array )
   {
  // The code in this function is what we would want to have ben generated by the compiler.

     const int numberOfCores = array.get_numberOfCores();

  // Make sure that these are distributed using the same approach (table-based or via an algorithmic approach).
     assert(array.get_tableBasedDistribution() == old_array.get_tableBasedDistribution());

// Use OpenMP to support the parallel threads on each core.
     if(old_array.isHaloExist())
     {
       old_array.haloExchange();
#pragma omp parallel for
       for (int p = 0; p < numberOfCores; p++)
          {
            relax(p,array,old_array,1);
            if(array.hasDetachedHalo())
              relax_on_detachedhalo_boundary(p,array,old_array,1);
          }
     }
     else
     {
#pragma omp parallel for
       for (int p = 0; p < numberOfCores; p++)
          {
            relax(p,array,old_array,1);
            relax_on_boundary(p,array,old_array,1);
          }
     }
   }



// ****************************************************
// ****************************************************
// Main test function for MulticoreArray<T> abstraction
// ****************************************************
// ****************************************************

int main ()
   {
  // A multidimensional array support would have to include inter-array padding (to allow the seperate rows to work well with the cache).
  // If multiple arrays are used then intra-array padding will separate them from each other and permit them to work well with cache.

     int numaSupport = -1;
// #ifdef NUMA_NUM_NODES
#if HAVE_NUMA_H
  // A return value of -1 means that all other functions in this library are undefined.
     numaSupport = numa_available();
#endif

     if (numaSupport != -1)
        {
          printf ("NUMA support is AVAILABLE \n");
        }
       else
        {
          printf ("NUMA support is NOT available numaSupport = %d \n",numaSupport);
        }

     int arraySize[DIM]              = {0,0,0};
     int numberOfCoresArraySize[DIM] = {0,0,0};
     int haloSize[DIM]               = {0,0,0};

     int interArraySubsectionPadding =  0; // Page size to avoid cache conflicts with memory allocted for use by each core

#if 1
  // 10x10x10 is 1 million elements
     int global_arraySize = 1024;

     arraySize[0] = global_arraySize;
     arraySize[1] = global_arraySize;
     arraySize[2] = global_arraySize;


     int numberOfCores =  4; // Number of cores to use (each axis)
     numberOfCoresArraySize[0] = numberOfCores;
     numberOfCoresArraySize[1] = numberOfCores;
     numberOfCoresArraySize[2] = numberOfCores;

#if 0
     numberOfCoresArraySize[0] = 4;
     numberOfCoresArraySize[1] = 2;
     numberOfCoresArraySize[2] = 2;
#endif
     int bdySize = 1;

     haloSize[0] = bdySize;
     haloSize[1] = bdySize;
     haloSize[2] = bdySize;

     MulticoreArray<double>::haloType type = MulticoreArray<double>::detached;

  // Array constructor call
     printf ("Allocate array1 \n");
     MulticoreArray<double> array1    (arraySize[0],arraySize[1],arraySize[2],numberOfCoresArraySize[0],numberOfCoresArraySize[1],numberOfCoresArraySize[2],haloSize[0],haloSize[1],haloSize[2],type,interArraySubsectionPadding,false);
     printf ("Allocate array1 \n");
     MulticoreArray<double> old_array1(arraySize[0],arraySize[1],arraySize[2],numberOfCoresArraySize[0],numberOfCoresArraySize[1],numberOfCoresArraySize[2],haloSize[0],haloSize[1],haloSize[2],type,interArraySubsectionPadding,false);
     printf ("Allocate array2 \n");
     MulticoreArray<double> array2    (arraySize[0],arraySize[1],arraySize[2],numberOfCoresArraySize[0],numberOfCoresArraySize[1],numberOfCoresArraySize[2],haloSize[0],haloSize[1],haloSize[2],type,interArraySubsectionPadding,true);
     printf ("Allocate array2 \n");
     MulticoreArray<double> old_array2(arraySize[0],arraySize[1],arraySize[2],numberOfCoresArraySize[0],numberOfCoresArraySize[1],numberOfCoresArraySize[2],haloSize[0],haloSize[1],haloSize[2],type,interArraySubsectionPadding,true);
     printf ("DONE: Allocate array2 \n");

#if 0
     array1.display    ("initial values: array1");
     array2.display    ("initial values: array2");
     old_array1.display("initial values: old_array1");
     old_array2.display("initial values: old_array2");
#endif

#if 0
  // Initialize to non-zero value.
     array1 = 1.0;
     array2 = 1.0;
#endif

#if 1
     printf ("Initialize the array1 \n");
     old_array1.sequenceFill3D(120.0);
     printf ("Initialize the array2 \n");
     old_array2.sequenceFill3D(120.0);
#endif

#if 1
//     array1.display    ("after initialization: array1");
//     array2.display    ("after initialization: array2");
//     old_array1.display("after initialization: old_array1");
//     old_array2.display("after initialization: old_array2");
#endif

  // Initialize the boundary
     int boundaryValue = 0;
     printf ("Initialize the boundary of array1 \n");
     array1.initializeBoundary(boundaryValue);
     old_array1.initializeBoundary(boundaryValue);
//     old_array1.display("after initialization: old_array1");
     printf ("Initialize the boundary of array2 \n");
     array2.initializeBoundary(boundaryValue);
     old_array2.initializeBoundary(boundaryValue);
//     old_array2.display("after initialization: old_array2");

     printf ("Call low_level_relax\n");

#ifndef __APPLE__
  // Setup timer
     timespec time1, time2;
     clock_gettime(CLOCK_REALTIME, &time1);
#endif

  // Call relaxation on array
     int numberOfIterations = 10;
     for (int i = 0; i < numberOfIterations; i++)
        {
#if 0
          printf ("Calling relaxation on large array \n");
#endif
#if 0
       // This is the higher level implementation attractive for users (or the even high level array notation, but not supported with this abstraction).
          high_level_relax(array1,old_array1);
          high_level_relax(array2,old_array2);
#else
       // This is the lower level implementation to be generated by the compiler.
//     printf ("Call relaxation 1\n");
//          lower_level_relax(array1,old_array1);
          lower_level_relax(array2,old_array2);
#endif
        }

#ifndef __APPLE__
  // Get and report the time.
     clock_gettime(CLOCK_REALTIME, &time2);
     cout << diff(time1,time2).tv_sec << ":" << diff(time1,time2).tv_nsec << endl;
#endif

#if 1
  // Output the result
//     array1.display("result: array1");
//     array2.display("result: array2");
#endif

  // Make sure that the results are the same.
//     assert(array1 == array2);
#endif

#if 0
  // Test refactored version of operator.
     relax2D(array1,old_array1);
#endif

#if 1
#ifndef __APPLE__
  // Setup timer
     clock_gettime(CLOCK_REALTIME, &time1);
#endif
  // Test refactored version of operator.
     printf ("Call mid_level_relax\n");
     array1 = 0.0;
     for (int i = 0; i < numberOfIterations; i++)
     {
       relax3D_midlevel(array1,old_array1);
     }
#ifndef __APPLE__
  // Get and report the time.
     clock_gettime(CLOCK_REALTIME, &time2);
     cout << diff(time1,time2).tv_sec << ":" << diff(time1,time2).tv_nsec << endl;
#endif
#endif

#if 0
  // Output the result
     old_array1.display("After relax2D_highlevel(): old_array1");
     array1.display("After relax2D_highlevel(): array1");
     array2.display("After relax2D_highlevel(): array2");
#endif

 // Make sure that the results are the same.

#if 1
#ifndef __APPLE__
  // Setup timer
     clock_gettime(CLOCK_REALTIME, &time1);
#endif
  // Test refactored version of operator.
     array1 = 0.0;
     printf ("Call high_level_relax\n");
     for (int i = 0; i < numberOfIterations; i++)
     {
       relax3D_highlevel(array1,old_array1);
     }
     assert(array1 == array2);
#ifndef __APPLE__
  // Get and report the time.
     clock_gettime(CLOCK_REALTIME, &time2);
     cout << diff(time1,time2).tv_sec << ":" << diff(time1,time2).tv_nsec << endl;
#endif
#endif

     return 0;
   }

