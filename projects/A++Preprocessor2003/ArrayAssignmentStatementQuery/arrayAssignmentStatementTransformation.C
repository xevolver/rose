// Treat config.h separately from other include files
#ifdef HAVE_CONFIG_H
// This avoids requiring the user to use config.h and follows 
// the automake manual request that we use <> instead of ""
#include <config.h>
#endif

#include "arrayPreprocessor.h"

// *****************************************************************
//      Interface function for Array Assignment Statement Query
// *****************************************************************

bool
ArrayAssignmentStatementTransformation::targetForTransformation( SgNode* astNode )
   {
  // This is a static function which returns true when the current node 
  // of the AST is a target for transformation.
     bool returnValue = FALSE;

     ROSE_ASSERT (astNode != NULL);

  // This code used to recognize array statements checks to see if the name of the type of the
  // function contained in the expression statement is "doubleArray".  This code will be
  // dramatically simplified once we can use the higher level grammars to recognise array
  // statements.  At present this code is not a robust test for the use existence of a transformable
  // array statement it will be robust once we can use the higher level grammars (AST restructuring
  // tools) generated by ROSETTA.

     SgExprStatement *expressionStatement = isSgExprStatement(astNode);

  // In this example we only perform transformations on declaration statements
     if (expressionStatement != NULL)
        {
          SgExpression* expression = expressionStatement->get_the_expr();
          ROSE_ASSERT (expression != NULL);

       // See if this is an A++ member function call
          SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(expression);
       // ROSE_ASSERT (functionCallExp != NULL);

          if (functionCallExp != NULL)
             {
               SgType* type = functionCallExp->get_type();
               ROSE_ASSERT (type != NULL);
               SgClassType* classType = isSgClassType(type);
               if (classType == NULL)
                  {
                 // Check to see if it a reference to a class type (and get it's base type)
                    SgType* type = functionCallExp->get_type();
                    ROSE_ASSERT (type != NULL);
                    SgReferenceType* referenceType = isSgReferenceType(type);
                    if (referenceType != NULL)
                       {
                         ROSE_ASSERT (referenceType != NULL);
                         SgType* baseType = referenceType->get_base_type();
                         ROSE_ASSERT (baseType != NULL);
                         classType = isSgClassType(baseType);
                         ROSE_ASSERT (classType != NULL);
                       }
                      else
                       {
                         return FALSE;
                       }
                  }
               ROSE_ASSERT (classType != NULL);

            // It is the get_name which returns the type name (not the qualified name (I forget what it is for)
               SgName name = classType->get_name();
               if (name == "intArray" || name == "floatArray" || name == "doubleArray")
                  {
#if 0
                    printf ("@@@@@@@@@@@ ArrayStatementTransformation::targetForTransformation(): file = %s line #%d \n",
                         rose::getFileName(expressionStatement), rose::getLineNumber(expressionStatement));
#endif
                    returnValue = TRUE;
                  }
                 else
                  {
                 // printf ("Not a expression statement containing a function call expression of type {double,float,int}Array ... \n");
                  }
             }
            else
             {
            // This case could be "A;" in which case there is no transformation
            // printf ("Not a expression statement containing a function call expression ... \n");
             }

       // Our test program should always be TRUE!
       // ROSE_ASSERT (returnValue == TRUE);
        }
       else
        {
       // printf ("Not an expression statement (only expression statements qualify!) \n");
        }

     return returnValue;
   }

#if 0
// Non-static function (interface function)
SynthesizedAttributeBaseClassType
ArrayAssignmentStatementTransformation::transformation (
   const ArrayStatementQueryInheritedAttributeType & X,
   SgNode* astNode )
   {
     printf ("don't call the non-static version while we debug the static version of ArrayAssignmentStatementTransformation::transformation() \n");
      ROSE_ABORT();

  // Call the static function from the nonstatic function
     return transformation ( X, astNode);
   }
#endif

// Static function (interface function)
SynthesizedAttributeBaseClassType
ArrayAssignmentStatementTransformation::transformation (
   SgProject & project,
   const ArrayStatementQueryInheritedAttributeType & X, 
   SgNode* astNode )
   {
  // This function returns the string representing the array statement transformation
     ROSE_ASSERT (isSgExprStatement(astNode) != NULL);

  // Declare the list to place transformation options into from each scope as we traverse backward
  // (up) the AST to the Global scope.
  // list<int> transformationOptions; // inherited attribute

  // Pass in the ArrayStatementQueryInheritedAttributeType object so
  // that all previously visited scopes can be copied to the new
  // inherited attribute.
     ArrayAssignmentStatementQueryInheritedAttributeType arrayAssignmentStatementQueryInheritedData(X,astNode);
     list<int> & transformationOptions = arrayAssignmentStatementQueryInheritedData.getTransformationOptions();

  // Find all the hints specified as enum values constructor parameters for declarations of
  // variables of type "TransformationAssertion".  The current scope and all parent scopes are
  // searched back to the global scope. (Maybe this should return a value rather than modify a
  // reference parameter???)
     TransformationSupport::getTransformationOptions ( astNode, transformationOptions, "TransformationAssertion");

  // Generate a list of names of variables of type InternalIndex
     list<string> indexObjectNameStringList = NameQuery::getVariableNamesWithTypeNameQuery (astNode, "InternalIndex" );

#if 1
     printf ("indexObjectNameStringList = \n%s\n",StringUtility::listToString(indexObjectNameStringList).c_str());
#endif

  // Now use STL to build a list of unique names
     indexObjectNameStringList.unique();

#if 1
     printf ("Unique Names: indexObjectNameStringList = \n%s\n",
          StringUtility::listToString(indexObjectNameStringList).c_str());
#endif

  // If Index objects are used in the array statement then we want to use special indexing based
  // substript computation and we need to communicate this to all phases of the transformation
  // (through use of an inherited attribute!).
  // ROSE_ASSERT (arrayAssignmentStatementQueryInheritedData.getUsingIndexObjectsInSubscriptComputation() == FALSE);
     if (indexObjectNameStringList.size() > 0)
          arrayAssignmentStatementQueryInheritedData.setUsingIndexObjectsInSubscriptComputation(true);
       else
          arrayAssignmentStatementQueryInheritedData.setUsingIndexObjectsInSubscriptComputation(false);

#if 0
     printf ("Exiting as part of testing (after finding names of InternalIndex objects) ... \n");
     ROSE_ABORT();
#endif

  // The dimension of the array statement must be computed on the way down (in the traversal of the AST).
  // This query gets the list of integer associated with the dimension of each array operand (array
  // operands using the doubleArray::operator() member function).
     list<int> operandDimensionList =
          NumberQuery::getNumberOfArgumentsToParenthesisOperatorQuery (astNode, "doubleArray" );
     ROSE_ASSERT (operandDimensionList.size() >= 0);
#if 1
     printf ("operandDimensionList = \n%s\n",StringUtility::listToString(operandDimensionList).c_str());
#endif

  // Now use STL to build a list of unique names
     operandDimensionList.unique();
#if 1
     printf ("Unique Names: operandDimensionList = \n%s\n",StringUtility::listToString(operandDimensionList).c_str());
#endif

  // If there is no dimension computed for the query then it means that there were no operator()
  // used in which case we have to assume 6D array operations
     int dimensionOfArrayStatement = (operandDimensionList.size() == 0) ? 6 : *(operandDimensionList.begin());
     printf ("Array statement is %d dimensional \n",dimensionOfArrayStatement);
     printf ("arrayAssignmentStatementQueryInheritedData.arrayStatementDimension = %d \n",
          arrayAssignmentStatementQueryInheritedData.arrayStatementDimension);

  // Make sure that it has the default value before we change it (error checking)
     ROSE_ASSERT (arrayAssignmentStatementQueryInheritedData.arrayStatementDimension == -1);

  // Modify the inherited attribute using the array statement dimension data
     arrayAssignmentStatementQueryInheritedData.arrayStatementDimensionDefined = TRUE;
     arrayAssignmentStatementQueryInheritedData.arrayStatementDimension        = dimensionOfArrayStatement;

#if 0
     printf ("Exiting as part of testing (after search for array statement dimension = %d) ... \n",dimensionOfArrayStatement);
     ROSE_ABORT();
#endif

  // Build a transformation object so we can setup the accumulatorValue which is not a static data
  // member.  Other transformations which don't use an accumulatorValue attribute don't require this
  // step.
     ArrayAssignmentStatementTransformation transformation(project);

  // Build a return value for the transformation function
     ArrayAssignmentStatementQuerySynthesizedAttributeType returnArrayStatementTransformation(astNode);

  // WARNING: It is a design problem that we have the dimension set in two locations
  // Set the dimension of the array statement in the array operand database
     transformation.accumulatorValue.operandDataBase.setDimension(dimensionOfArrayStatement);
     ROSE_ASSERT (transformation.accumulatorValue.operandDataBase.getDimension() > 0);

#if 0
     printf ("Exiting as part of testing (after search for array statement dimension = %d) ... \n",dimensionOfArrayStatement);
     ROSE_ABORT();
#endif

  // Setup the data base with the options specified by the use and extracted from the current scope
  // of the application code.
     transformation.accumulatorValue.operandDataBase.setUserOptimizationAssertions
          (arrayAssignmentStatementQueryInheritedData.transformationOptions);
     ROSE_ASSERT ( transformation.accumulatorValue.operandDataBase.transformationOption >
                   ArrayTransformationSupport::UnknownIndexingAccess );

  // Make sure the data base has been setup properly
     ROSE_ASSERT ( transformation.accumulatorValue.operandDataBase.transformationOption >
                   ArrayTransformationSupport::UnknownIndexingAccess );
     ROSE_ASSERT ( transformation.accumulatorValue.operandDataBase.dimension > -1 );

  // Call the tree traversal mechanism (tree walker)
     returnArrayStatementTransformation =
          transformation.traverse ( astNode, arrayAssignmentStatementQueryInheritedData );

#if 0
  // Copy the operand data base out of the accumulator attribute and into the
  // ArrayAssignmentStatementTransformation object
     transformation.operandDataBase = transformation.accumulatorValue.operandDataBase;

     printf ("transformation.operandDataBase.displayString() = %s \n",
          transformation.operandDataBase.displayString().c_str());
#endif

  // Verify that we have saved the global and variable declarations and variable initializations
  // ROSE_ASSERT (returnArrayStatementTransformation.getGlobalDeclaration().isEmpty()       == false);
  // ROSE_ASSERT (returnArrayStatementTransformation.getVariableDeclaration().isEmpty()     == false);
  // ROSE_ASSERT (returnArrayStatementTransformation.getVariableInitialization().isEmpty()  == false);

  // ROSE_ASSERT (returnArrayStatementTransformation.contains(AST_Rewrite::GlobalScope) == true);
  // ROSE_ASSERT (returnArrayStatementTransformation.contains(AST_Rewrite::DeclarationWithInitializerString) == true);
  // ROSE_ASSERT (returnArrayStatementTransformation.contains(AST_Rewrite::VariableInitializationString) == true);

  // printf ("returnArrayStatementTransformation.getTransformationSourceCode().c_str() = \n%s \n",
  //      returnArrayStatementTransformation.getTransformationSourceCode().c_str());

#if 0
  // NOTE: I think we need to get the variable declarations out of returnArrayStatementTransformation
     list<string> stringList = returnArrayStatementTransformation.getVariableDeclarationStrings();
     ROSE_ASSERT (stringList.size() > 0);
     for (list<string>::iterator i = stringList.begin(); i != stringList.end(); i++)
          printf ("Base of ArrayAssignmentStatementTransformation::transformation(): getVariableDeclarationStrings() = %s \n",(*i).c_str());
#endif

#if 0
     printf ("Exiting as part of testing (after ASSIGNMENT TRANSFORMATION QUERY) ... \n");
     ROSE_ABORT();
#endif

     return returnArrayStatementTransformation;
   }

// ********************************************************************************************
//                             Destructors and Constructors
// ********************************************************************************************

ArrayAssignmentStatementTransformation::~ArrayAssignmentStatementTransformation()
   {
  // Nothing to do here!
     delete &accumulatorValue;
   };

ArrayAssignmentStatementTransformation::ArrayAssignmentStatementTransformation( SgProject & project )
   : // Initialize the accumulator attribute
        accumulatorValue( *(new ArrayAssignmentStatementQueryAccumulatorType()) )
   {
  // Nothing to do here!
     printf ("Inside of body of constructor ArrayAssignmentStatementTransformation \n");
   };

ArrayAssignmentStatementTransformation::ArrayAssignmentStatementTransformation()
   : // Initialize the accumulator attribute
        accumulatorValue( *(new ArrayAssignmentStatementQueryAccumulatorType()) )
   {
  // Nothing to do here!
     printf ("ERROR: Can't call this default constructor for ArrayAssignmentStatementTransformation: SgProject information for base class invalid pointer \n");
     ROSE_ABORT();
   };

// ********************************************************************************************
//                                         Data Base Support 
// ********************************************************************************************

OperandDataBaseType &
ArrayAssignmentStatementTransformation::getOperandDataBase()
   {
  // return operandDataBase;
     return accumulatorValue.operandDataBase;
   }

















