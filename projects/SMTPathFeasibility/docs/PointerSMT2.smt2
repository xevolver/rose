; Originally based on 
; Efficient evaluation of pointer predicates with Z3 SMT Solver in SLAM2
; Ball, Bounimova, Levin, and Moura
; March 2010
; Any errors found in the code reflect on myself only

; Definitions
; Predicate evaluation needs pointer variables and memory objects/locations
; Locations are represented as simple variables (x, y, z) and terms
; a term can be a direct or indirect field access, array element access, or dereference
; Direct
; x.f
; Indirect
; x->f
; Array element access
; x[1]
; Dereference
; *x *(x.f)

; Location: An element of the abstract domain L
; Each location X has a unique address represented by a function from
; locations to integers
; A : L -> INT
; Values stored in a location are represented by a function from L to V (values)
; V : L -> V

; L is partitioned into L_1 and L_2, normal and abnormal locations respectively
; Normal Locations (L_1) are partitioned into 3 disjoint sets
; Basic Locations L_B, field locations L_F, and implicit locations L_I
; Access term (field access or array element access) denotes a field location
; Dereference could denote a location which is also denoted by another variable or an access term
; Ex:
; x == *y
; x and dereference *y denote the same basic location
; this means that this dereference is aliased with corresponding variable or access term
; A dereference that cannot be aliased with a  variable or access term is thought of
; as denoting an implicit location
; thus implicit location can only be referenced through dereferences
; A predicate can contain dereference terms that cannot yeild any normal location
; Ex
; *p in the predicate (p==0 AND *p==N)
; cannot denote any normal location that would make this predicate
; satisfiable for any value of N, these go into abnormal locations
; abnormal location could signal a bug in the program, e.g.
; { p = 0; *p = N;}
; structures and arrays are considered aggregate location
; by replacing field names with integers from the interval [0, ..., N-1]
; where N is the number of fields in the structure
; preserving the order of fields
; Access terms of the form x[f] are replaced with access terms of the for x.f where f is a non-negative integer
; field names and constant indicies are referred to as field indices

; Finite interval [0, ..., N-1], N is the number of fields in the largest aggregate defined in the program
; aggregate parent has children locations accessed by field indices or dereference links
; Constructor S(X, C) X parent, C field index ([0,...,N-1]) or a dereference link D
; D is introduced as a unique abstract object to represent a pointer dereference location *X as S(X,D)
; S(X, C) is polymorphic in the second argument
; Entire domain of links is the union of [0, ... , N-1] and D, D is not in [0, ..., N-1]
; all non-basic locations (normal and abnormal) are generated by applying location constructor to basic locations from the set L_B. 
; Following axioms defines valid terms generated by this constructor at the same time defining dependencies between this constructor
; and the address and value functions (A, V)
; F, G, X, Y semantic objects
; field indices F, G; locations X,Y

; D stands for the integer -1  (dereference link encoding)
; the integer interval [0, ..., N-1] encodes field indices

(S X C Z) means X is parent, C field index, Z location
(V X Y) means at X Location the value is Y
(L_B LOC) means that LOC is a basic location
(A L Z) means the location X has integer representation value Z 
; forall X in L_N A(X) > 0
(define-rel A (LOCATION Int) )
(rule (=> (A X Y) (> Y 0)))
; forall X,Y : A(X) = A(Y) => X = Y
; (rule (=> (and (A X Z) (A Y Z)) (= X Y)))
; forall X, F, F in [0, ..., N-1] : S(X, F) not in L_B
 (define-rel (S_Field LOC FIELD LOC))
 (define-rel (S_Connection LOC DEREF LOC)) 
; NOTE not quite sure how to define L_B, it should mean something to the effect of LOC in L_B, so 
 (define-rel L_B (LOC))
 (rule (=> (S_Field LOC FIELD A) (not (L_B A))))
; forall X : A(S(X,D)) = V(X)
(rule (=> (and (S X D Z) (A Z L)) (V X L)))
; Forall X, Y, F in [0,...,N-1], G in [0,...,N-1] S(X,F) = S(Y, G) => X =Y and F = G
(rule (=> (and (S X F Z) (S Y G Z)) (and (= X Y) (= F G))))
; Forall X,Y,F in [0,..., N-1], V(X) = V(Y) => (V(S(X,F)) = V(S(Y,F)) 
(rule (=> (V X V_1) (V Y V_1)) (S X F Z) (S Y F W) (V Z V_2) (V W V_2))


; Translation, f, v, x are syntactic objects, f in fields, v in variables, x in locations
; x' result of translation for a term x by applying the translation rules recursively
; 1) Basic location encoding: each variable v is replaced by a unique positive integer n, n < B
; 2) Dereference *x becomes S(x', D)
; 3) Direct field access x.f becomes S(x', f'), where f' is a nonnegative integer n, n < N
; 4) Indirect field access x->f becomes S(S(x', D), f')
; *x becomes (S x! D B_i) (i for whatever basic location we're at

; Implementation
; 1) forall X > 0: A(X) > 0
(define-rel (A Int Loc))
(rule (=> (A X Z) (> Z 0)))
; 2) forall X, Y : A(X) = A(Y) => X = Y
(rule (=> (and (A X Z) (A Y Z))(= X Y)))
; 3) forall X, F>=0: S(X,F) > B
(rule (=> (and (S X F Z) (>= F 0)) (> Z B)))
; 4) forall X: A(S(X,D)) = V(X)
(rule (=> (and (S X D Y) (A Y Z)) (V X Z)))
; 5) forall X,Y,F >= 0, G>= 0 : S(X,F) = S(Y,G) => X = Y and F = G
(rule (=> (and (S X F Z) (S Y G Z)) (and (= X Y) (= F G))))
; 6) forall X,Y,F>=0 : V(X) = V(Y) => V(S(X,F)) = V(S(Y, F)) 
(V X Z) (V Y Z) => (and (and (S X F Q) (S Y F R)) (and (V Q L) (V R L)

;Axioms Change A_INV is the inverse of A, S_INV1 is the inverse of S first componenet, S_INV2 is the inverse of S second component
;2 becomes 2a, 5 becomes 5a, 5b
(define-rel A_INV Int LOC)
(define-rel S_INV1 LOC X) ; X parent
(define-rel S_INV2 LOC C) ; X field index
;2a: forall X : A_INV(A(X)) = X
(rule (=> (and (A X Z) (A_INV Z Y)) (= Y X)))
;5a: forall X, F>=0: S_INV1(S(X,F)) = X
(rule (=> (S X F Z) (S_INV1 Z X)))
;5b: forall X, F>=0: S_INV2(S(X,F)) = F
(rule (=> (S X F Z) (S_INV2 Z F)))

;merging address of aggregate with address of its first field
;removes the optimization changes

;2a) forall X > B, A(X) = A(S(X,0))
(rule (=> (and (> X B) (A X Z)) (S X 0 Z))
;2b) forall X > B, Y: Y != S(X,0) => A(X) == A(Y) => X = Y
(=> (and (not (S X 0 Y)) (and (A X Q) (A Y Q)) (= X Y)))

; physical memory model, no unions
;T(X,F) gets the address shift between F and F+1
; (T X F Z) Z is the address shift

;7) forall F, 0<=F<N-1: A(X,F+1) = A(X,F) + T(X,F))
(define-rel T LOC Int Int) ; location field , address shift amount
(rule (=> (A X (+ F 1) Q) (A X F Q1) (T X F Q2) (= (+ Q1 Q2) Q)))

; Array elements
; Translation rule

; x[k] k variable or location term, If k isa variable, k' is an integer that encodes k as a basic location
; if k is a location term, k' becomes S(x',V(n'))

; new axiom

; forall X > 0, V(X) != D
(rule (=> (V X Z) (distinct D Z))) 


; 2a_2 : 



;2a) forall X A_INV(A(X)) = X



; 
 


; forall 



; forall X in L_n : A (x) > 0
