// DQ (3/22/2016): This must preceed the inclusion of generated files since generated 
// attribute classes may contain variables of abstracition types.
// #include "array.h"

// Example ROSE Translator reads input program and implements a DSL embedded within C++
// to support the stencil computations, and required runtime support is developed seperately.
#include "rose.h"

#include "dsl.h"

using namespace std;

using namespace SPRAY;
using namespace SageInterface;
using namespace SageBuilder;


// This is a function refactoring code used within the stencil evaluation.
// Likely it is generally useful in writing DSLs so it should be refactored 
// to be elsewhere directly in ROSE (e.g. SageInterface namespace).
bool
DSL_Support::isMatchingClassType(SgType* type, const string & name, bool isTemplateClass)
   {
  // This function returns true if the type is a class type or template class instantiation matching the input name.

     bool returnValue = false;

     ROSE_ASSERT(type != NULL);

  // We could maybe just use the type from varRefExp->get_type() (which would be shorter/simpler).
  // SgClassType* classType = isSgClassType(initializedName->get_type());
     SgClassType* classType = isSgClassType(type);
     if (classType != NULL)
        {
       // Check if this is associated with a template instantiation.
          if (isTemplateClass == true)
             {
               SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(classType->get_declaration());
               if (templateInstantiationDecl != NULL)
                  {
#if 0
                    printf ("case SgTemplateInstaiationDecl: class name = %s \n",classType->get_name().str());
                    printf ("case SgTemplateInstaiationDecl: templateInstantiationDecl->get_templateName() = %s \n",templateInstantiationDecl->get_templateName().str());
#endif
                    if (templateInstantiationDecl->get_templateName() == name)
                       {
#if 0
                         printf ("This is verified to be associated with the template class type name = %s \n",name.c_str());
#endif
                         returnValue = true;
                       }
                  }
             }
            else
             {
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
               if (classDeclaration != NULL)
                  {
                    if (classDeclaration->get_name() == name)
                       {
#if 0
                         printf ("This is verified to be associated with the class type name = %s \n",name.c_str());
#endif
                         returnValue = true;
                       }
                  }
             }
        }

     return returnValue;
   }



bool
DSL_Support::isMatchingMemberFunction(SgMemberFunctionRefExp* memberFunctionRefExp, const string & name, bool isTemplateInstantiation)
   {
      bool returnValue = false;
      ROSE_ASSERT(memberFunctionRefExp != NULL);

      SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp->get_symbol();
      ROSE_ASSERT(memberFunctionSymbol != NULL);

#if 0
      printf ("memberFunctionSymbol = %p = %s \n",memberFunctionSymbol,memberFunctionSymbol->class_name().c_str());
#endif

      SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionSymbol->get_declaration();
      ROSE_ASSERT(memberFunctionDeclaration != NULL);

#if 0
      printf ("memberFunctionDeclaration = %p = %s \n",memberFunctionDeclaration,memberFunctionDeclaration->class_name().c_str());
#endif

      if (isTemplateInstantiation == true)
         {
           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration);

        // It is interesting that for operator+, the names of all three ways of computing then are the same.
#if 0
           printf ("memberFunctionDeclaration->get_name()                       = %s \n",memberFunctionDeclaration->get_name().str());
           if (templateInstantiationMemberFunctionDecl != NULL)
              {
                printf ("templateInstantiationMemberFunctionDecl->get_name()         = %s \n",templateInstantiationMemberFunctionDecl->get_name().str());
                printf ("templateInstantiationMemberFunctionDecl->get_templateName() = %s \n",templateInstantiationMemberFunctionDecl->get_templateName().str());
              }
#endif
           if (templateInstantiationMemberFunctionDecl != NULL && templateInstantiationMemberFunctionDecl->get_templateName() == name)
              {
                returnValue = true;
              }
         }
        else
         {
#if 0
           printf ("memberFunctionDeclaration->get_name()                       = %s \n",memberFunctionDeclaration->get_name().str());
#endif
           if (memberFunctionDeclaration->get_name() == name)
              {
                returnValue = true;
              }
         }

     return returnValue;
   }

// SgFunctionCallExp* DSL_Support::buildMemberFunctionCall(SgExpression* expressionRoot, SgType* type, const string & memberFunctionName, SgExpression* expression, bool isOperator)
SgFunctionCallExp*
DSL_Support::buildMemberFunctionCall(SgExpression* expressionRoot, const string & memberFunctionName, SgExpression* expression, bool isOperator)
   {
     SgFunctionCallExp* memberFunctionCall = NULL;

#if 0
     printf ("In DSL_Support::buildMemberFunctionCall(): expressionRoot = %p = %s memberFunctionName = %s expression = %p isOperator = %s \n",
          expressionRoot,expressionRoot->class_name().c_str(),memberFunctionName.c_str(),expression,isOperator ? "true" : "false");
#endif

  // Need to get the symbol for the member function "operator[]" in the RectMDArray<TDest> template class instantiation.

  // We can't get the type from the expressionRoot since it might be a function call and 
  // return a type that is different from the SgClassType of the declaration where we want 
  // to find the member function.
  // SgClassType* classType = isSgClassType(expressionRoot->get_type());
  // SgClassType* classType = isSgClassType(type);

  // Note that we need to get past any possible tyep references, etc.
  // SgClassType* classType = isSgClassType(expressionRoot->get_type());
  // Available values to strip (we only select a subset): STRIP_MODIFIER_TYPE|STRIP_REFERENCE_TYPE|STRIP_POINTER_TYPE|STRIP_ARRAY_TYPE|STRIP_TYPEDEF_TYPE
     SgClassType* classType = isSgClassType(expressionRoot->get_type()->stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_TYPEDEF_TYPE));

     if (classType == NULL)
        {
          printf ("Error: classType == NULL: expressionRoot->get_type() = %p \n",expressionRoot->get_type());
          if (expressionRoot->get_type() != NULL)
             {
               printf ("   --- expressionRoot->get_type() = %s \n",expressionRoot->get_type()->class_name().c_str());
             }

       // classType = SgType::stripType(expressionRoot->get_type());
       // Available values: STRIP_MODIFIER_TYPE|STRIP_REFERENCE_TYPE|STRIP_POINTER_TYPE|STRIP_ARRAY_TYPE|STRIP_TYPEDEF_TYPE
       // classType = isSgClassType(expressionRoot->get_type()->stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_TYPEDEF_TYPE));
       // ROSE_ASSERT(classType != NULL);
        }
     ROSE_ASSERT(classType != NULL);

     SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
     ROSE_ASSERT(classDeclaration != NULL);
     SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration->get_definingDeclaration());
     ROSE_ASSERT(definingClassDeclaration != NULL);

  // We need the class definition scope so that we can look up the member function "operator[]".
     SgClassDefinition* classDefinition = definingClassDeclaration->get_definition();
     ROSE_ASSERT(classDefinition != NULL);
#if 0
     printf ("classDeclaration->get_name() = %s classDefinition = %p = %s \n",classDeclaration->get_name().str(),classDefinition,classDefinition->class_name().c_str());
#endif
  // For the moment we will assume this is not a overloaded operator.
  // SgMemberFunctionSymbol* memberFunctionSymbol = classDefinition->lookup_nontemplate_member_function_symbol("opearator[]");
  // SgFunctionSymbol* functionSymbol = classDefinition->lookup_function_symbol("operator[]");
     SgFunctionSymbol* functionSymbol = classDefinition->lookup_function_symbol(memberFunctionName);
     if (functionSymbol == NULL)
        {
          printf ("Error: function not found in classDeclaration = %s symbol table: memberFunctionName = %s \n",classDeclaration->get_name().str(),memberFunctionName.c_str());

       // Debugging the missing symbol which we expected in the symbol table.
       // classDefinition->get_symbol_table()->print();
        }
     ROSE_ASSERT(functionSymbol != NULL);
  // SgMemberFunctionSymbol* memberFunctionSymbol = classDefinition->lookup_function_symbol("opearator[]");
     SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(functionSymbol);
     ROSE_ASSERT(memberFunctionSymbol != NULL);

  // Build the member function reference expression.
     bool virtual_call   = false;
     bool need_qualifier = false;
     SgMemberFunctionRefExp* memberFunctionRefExp = SageBuilder::buildMemberFunctionRefExp(memberFunctionSymbol,virtual_call,need_qualifier);

  // Build the variable reference so that we can apply the member function.
  // SgVarRefExp* varRefExp = SageBuilder::buildVarRefExp(variableSymbol);

  // Build the dot expression (array variable reference on lhs and member function reference on rhs).
     SgDotExp* dotExp                   = SageBuilder::buildDotExp(expressionRoot,memberFunctionRefExp);

  // Build the function argument list.
  // SgExprListExp* exprListExp         = SageBuilder::buildExprListExp(expression);
     SgExprListExp* exprListExp = NULL;
     if (expression != NULL)
        {
          exprListExp = SageBuilder::buildExprListExp(expression);
        }
       else
        {
          exprListExp = SageBuilder::buildExprListExp();
        }

  // Build the function call expression.
     SgFunctionCallExp* functionCallExp = SageBuilder::buildFunctionCallExp(dotExp,exprListExp);

     if (isOperator == true)
        {
       // Cause the unparsed code to use the operator syntax (instead of function syntax).
          functionCallExp->set_uses_operator_syntax(true);
        }

     memberFunctionCall = functionCallExp;

     ROSE_ASSERT(memberFunctionCall != NULL);

     return memberFunctionCall;
   }


SgFunctionCallExp*
DSL_Support::buildMemberFunctionCall(SgVariableSymbol* variableSymbol, const string & memberFunctionName, SgExpression* expression, bool isOperator)
   {
  // Build the variable reference so that we can apply the member function.
     SgVarRefExp* varRefExp = SageBuilder::buildVarRefExp(variableSymbol);
  // SgType* type           = variableSymbol->get_type();
  // SgFunctionCallExp* memberFunctionCall = buildMemberFunctionCall(varRefExp, type, memberFunctionName, expression, isOperator);
     SgFunctionCallExp* memberFunctionCall = buildMemberFunctionCall(varRefExp, memberFunctionName, expression, isOperator);
     ROSE_ASSERT(memberFunctionCall != NULL);

     return memberFunctionCall;
   }

SgVariableDeclaration*
DSL_Support::buildDataPointer(const string & pointerVariableName, SgVariableSymbol* variableSymbol, SgScopeStatement* outerScope)
   {
  // Optionally build a pointer variable so that we can optionally support a C style indexing for the DTEC DSL blocks.
     SgExpression* pointerExp = buildMemberFunctionCall(variableSymbol,"getPointer",NULL,false);
     ROSE_ASSERT(pointerExp != NULL);
     SgAssignInitializer* assignInitializer = SageBuilder::buildAssignInitializer_nfi(pointerExp);
     ROSE_ASSERT(assignInitializer != NULL);

  // Build the variable declaration for the pointer to the data.
     SgVariableDeclaration* variableDeclaration  = SageBuilder::buildVariableDeclaration_nfi(pointerVariableName,SageBuilder::buildPointerType(SageBuilder::buildDoubleType()),assignInitializer,outerScope);
     ROSE_ASSERT(variableDeclaration != NULL);

     return variableDeclaration;
   }

SgVariableDeclaration*
DSL_Support::buildBoxRef(const string & pointerVariableName, SgVariableSymbol* variableSymbol, SgScopeStatement* outerScope, SgType* type)
   {
  // Optionally build a pointer variable so that we can optionally support a C style indexing for the DTEC DSL blocks.
     SgExpression* pointerExp = buildMemberFunctionCall(variableSymbol,"getBox",NULL,false);
     ROSE_ASSERT(pointerExp != NULL);
     SgAssignInitializer* assignInitializer = SageBuilder::buildAssignInitializer_nfi(pointerExp);
     ROSE_ASSERT(assignInitializer != NULL);

  // Build the variable declaration for the pointer to the data.
     SgVariableDeclaration* variableDeclaration  = SageBuilder::buildVariableDeclaration_nfi(pointerVariableName,type,assignInitializer,outerScope);
     ROSE_ASSERT(variableDeclaration != NULL);

     return variableDeclaration;
   }



SgVariableDeclaration*
DSL_Support::buildMultiDimPointer(const string & pointerVariableName, SgVariableSymbol* variableSymbol, SgScopeStatement* outerScope, std::vector<SgVariableSymbol*> SymbolArray, int dimSize)
   {
     SgArrayType* baseType = SageBuilder::buildArrayType(SageBuilder::buildDoubleType(), SageBuilder::buildVarRefExp(SymbolArray[0]));

     for(int i=1; i < dimSize-1; ++i)
     {
        SgArrayType* oldType = baseType; 
        SgArrayType* newType = SageBuilder::buildArrayType(oldType, SageBuilder::buildVarRefExp(SymbolArray[i]));
        baseType = newType;
     } 

  // Optionally build a pointer variable so that we can optionally support a C style indexing for the DTEC DSL blocks.
     SgExpression* pointerExp = buildMemberFunctionCall(variableSymbol,"getPointer",NULL,false);
     ROSE_ASSERT(pointerExp != NULL);
     SgPointerType* castType = SageBuilder::buildPointerType(baseType);
     SgCastExp* castExp = SageBuilder::buildCastExp(pointerExp, castType,SgCastExp::e_C_style_cast);
     SgAssignInitializer* assignInitializer = SageBuilder::buildAssignInitializer_nfi(castExp);
     ROSE_ASSERT(assignInitializer != NULL);

  // Build the variable declaration for the pointer to the data.
     SgVariableDeclaration* variableDeclaration  = SageBuilder::buildVariableDeclaration_nfi(pointerVariableName,castType,assignInitializer,outerScope);
     ROSE_ASSERT(variableDeclaration != NULL);

     return variableDeclaration;
   }


SgInitializedName*
DSL_Support::detectVariableDeclarationOfSpecificType (SgNode* astNode, const string & className)
   {
  // Within the stencil DSL we want to interogate the SgAssignInitializer, but we need to generality 
  // in the refactored function to use any SgInitializer (e.g. SgConstructorInitializer, etc.).
  // bool detectedPointVariableDeclaration = false;

     SgInitializedName* return_initializedName = NULL;

  // We need to find variables of type "Point" so that we can construct the associated finite state machines that will 
  // use the same name as a the variable.  This code identifies variable of type "Point" and their associated initializers.
  // The initializers are recognized and define specific semantics used to define events to the finite state machines
  // used to model each "Point" data member.  See below how we recognize functions "getZeros" and "getUnitv" to 
  // setup the constructed finite state machines which we then save in a map for later use.
     SgVariableDeclaration* variableDeclarationForPoint = isSgVariableDeclaration(astNode);
     if (variableDeclarationForPoint != NULL)
        {
       // Get the SgInitializedName from the SgVariableDeclaration.
          SgInitializedName* initializedName = SageInterface::getFirstInitializedName(variableDeclarationForPoint);
#if 0
          printf ("initializedName->get_name() = %s initializedName->get_type() = %s \n",initializedName->get_name().str(),initializedName->get_type()->class_name().c_str());
#endif
          SgClassType* classType = isSgClassType(initializedName->get_type());
#if 0
          if (classType == NULL)
             {
            // Check for SgModifierType and strip away to get at possible SgClassType.
               printf ("initializedName type is not a SgClassType, check for SgModifierType and strip away to get at possible SgClassType (not implemented) \n");
             }
#endif
          if (classType != NULL)
             {
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
               ROSE_ASSERT(classDeclaration != NULL);
#if 0
               printf ("initializedName->get_name()  = %s \n",initializedName->get_name().str());
               printf ("classDeclaration->get_name() = %s \n",classDeclaration->get_name().str());
#endif
            // We might want to be more flexiable about the type of the 2nd parameter (allow SgTypeFloat, SgTypeComplex, etc.).
               if (classDeclaration->get_name() == className)
                  {
                 // Found a variable of type Point.
#if 0
                    printf ("initializedName->get_name()  = %s \n",initializedName->get_name().str());
                    printf ("classDeclaration->get_name() = %s \n",classDeclaration->get_name().str());
#endif
                    return_initializedName = initializedName;

                 // new StencilOffsetFSM();
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
             }
            else
             {
            // If "const" is used, then this will be a SgModifierType.
#if 0
               printf ("initializedName->get_type() = %s \n",initializedName->get_type()->class_name().c_str());
#endif
             }
        }

     return return_initializedName;
   }


SgFunctionCallExp* 
DSL_Support::detectMemberFunctionOfSpecificClassType(
     SgNode* astNode, SgInitializedName* & initializedNameUsedToCallMemberFunction, 
     const string & className, bool isTemplateClass, const string & memberFunctionName, 
     bool isTemplateFunctionInstantiation)
   {
  // Recognize member function calls on "Point" objects so that we can trigger events on those associated finite state machines.

     SgFunctionCallExp* return_functionCallExp = NULL;

     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(astNode);
     if (functionCallExp != NULL)
        {
       // printf ("*** functionCallExp->get_function() = %s \n",functionCallExp->get_function()->class_name().c_str());

          SgDotExp* dotExp = isSgDotExp(functionCallExp->get_function());
          if (dotExp != NULL)
             {
               SgVarRefExp* varRefExp = isSgVarRefExp(dotExp->get_lhs_operand());
               SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(dotExp->get_rhs_operand());

            // Note that varRefExp might be NULL and the member function could still be from the target clas type.
            // We need to allow for this case. But this code handles the simpler case for now.
               if (varRefExp != NULL && memberFunctionRefExp != NULL)
                  {
                    ROSE_ASSERT(varRefExp->get_symbol() != NULL);
                    SgInitializedName* initializedName = varRefExp->get_symbol()->get_declaration();
                    ROSE_ASSERT(initializedName != NULL);

                    string name = initializedName->get_name();

                 // bool isTemplateClass = false;
                    bool isMatchingClassNameType = isMatchingClassType(initializedName->get_type(),className,isTemplateClass);
#if 0
                    printf ("isMatchingClassNameType = %s \n",isMatchingClassNameType ? "true" : "false");
                    printf ("Calling isMatchingMemberFunction() \n");
#endif
                 // bool isTemplateFunctionInstantiation = false;
                    bool isMatchingMemberFunctionName = isMatchingMemberFunction(memberFunctionRefExp,memberFunctionName,isTemplateFunctionInstantiation);
#if 0
                    printf ("isMatchingMemberFunctionName = %s \n",isMatchingMemberFunctionName ? "true" : "false");
#endif
                    if (isMatchingMemberFunctionName == true && isMatchingClassNameType == true)
                       {
#if 0
                         printf ("Found className::memberFunctionName = %s::%s \n",className.c_str(),memberFunctionName.c_str());
#endif
                         return_functionCallExp = functionCallExp;
                         initializedNameUsedToCallMemberFunction = initializedName;
                       }
                  }
             }
        }

     return return_functionCallExp;
   }
















  // ********************************************************
  // DQ (10/24/2014): Added feature for constant expresssion 
  // evaluation. This code below is an advanced version of 
  // that is going into the SageInterface.  It should be 
  // available there shortly and when in place it should be 
  // removed from here and referenced from the SageInterface 
  // namespace.
  // ********************************************************

struct DSL_Support::const_numeric_expr_t DSL_Support::SimpleExpressionEvaluator2::getValueExpressionValue(SgValueExp *valExp)
{   
    struct DSL_Support::const_numeric_expr_t subtreeVal;
    subtreeVal.isIntOnly_ = true;

   if (isSgIntVal(valExp)) {
     subtreeVal.value_ = isSgIntVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgLongIntVal(valExp)) {
     subtreeVal.value_ = isSgLongIntVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgLongLongIntVal(valExp)) {
     subtreeVal.value_ = isSgLongLongIntVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgShortVal(valExp)) {
     subtreeVal.value_ = isSgShortVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgUnsignedIntVal(valExp)) {
     subtreeVal.value_ = isSgUnsignedIntVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgUnsignedLongVal(valExp)) {
     subtreeVal.value_ = isSgUnsignedLongVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgUnsignedLongLongIntVal(valExp)) {
     subtreeVal.value_ = isSgUnsignedLongLongIntVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgUnsignedShortVal(valExp)) {
     subtreeVal.value_ = isSgUnsignedShortVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
   } else if (isSgDoubleVal(valExp)) {
     subtreeVal.value_ = isSgDoubleVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
     subtreeVal.isIntOnly_ = false;
   } else if (isSgFloatVal(valExp)){
     subtreeVal.value_ = isSgFloatVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
     subtreeVal.isIntOnly_ = false;
   } else if (isSgLongDoubleVal(valExp)){
     subtreeVal.value_ = isSgDoubleVal(valExp)->get_value();
     subtreeVal.hasValue_ = true;
     subtreeVal.isIntOnly_ = false;
   }
   return subtreeVal;
 }

 
  // ********************************************************
  // DQ (10/24/2014): Added feature for constant expresssion 
  // evaluation. This code below is an advanced version of 
  // that is going into the SageInterface.  It should be 
  // available there shortly and when in place it should be 
  // removed from here and referenced from the SageInterface 
  // namespace.
  // ********************************************************

 struct DSL_Support::const_numeric_expr_t DSL_Support::SimpleExpressionEvaluator2::evaluateVariableReference(SgVarRefExp *vRef) 
   {
   if (isSgModifierType(vRef->get_type()) == NULL) {
     struct DSL_Support::const_numeric_expr_t val;
     val.value_ = -1;
     val.hasValue_ = false;
     return val;
   }
   if (isSgModifierType(vRef->get_type())->get_typeModifier().get_constVolatileModifier().isConst()) {
     // We know that the var value is const, so get the initialized name and evaluate it
     SgVariableSymbol *sym = vRef->get_symbol();
     SgInitializedName *iName = sym->get_declaration();
     SgInitializer *ini = iName->get_initializer();
                                                                                 
     if (isSgAssignInitializer(ini)) {
       SgAssignInitializer *initializer = isSgAssignInitializer(ini);
       SgExpression *rhs = initializer->get_operand();
       SimpleExpressionEvaluator2 variableEval;
                                                                                                                
       return variableEval.traverse(rhs);
     }
   }
   struct DSL_Support::const_numeric_expr_t val;
   val.hasValue_ = false;
   val.value_ = -1;
   return val;
 }

 
  // ********************************************************
  // DQ (10/24/2014): Added feature for constant expresssion 
  // evaluation. This code below is an advanced version of 
  // that is going into the SageInterface.  It should be 
  // available there shortly and when in place it should be 
  // removed from here and referenced from the SageInterface 
  // namespace.
  // ********************************************************

struct DSL_Support::const_numeric_expr_t DSL_Support::SimpleExpressionEvaluator2::evaluateSynthesizedAttribute(SgNode *node, SynthesizedAttributesList synList) 
{
   if (isSgExpression(node)) {
     if (isSgValueExp(node)) {
       return this->getValueExpressionValue(isSgValueExp(node));
     }
                                                                                                                                                 
     if (isSgVarRefExp(node)) {
      //      std::cout << "Hit variable reference expression!" << std::endl;
       return evaluateVariableReference(isSgVarRefExp(node));
     }
     // Early break out for assign initializer // other possibility?
     if (isSgAssignInitializer(node)) {
       if(synList.at(0).hasValue_){
         return synList.at(0);
       } else { 
         struct DSL_Support::const_numeric_expr_t val;
         val.value_ = -1;
         val.hasValue_ = false;
         return val;
       }
     }
     struct DSL_Support::const_numeric_expr_t evaluatedValue;
     evaluatedValue.hasValue_ = false;
     evaluatedValue.value_ = -1;
     evaluatedValue.isIntOnly_ = false;
     if(isSgBinaryOp(node)){
       if((synList[0].isIntOnly_ == true) && (synList[1].isIntOnly_ == true)){
         evaluatedValue.isIntOnly_ = true;
       }
       // JP The += -= /= operator don't make sense, since we restrict ourselves to const marked variables.
       if(synList[0].hasValue_ && synList[1].hasValue_){
         if (isSgAddOp(node)) {
           assert(synList.size() == 2);
           evaluatedValue.value_ = synList[0].value_ + synList[1].value_ ;
           evaluatedValue.hasValue_ = true;
         } else if (isSgSubtractOp(node)) {
           assert(synList.size() == 2);
           evaluatedValue.value_ = synList[0].value_  - synList[1].value_ ;
           evaluatedValue.hasValue_ = true;
         } else if (isSgMultiplyOp(node)) {
           assert(synList.size() == 2);
           evaluatedValue.value_ = synList[0].value_  * synList[1].value_ ;
           evaluatedValue.hasValue_ = true;
         } else if (isSgDivideOp(node)) {
           assert(synList.size() == 2);
           evaluatedValue.value_ = synList[0].value_  / synList[1].value_ ;
           evaluatedValue.hasValue_ = true;
         } else if (isSgModOp(node)) {
           assert(synList.size() == 2);
           if (synList[0].isIntOnly_ && synList[1].isIntOnly_){
             long a = synList[0].value_;
             long b = synList[1].value_;
             evaluatedValue.value_ = a % b;
             evaluatedValue.isIntOnly_ = true;
           } else {
             std::cerr << "Wrong arguments to modulo operator." << std::endl;
           }
           evaluatedValue.hasValue_ = true;
         }
       } else {
         std::cerr << "Expression is not evaluatable" << std::endl;
         evaluatedValue.hasValue_ = false;
         evaluatedValue.value_ = -1;
         return evaluatedValue;
       }
     } else if(isSgUnaryOp(node)){
       evaluatedValue.isIntOnly_ = synList[0].isIntOnly_;
       if(synList[0].hasValue_ == true){
         if(isSgMinusOp(node)){
           evaluatedValue.value_ = (-1) * synList[0].value_;
           evaluatedValue.hasValue_ = true;
         } else if (isSgUnaryAddOp(node)){
           evaluatedValue.value_ = + synList[0].value_;
           evaluatedValue.hasValue_ = true;
         } else if (isSgCastExp(node)){

        // DQ: check if this is a cast which will not loose precission.
           SgCastExp* castExp = isSgCastExp(node);
           if (castExp->cast_looses_precision() == true)
              {
                evaluatedValue.hasValue_ = false;
                evaluatedValue.value_ = synList[0].value_;
              }
             else
              {
                evaluatedValue.hasValue_ = true;
                evaluatedValue.value_ = synList[0].value_;
              }
         }
       } else {
         std::cerr << "Expression is not evaluatable" << std::endl;
         evaluatedValue.hasValue_ = false;
         evaluatedValue.value_ = -1;
         return evaluatedValue;
       }
     }
//     evaluatedValue.hasValue_ = true;
     return evaluatedValue;
   }
   struct DSL_Support::const_numeric_expr_t evaluatedValue;
   evaluatedValue.hasValue_ = false;
   evaluatedValue.value_ = -1;
   return evaluatedValue;
 }


  // ********************************************************
  // DQ (10/24/2014): Added feature for constant expresssion 
  // evaluation. This code below is an advanced version of 
  // that is going into the SageInterface.  It should be 
  // available there shortly and when in place it should be 
  // removed from here and referenced from the SageInterface 
  // namespace.
  // ********************************************************

struct DSL_Support::const_numeric_expr_t 
DSL_Support::evaluateConstNumericExpression(SgExpression *expr)
{
  SimpleExpressionEvaluator2 eval;
  return eval.traverse(expr);
}


  // This function supports the DSL when constness is not rigidly followed.
SgExpression* 
DSL_Support::defining_expression ( SgNode* root, SgInitializedName* variable )
   {
  // This function is a work around to not knowing now to use some of the better program analysis 
  // in ROSE that should be a more efficient (but maybe less robust) way of doing the same thing.
  // This will for the moment support a concept of finding the only defining declaration for a variable 
  // globally across the program's AST.  As such this is a DSL specific concept and outside of
  // a inter-procedural use-def analysis (which would be better).

#if 0
     printf ("In DSL_Support::defining_expression(): Search the AST for the assignment to variable = %p = %s \n",variable,variable->get_name().str());
#endif

     class AssignmentSetTraversal : public AstSimpleProcessing
        {
          private:
               SgInitializedName* targetVariable;

          public:
               SgExpression* definingRhsExpression;

          public:
               AssignmentSetTraversal ( SgInitializedName* input_targetVariable ) 
                  {
                    targetVariable        = input_targetVariable;
                    definingRhsExpression = NULL;
                  }

               void visit (SgNode* node)
                  {
                    SgAssignOp* assignment = isSgAssignOp(node);
                    if (assignment != NULL)
                       {
                      // Get the lhs:
                         SgExpression* lhs = assignment->get_lhs_operand();
                         SgExpression* rhs = assignment->get_rhs_operand();

                         SgVarRefExp* varRefExp = isSgVarRefExp(lhs);
                         if (varRefExp != NULL)
                            {
                              SgInitializedName* var = varRefExp->get_symbol()->get_declaration();
                              if (var != NULL)
                                 {
                                   ROSE_ASSERT(targetVariable != NULL);
                                   if (var == targetVariable)
                                      {
                                        printf ("Sucess, we have identified the expression used to set the non-member variable = %p = %s \n",targetVariable,targetVariable->get_name().str());
                                        definingRhsExpression = rhs;
                                      }
                                     else
                                      {
#if 0
                                        printf ("variable on lhs does not match target var = %p = %s \n",var,var->get_name().str());
#endif
                                      }
                                 }
                                else
                                 {
                                 }
                            }
                           else
                            {
                              SgBinaryOp* binaryOp = isSgBinaryOp(lhs);

                           // This might be a member variable.
                              SgArrowExp* arrowExp = isSgArrowExp(binaryOp);
                              SgDotExp*   dotExp   = isSgDotExp(binaryOp);
                              if (arrowExp != NULL || dotExp != NULL)
                                 {
#if 0
                                   printf ("Found binaryOp = %p = %s \n",binaryOp,binaryOp->class_name().c_str());
#endif
                                   SgExpression* expression = binaryOp->get_rhs_operand();
                                   ROSE_ASSERT(expression != NULL);

                                   SgVarRefExp* varRefExp = isSgVarRefExp(expression);
                                   if (varRefExp != NULL)
                                      {
#if 0
                                        printf ("Found a SgVarRefExp: varRefExp = %p name = %s \n",varRefExp,SageInterface::get_name(varRefExp).c_str());
#endif
                                        ROSE_ASSERT(varRefExp->get_symbol() != NULL);
                                        SgInitializedName* var = varRefExp->get_symbol()->get_declaration();

                                        if (var == targetVariable)
                                           {
                                             printf ("Sucess, we have identified the expression used to set the member variable = %p = %s \n",targetVariable,targetVariable->get_name().str());
                                             definingRhsExpression = rhs;
                                           }
                                          else
                                           {
#if 0
                                             printf ("variable on lhs does not match target var = %p = %s \n",var,var->get_name().str());
#endif
                                           }
                                      }
                                 }
                                else
                                 {
                                   printf ("lhs not identified as part of DSL: lhs = %p = %s = %s \n",lhs,lhs->class_name().c_str(),lhs->unparseToString().c_str());
                                   ROSE_ASSERT(false);
                                 }
                            }
                       }

                    SgInitializedName* initializedName = isSgInitializedName(node); 
                    if (initializedName != NULL)
                       {
#if 0
                         printf ("In traversal: initializedName = %p = %s \n",initializedName,initializedName->get_name().str());
#endif
                       }
                  }
        };

     ROSE_ASSERT(variable != NULL);

  // Now buid the traveral object and call the traversal (preorder) on the AST subtree.
     AssignmentSetTraversal traversal(variable);
     traversal.traverse(root, preorder);

#if 0
     printf ("Exiting as a test! \n");
     ROSE_ASSERT(false);
#endif

     ROSE_ASSERT(traversal.definingRhsExpression != NULL);

     printf ("Leaving defining_expression(): traversal.definingRhsExpression = %s \n",traversal.definingRhsExpression->unparseToString().c_str());

     return traversal.definingRhsExpression;
   }


void
DSL_Support::outputGeneratedData()
   {
  // DQ (2/3/2016): Added output function for generated data about target DSL abstractions.

     printf ("\n\nOutput of DSL target abstractions (types, functions, and member functions): \n");

     printf ("   --- DSL target types (size = %zu): \n",dsl_type_names.size());
     for (size_t i=0; i < dsl_type_names.size(); i++)
        {
          printf ("      --- type name = %s \n",dsl_type_names[i].c_str());
        }
     printf ("   --- DSL target functions (size = %zu): \n",dsl_function_names.size());
     for (size_t i=0; i < dsl_function_names.size(); i++)
        {
          printf ("      --- function name = %s \n",dsl_function_names[i].c_str());
        }
     printf ("   --- DSL target member functions (size = %zu): \n",dsl_member_function_names.size());
     for (size_t i=0; i < dsl_member_function_names.size(); i++)
        {
          printf ("      --- class = %s member function name = %s \n",dsl_member_function_names[i].first.c_str(),dsl_member_function_names[i].second.c_str());
        }

   }

void
DSL_Support::checkAndResetToMakeConsistantCompilerGenerated ( SgInitializedName* initializedName )
   {
  // DQ (2/15/2015): This makes up for a bug in the ROSE AST (to be fixed later).
  // It seems that the compiler generated mode is not set uniformally between the 
  // starting and the ending source position construct.

     ROSE_ASSERT(initializedName->get_startOfConstruct() != NULL);
     bool isCompilerGenerated_result = initializedName->get_startOfConstruct()->isCompilerGenerated();
     ROSE_ASSERT(initializedName->get_endOfConstruct() != NULL);
     if (isCompilerGenerated_result != initializedName->get_endOfConstruct()->isCompilerGenerated())
        {
#if 0
          initializedName->get_endOfConstruct()->display("In DetectionTraversal::evaluateInheritedAttribute(): error: startOfConstruct()->isCompilerGenerated() != endOfConstruct()->isCompilerGenerated(): debug");
#endif
          initializedName->get_endOfConstruct()->setCompilerGenerated();
        }
     ROSE_ASSERT(isCompilerGenerated_result == initializedName->get_endOfConstruct()->isCompilerGenerated());
   }


#define DEBUG_DETECTED_TYPES 1

bool
DSL_Support::isDslType(SgNode* astNode, string & type_name)
   {
  // Recognition of DSL types (return the associated DSL type name).

     bool returnValue = false;

     SgType* type = isSgType(astNode);
     ROSE_ASSERT(type != NULL);

     SgType* base_type = type->findBaseType();
     ROSE_ASSERT(base_type != NULL);

     SgClassType* classType = isSgClassType(base_type);

     if (classType != NULL)
        {
#if 0
          printf ("In isDslVariable(): case SgClassType: class name = %s \n",classType->get_name().str());
#endif
       // Better version of code.
          SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
          if (classDeclaration != NULL)
             {
            // DQ (3/22/2016): Use new mechanism that will work across translation units.
            // string className = classDeclaration->get_name();
            // string className = SageInterface::generateUniqueName (classDeclaration);
            // string className = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);
               type_name = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);

               string className = type_name;
#if 0
            // DQ (3/22/2016): Output the date collected from the DSL compiler's geneated code.
               printf ("className = %s dsl_type_names.size()            = %zu \n",className.c_str(),dsl_type_names.size());
               for (size_t i = 0; i < dsl_type_names.size(); i++)
                  {
                    printf ("   --- dsl_type_name[%zu] = %s \n",i,dsl_type_names[i].c_str());
                  }
#endif

            // This is just error checking.
               std::vector<std::string>::iterator it = find(dsl_type_names.begin(),dsl_type_names.end(),className);
               if (it != dsl_type_names.end())
                  {
#if DEBUG_DETECTED_TYPES
                    printf ("Detected className = %s typed variable \n",className.c_str());
#endif
                    returnValue = true;

                 // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
                    ROSE_ASSERT(dsl_attribute_map.find(className) != dsl_attribute_map.end());
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
             }
        }

#if 0
     printf ("Found a DSL variable declaration \n");
#endif
#if 0
     variableDeclaration->get_file_info()->display("location of stencil declaration: debug");
#endif

     return returnValue;
   }


#define DEBUG_DETECTED_VARIABLES 1

bool
DSL_Support::isDslVariable(SgNode* astNode)
   {
  // Recognition of DSL variables

     bool returnValue = false;

     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(astNode);
     if (variableDeclaration != NULL)
        {
       // Get the SgInitializedName from the SgVariableDeclaration.
          SgInitializedName* initializedName = SageInterface::getFirstInitializedName(variableDeclaration);

#if 1
          string className;
          bool detectedDslType = isDslType(initializedName->get_type(),className);

          if (detectedDslType == true)
             {
               std::vector<std::string>::iterator it = find(dsl_type_names.begin(),dsl_type_names.end(),className);
               if (it != dsl_type_names.end())
                  {
                 // Save the SgInitializedName associated with the Point type.
#if DEBUG_DETECTED_VARIABLES
                    printf ("Detected className = %s typed variable: initializedName = %p name = %s \n",className.c_str(),initializedName,initializedName->get_name().str());
#endif
                    checkAndResetToMakeConsistantCompilerGenerated(initializedName);

                    if (initializedName->isCompilerGenerated() == false)
                       {
#if 0
                         array_dsl_attribute* dslAttribute = new array_dsl_attribute();
#if 0
                         printf ("Adding (array_dsl_attribute to dsl variable) dslAttribute = %p \n",dslAttribute);
#endif
                         ROSE_ASSERT(dslAttribute != NULL);

                      // virtual void addNewAttribute (std::string s, AstAttribute *a);   
                         initializedName->addNewAttribute(className,dslAttribute);
#endif
                       }
                      else
                       {
                         printf ("Note: initializedName->isCompilerGenerated() == true where we are adding an DSL attribute \n");
                       }

                    returnValue = true;

                 // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
                    ROSE_ASSERT(dsl_attribute_map.find(className) != dsl_attribute_map.end());

                 // We might use a virtual factory function to generate a copy of the attribute (but the copy constructor might work).
                 // dsl_attribute* attribute = new dsl_attribute(dsl_attribute_map[className]);
                 // dsl_attribute* attribute = dsl_attribute_map[className].second.factory_copy();
                 // dsl_attribute attribute_in_map = dsl_attribute_map[className];
                 // dsl_attribute* attribute = dsl_attribute_map[className].factory_copy();
                 // dsl_attribute* attribute = dsl_attribute_map[className];
                    dsl_attribute* attribute = dsl_attribute_map[className]->factory_copy();
                    ROSE_ASSERT(attribute != NULL);

                 // Add the attribute to the SgInitializedName.
                    initializedName->addNewAttribute(className,attribute);
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
             }
#else
          SgType* base_type = initializedName->get_type()->findBaseType();
          ROSE_ASSERT(base_type != NULL);

#error "DEAD CODE!"

       // SgClassType* classType = isSgClassType(initializedName->get_type());
          SgClassType* classType = isSgClassType(base_type);

          if (classType != NULL)
             {
#if 0
               printf ("In isDslVariable(): case SgClassType: class name = %s \n",classType->get_name().str());
#endif
            // Better version of code.
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
               if (classDeclaration != NULL)
                  {
                 // DQ (3/22/2016): Use new mechanism that will work across translation units.
                 // string className = classDeclaration->get_name();
                 // string className = SageInterface::generateUniqueName (classDeclaration);
                    string className = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);
#if 0
                 // DQ (3/22/2016): Output the date collected from the DSL compiler's geneated code.
                    printf ("className = %s dsl_type_names.size()            = %zu \n",className.c_str(),dsl_type_names.size());
                    for (size_t i = 0; i < dsl_type_names.size(); i++)
                       {
                         printf ("   --- dsl_type_name[%zu] = %s \n",i,dsl_type_names[i].c_str());
                       }
#endif
                    std::vector<std::string>::iterator it = find(dsl_type_names.begin(),dsl_type_names.end(),className);
                    if (it != dsl_type_names.end())
                       {
                      // Save the SgInitializedName associated with the Point type.
#if DEBUG_DETECTED_VARIABLES
                         printf ("Detected className = %s typed variable: initializedName = %p name = %s \n",className.c_str(),initializedName,initializedName->get_name().str());
#endif
                         checkAndResetToMakeConsistantCompilerGenerated(initializedName);

#error "DEAD CODE!"

                         if (initializedName->isCompilerGenerated() == false)
                            {
#if 0
                              array_dsl_attribute* dslAttribute = new array_dsl_attribute();
#if 0
                              printf ("Adding (array_dsl_attribute to dsl variable) dslAttribute = %p \n",dslAttribute);
#endif
                              ROSE_ASSERT(dslAttribute != NULL);

                           // virtual void addNewAttribute (std::string s, AstAttribute *a);   
                              initializedName->addNewAttribute(className,dslAttribute);
#endif
                            }
                           else
                            {
                              printf ("Note: initializedName->isCompilerGenerated() == true where we are adding an DSL attribute \n");
                            }

                         returnValue = true;

#error "DEAD CODE!"

                      // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
                         ROSE_ASSERT(dsl_attribute_map.find(className) != dsl_attribute_map.end());

                      // We might use a virtual factory function to generate a copy of the attribute (but the copy constructor might work).
                      // dsl_attribute* attribute = new dsl_attribute(dsl_attribute_map[className]);
                      // dsl_attribute* attribute = dsl_attribute_map[className].second.factory_copy();
                      // dsl_attribute attribute_in_map = dsl_attribute_map[className];
                      // dsl_attribute* attribute = dsl_attribute_map[className].factory_copy();
                      // dsl_attribute* attribute = dsl_attribute_map[className];
                         dsl_attribute* attribute = dsl_attribute_map[className]->factory_copy();
                         ROSE_ASSERT(attribute != NULL);

#error "DEAD CODE!"

                      // Add the attribute to the SgInitializedName.
                         initializedName->addNewAttribute(className,attribute);
#if 0
                         printf ("Exiting as a test! \n");
                         ROSE_ASSERT(false);
#endif
                       }
                  }
             }

#error "DEAD CODE!"

#endif

#if 0
          printf ("Found a DSL variable declaration \n");
#endif
#if 0
          variableDeclaration->get_file_info()->display("location of stencil declaration: debug");
#endif
        }

     return returnValue;
   }

#define DEBUG_DETECTED_VARREFEXP 1

bool
DSL_Support::isDslVarRefExp(SgNode* astNode)
   {
  // DQ (5/5/2016): Need to finish the support for SgVarRefExp.

     bool returnValue = false;

     SgVarRefExp* varRefExp = isSgVarRefExp(astNode);
     if (varRefExp != NULL)
        {
          SgType* type = varRefExp->get_type();
          ROSE_ASSERT(type != NULL);

          string type_name;
          bool detectedDslType = isDslType(type,type_name);

          printf ("type_name = %s \n",type_name.c_str());

          string attribute_name = type_name + "_varRef";

          if (detectedDslType == true)
             {
               returnValue = true;

            // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
               ROSE_ASSERT(dsl_attribute_map.find(attribute_name) != dsl_attribute_map.end());

            // We might use a virtual factory function to generate a copy of the attribute (but the copy constructor might work).
               dsl_attribute* attribute = dsl_attribute_map[attribute_name]->factory_copy();
               ROSE_ASSERT(attribute != NULL);

            // Add the attribute to the SgInitializedName.
               varRefExp->addNewAttribute(attribute_name,attribute);
#if 0
               printf ("Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
             }
        }

     return returnValue;
   }

#define DEBUG_DETECTED_FUNCTIONS 1

bool
DSL_Support::isDslFunction(SgNode* astNode)
   {
  // Recognition of DSL function abstractions (likely friend functions of classes defining types of DSL variables 
  // or functions taking DSL variablews are parameters or returning DSL variables).

     bool returnValue = false;

  // Find the invocation of the stencil operator (via a SgFunctionCallExp).
     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(astNode);
     if (functionCallExp != NULL)
        {
          bool supportedNode = false;

          SgExpression* associatedFunction = functionCallExp->get_function();
          ROSE_ASSERT(associatedFunction != NULL);
#if 1
          printf ("Found SgFunctionCallExp: associatedFunction = %p = %s \n",associatedFunction,associatedFunction->class_name().c_str());
#endif
       // Here we make assumptions on how the stencil is specified in the DSL.
          SgDotExp* dotExp = isSgDotExp(functionCallExp->get_function());
          if (dotExp != NULL)
             {
            // This kind of IR node in a SgFunctionCallExp is supported.
               supportedNode = true;

               bool supportedDotExp = false;

               SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(dotExp->get_rhs_operand());
#if 0
               SgVarRefExp* varRefExp = isSgVarRefExp(dotExp->get_lhs_operand());
            // Check if this is found a bit deeper.
               if (varRefExp == NULL)
                  {
                    ROSE_ASSERT(dotExp->get_lhs_operand() != NULL);
                    SgArrowExp* arrowExp   = isSgArrowExp(dotExp->get_lhs_operand());
                    if (arrowExp != NULL)
                       {
                         varRefExp = isSgVarRefExp(arrowExp->get_rhs_operand());
                       }

                 // DQ (4/1/2016): Added error checking.
                    if (varRefExp == NULL)
                       {
                         printf ("In isDslFunction(): case SgDotExp: Skipping this case: dotExp->get_lhs_operand() = %p = %s \n",dotExp->get_lhs_operand(),dotExp->get_lhs_operand()->class_name().c_str());
                       }
                 // ROSE_ASSERT(varRefExp != NULL);
                  }
#endif
            // if (varRefExp != NULL && memberFunctionRefExp != NULL)
               if (memberFunctionRefExp != NULL)
                  {
                    supportedDotExp = true;

#if 0
                 // if (initializedNameList.find(initializedName) != initializedNameList.end())
                    SgVariableSymbol* variableSymbol = isSgVariableSymbol(varRefExp->get_symbol());
                    SgInitializedName* initializedName = variableSymbol->get_declaration();
                    ROSE_ASSERT(initializedName != NULL);
#if 0
                    SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp->get_symbol();
                    printf ("In isDslFunction(): case SgDotExp: found function ref name = %s from variable reference for variable name = %s \n",memberFunctionSymbol->get_name().str(),initializedName->get_name().str());
#endif
#endif
                 // Add attribute
#if 0
                    array_assignment_operator_dsl_attribute* dslAttribute = new array_assignment_operator_dsl_attribute();
#if 1
                    printf ("Adding (array_assignment_operator_dsl_attribute to dsl function call) dslAttribute = %p \n",dslAttribute);
#endif
                    ROSE_ASSERT(dslAttribute != NULL);

                 // virtual void addNewAttribute (std::string s, AstAttribute *a);   
                    functionCallExp->addNewAttribute(memberFunctionSymbol->get_name(),dslAttribute);
#endif
#if 0
                    array_refexp_dsl_attribute* dslAttribute_refexp = new array_refexp_dsl_attribute();
#if 0
                    printf ("Adding (array_refexp_dsl_attribute to dsl var ref) dslAttribute = %p \n",dslAttribute_refexp);
#endif
                    ROSE_ASSERT(dslAttribute_refexp != NULL);

                 // virtual void addNewAttribute (std::string s, AstAttribute *a);   
                    varRefExp->addNewAttribute(initializedName->get_name(),dslAttribute_refexp);
#endif
                  }

#if 0
               printf ("Detected SgDotExp in evaluation of function call: varRefExp = %p arrowExp->get_lhs_operand() = %s memberFunctionRefExp = %p \n",
                    varRefExp,dotExp->get_lhs_operand()->class_name().c_str(),memberFunctionRefExp);
#endif
               ROSE_ASSERT(memberFunctionRefExp != NULL);
               SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionRefExp->getAssociatedMemberFunctionDeclaration();
               string memberFunctionName = SageInterface::generateUniqueNameForUseAsIdentifier(memberFunctionDeclaration);
#if 0
               printf ("In isDslFunction(): case SgArrowExp: found memberFunctionName = %s \n",memberFunctionName.c_str());
#endif
               SgClassDeclaration* classDeclaration = memberFunctionDeclaration->get_associatedClassDeclaration();
               ROSE_ASSERT(classDeclaration != NULL);
               string associatedClassName = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);
#if 0
               printf ("associatedClassName = %s memberFunctionName = %s \n",associatedClassName.c_str(),memberFunctionName.c_str());
#endif
               std::pair< std::string,std::string> namePair(associatedClassName,memberFunctionName);

               std::vector<std::pair< std::string,std::string>>::iterator it = find(dsl_member_function_names.begin(),dsl_member_function_names.end(),namePair);
               if (it != dsl_member_function_names.end())
                  {
#if DEBUG_DETECTED_FUNCTIONS
                    printf ("Detected member function call from DSL variable:  memberFunctionName = %s \n",memberFunctionName.c_str());
#endif
                    returnValue = true;
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                 // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
                    ROSE_ASSERT(dsl_attribute_map.find(memberFunctionName) != dsl_attribute_map.end());

                 // We might use a virtual factory function to generate a copy of the attribute (but the copy constructor might work).
                 // dsl_attribute* attribute = dsl_attribute_map[className]->factory_copy();
                    dsl_attribute* attribute = dsl_attribute_map[memberFunctionName]->factory_copy();
                    ROSE_ASSERT(attribute != NULL);

                    functionCallExp->addNewAttribute(memberFunctionName,attribute);
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }

#if 0
            // DQ (2/16/2015): Check for operator*() in "const Point hi = getOnes() * scalar;"
            // This is actually the better and most general test for a specific member function 
            // call (since calling off of a variable is not general enough).
               SgFunctionCallExp* nestedFunctionCallExp = isSgFunctionCallExp(dotExp->get_lhs_operand());
               if (nestedFunctionCallExp != NULL)
                  {
                    SgExpression* expression = functionCallExp->get_function();
                    ROSE_ASSERT(expression != NULL);

                    printf ("What is this: expression = %p = %s \n",expression,expression->class_name().c_str());


                    SgType* returnType = nestedFunctionCallExp->get_type();
                    ROSE_ASSERT(returnType != NULL);
#if 0
                    printf ("returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif
                    SgType* base_type = returnType->findBaseType();
                    ROSE_ASSERT(base_type != NULL);

                    SgClassType* classType = isSgClassType(base_type);
                    if (classType != NULL)
                       {
                         SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
                         if (classDeclaration != NULL)
                            {
                           // string className = classDeclaration->get_name();
                              string className = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);
#if 0
                              printf ("In isDslFunction(): case SgDotExp: case function returning DSL type: class name = %s \n",className.c_str());
#endif
                            }
                       }
#if 1
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
#endif

            // Make sure that any case we see is processed.
               if (supportedDotExp == false)
                  {
                    ROSE_ASSERT(dotExp->get_lhs_operand() != NULL);
                    printf ("In isDslFunction(): case SgDotExp: dotExp->get_lhs_operand() = %s case not handled \n",dotExp->get_lhs_operand()->class_name().c_str());
#if 1
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
             }

       // This case does not appear to be used for the DSL abstractions.
          SgArrowExp* arrowExp = isSgArrowExp(functionCallExp->get_function());
          if (arrowExp != NULL)
             {
            // This kind of IR node in a SgFunctionCallExp is supported.
               supportedNode = true;

               bool supportedArrowExp = false;

            // This variable is not used anymore.
            // SgVarRefExp* varRefExp = isSgVarRefExp(arrowExp->get_lhs_operand());

               SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(arrowExp->get_rhs_operand());
               ROSE_ASSERT(arrowExp->get_lhs_operand() != NULL);
#if 0
               printf ("Detected SgArrowExp in evaluation of function call: varRefExp = %p arrowExp->get_lhs_operand() = %s memberFunctionRefExp = %p \n",
                    varRefExp,arrowExp->get_lhs_operand()->class_name().c_str(),memberFunctionRefExp);
#endif

               ROSE_ASSERT(memberFunctionRefExp != NULL);
               SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionRefExp->getAssociatedMemberFunctionDeclaration();


            // if (varRefExp != NULL && memberFunctionRefExp != NULL)
               if (memberFunctionRefExp != NULL)
                  {
                    supportedArrowExp = true;

                 // string memberFunctionName = memberFunctionRefExp->get_symbol()->get_name();
                    string memberFunctionName = SageInterface::generateUniqueNameForUseAsIdentifier(memberFunctionDeclaration);
#if 0
                    printf ("In isDslFunction(): case SgArrowExp: found memberFunctionName = %s \n",memberFunctionName.c_str());
#endif
                 // std::vector<std::string>::iterator it = find(dsl_function_names.begin(),dsl_function_names.end(),memberFunctionName);
                 // string associatedClassName = "xxx";
                 // SgClassDeclaration* get_associatedClassDeclaration() const
                    SgClassDeclaration* classDeclaration = memberFunctionDeclaration->get_associatedClassDeclaration();
                    ROSE_ASSERT(classDeclaration != NULL);
                    string associatedClassName = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);
#if 0
                    printf ("associatedClassName = %s memberFunctionName = %s \n",associatedClassName.c_str(),memberFunctionName.c_str());
#endif
                    std::pair< std::string,std::string> namePair(associatedClassName,memberFunctionName);

                    std::vector<std::pair< std::string,std::string>>::iterator it = find(dsl_member_function_names.begin(),dsl_member_function_names.end(),namePair);
                    if (it != dsl_member_function_names.end())
                       {
#if DEBUG_DETECTED_FUNCTIONS
                         printf ("Detected member function call from DSL variable pointer:  memberFunctionName = %s \n",memberFunctionName.c_str());
#endif
                         returnValue = true;
#if 1
                         printf ("Exiting as a test! \n");
                         ROSE_ASSERT(false);
#endif
                       }
                  }
                 else
                  {
                 // printf ("Note: In case of SgArrowExp: but varRefExp == NULL and/or memberFunctionRefExp == NULL \n");
                    printf ("Note: In case of SgArrowExp: but memberFunctionRefExp == NULL \n");
#if 1
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }

               if (supportedArrowExp == false)
                  {
                    ROSE_ASSERT(arrowExp->get_lhs_operand() != NULL);
                    printf ("In isDslFunction(): case SgArrowExp: arrowExp->get_lhs_operand() = %s case not handled \n",arrowExp->get_lhs_operand()->class_name().c_str());
#if 1
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
             }

       // This case does not appear to be used for the DSL abstractions.
       // This is the case for the apply function in the ShiftCalculus.
          SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(functionCallExp->get_function());
          if (memberFunctionRefExp != NULL)
             {
            // This kind of IR node in a SgFunctionCallExp is supported.
               supportedNode = true;

            // We might have to narrow these to the specific cases were are interested in.
               SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp->get_symbol();
#if 0
               string tmp_memberFunctionName = memberFunctionSymbol->get_name();
               printf ("In isDslFunction(): case SgMemberFunctionRefExp: tmp_memberFunctionName = %s \n",tmp_memberFunctionName.c_str());
#endif
               SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionSymbol->get_declaration();
               ROSE_ASSERT(memberFunctionDeclaration != NULL);

               string memberFunctionName = SageInterface::generateUniqueNameForUseAsIdentifier(memberFunctionDeclaration);
#if 0
               printf ("In isDslFunction(): memberFunctionName = %s \n",memberFunctionName.c_str());
#endif
               SgClassDeclaration* classDeclaration = memberFunctionDeclaration->get_associatedClassDeclaration();
               ROSE_ASSERT(classDeclaration != NULL);
               string associatedClassName = SageInterface::generateUniqueNameForUseAsIdentifier(classDeclaration);
#if 0
               printf ("In isDslFunction(): associatedClassName = %s memberFunctionName = %s \n",associatedClassName.c_str(),memberFunctionName.c_str());
#endif
            // string associatedClassName = "xxx";
               std::pair< std::string,std::string> namePair(associatedClassName,memberFunctionName);

               std::vector<std::pair< std::string,std::string>>::iterator it = find(dsl_member_function_names.begin(),dsl_member_function_names.end(),namePair);
               if (it != dsl_member_function_names.end())
                  {
#if DEBUG_DETECTED_FUNCTIONS
                    printf ("Detected member function call from DSL (SgMemberFunctionRefExp):  associatedClassName = %s memberFunctionName = %s \n",associatedClassName.c_str(),memberFunctionName.c_str());
#endif
                    returnValue = true;

                 // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
                    ROSE_ASSERT(dsl_attribute_map.find(memberFunctionName) != dsl_attribute_map.end());

                 // We might use a virtual factory function to generate a copy of the attribute (but the copy constructor might work).
                 // dsl_attribute* attribute = dsl_attribute_map[className]->factory_copy();
                    dsl_attribute* attribute = dsl_attribute_map[memberFunctionName]->factory_copy();
                    ROSE_ASSERT(attribute != NULL);
#if 1
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
#if 0
               printf ("Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
             }

       // This case does not appear to be used for the DSL abstractions.
          SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(functionCallExp->get_function());
          if (functionRefExp != NULL)
             {
            // This kind of IR node in a SgFunctionCallExp is supported.
               supportedNode = true;

            // string functionName = functionRefExp->get_symbol()->get_name();
               SgFunctionDeclaration* functionDeclaration = functionRefExp->get_symbol()->get_declaration();
               ROSE_ASSERT(functionDeclaration != NULL);
               string functionName = SageInterface::generateUniqueNameForUseAsIdentifier(functionDeclaration);
#if 1
               printf ("In isDslFunction(): case SgFunctionRefExp: found functionName = %s \n",functionName.c_str());
#endif
               std::vector<std::string>::iterator it = find(dsl_function_names.begin(),dsl_function_names.end(),functionName);
               if (it != dsl_function_names.end())
                  {
#if DEBUG_DETECTED_FUNCTIONS
                    printf ("Detected function call from DSL SgFunctionRefExp:  functionName = %s \n",functionName.c_str());
#endif
                    returnValue = true;

                 // At this point we have the information that we need to lookup the attribute in the dsl_attribute_map.
                    ROSE_ASSERT(dsl_attribute_map.find(functionName) != dsl_attribute_map.end());

                 // We might use a virtual factory function to generate a copy of the attribute (but the copy constructor might work).
                 // dsl_attribute* attribute = dsl_attribute_map[className]->factory_copy();
                    dsl_attribute* attribute = dsl_attribute_map[functionName]->factory_copy();
                    ROSE_ASSERT(attribute != NULL);
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
#if 1
               printf ("Found a SgFunctionRefExp: functionDeclaration = %p = %s \n",functionDeclaration,functionDeclaration->get_name().str());
               ROSE_ASSERT(false);
#endif
             }


       // Make a list of the cases we need to consider!
       // SgVarRefExp* varRefExp = isSgVarRefExp(functionCallExp->get_function());
          SgVarRefExp* varRefExp = isSgVarRefExp(functionCallExp->get_function());
          if (varRefExp != NULL)
             {
            // Note this this case only happens outside of the DSL implementation (so we will ignore it for now).
            // It is a function call from a function pointer variable in a template function in both: 
            //    include-staging/g++_HEADERS/hdrs4/ext/string_conversions.h, and
            //    include-staging/g++_HEADERS/hdrs4/ostream
            // that I do not yet understand (and have not investegated further).
#if 1
               printf ("Case of functionCallExp->get_function() == SgVarRefExp not implemented! \n");
#endif
               supportedNode = true;
#if 0
               varRefExp->get_file_info()->display("Case of functionCallExp->get_function() == SgVarRefExp not implemented!");
#endif
#if 1
            // DQ (5/4/2016): I forget why we are supporting this case.
               printf ("Error: Case of functionCallExp->get_function() == SgVarRefExp not implemented! \n");
               ROSE_ASSERT(false);
#endif
             }

       // Test if the IR node in a SgFunctionCallExp was supported.
       // We might have to add more cases if we find something not supported.
          if (supportedNode == false)
             {
               SgExpression* associatedFunction = functionCallExp->get_function();
               ROSE_ASSERT(associatedFunction != NULL);
#if 1
               printf ("In support of SgFunctionCallExp: associatedFunction = %p = %s \n",associatedFunction,associatedFunction->class_name().c_str());
#endif
#if 1
               printf ("Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
             }



       // Now add attributes to the function arguments.
          SgExprListExp* argumentList = functionCallExp->get_args();
          ROSE_ASSERT(argumentList != NULL);

          for (size_t i = 0; i < argumentList->get_expressions().size(); i++)
             {
               SgExpression* arg = argumentList->get_expressions()[i];
               ROSE_ASSERT(arg != NULL);

               SgVarRefExp* varRefExp = isSgVarRefExp(arg);
               if (varRefExp != NULL)
                  {
#if 0
                   array_refexp_dsl_attribute* dslAttribute_refexp = new array_refexp_dsl_attribute();
#if 1
                   printf ("Adding (array_refexp_dsl_attribute to dsl var ref) dslAttribute = %p \n",dslAttribute_refexp);
#endif
                   ROSE_ASSERT(dslAttribute_refexp != NULL);

                // virtual void addNewAttribute (std::string s, AstAttribute *a);   
                   varRefExp->addNewAttribute("varRef",dslAttribute_refexp);
#endif
                  }

               SgValueExp* valueExp = isSgValueExp(arg);
               if (valueExp != NULL)
                  {
#if 0
                   value_refexp_dsl_attribute* dslAttribute_value = new value_refexp_dsl_attribute();
#if 1
                   printf ("Adding (value_refexp_dsl_attribute to dsl value) dslAttribute = %p \n",dslAttribute_value);
#endif
                   ROSE_ASSERT(dslAttribute_value != NULL);

                // virtual void addNewAttribute (std::string s, AstAttribute *a);   
                   valueExp->addNewAttribute("value",dslAttribute_value);
#endif
                  }
             }
        }

     return returnValue;
   }


bool DSL_Support::isDslMemberFunction(SgNode* astNode)
   {
  // Note clear if we need this function (the seperation into DSL member function
  // might have a lot of redundant code with the isDslFunction() function above).

  // Recognition of DSL member function abstractions (member functions of classes defining types of DSL variables).

     bool returnValue = false;

     return returnValue;
   }


bool DSL_Support::isDslAbstraction(SgNode* astNode)
   {
  // Detection of target abstractions.

  // The return value could be the associated attribute, or this function could add the attribute directly.
  // I think it is better for this function to add the attribute.

     bool returnValue = false;

     bool detectedDslVariable       = isDslVariable(astNode);
     bool detectedDslFunction       = isDslFunction(astNode);
  // bool detectedDslMemberFunction = isDslMemberFunction(astNode);

     bool detectedDslVarRefExp = isDslVarRefExp(astNode);

#if 0
     if (detectedDslVarRefExp == true)
        {
          printf ("Found DSL SgVarRefExp \n");
          ROSE_ASSERT(false);
        }
#endif

  // if (detectedDslVariable == true || detectedDslFunction == true || detectedDslMemberFunction == true)
  // if (detectedDslVariable == true || detectedDslFunction == true)
     if (detectedDslVariable == true || detectedDslFunction == true || detectedDslVarRefExp == true)
        {
       // Identify the correct attribute and attach it to the IR node.

          if (detectedDslVariable == true)
             {
            // Select the attribute for this DSL variable.
               ROSE_ASSERT(detectedDslFunction == false);
               ROSE_ASSERT(detectedDslVarRefExp == false);
#if 1
               printf ("Identified a DSL variable abstraction: astNode = %p = %s = %s \n",astNode,astNode->class_name().c_str(),SageInterface::get_name(astNode).c_str());
#endif
             }

          if (detectedDslFunction == true)
             {
            // Select the attribute for this DSL function.
               ROSE_ASSERT(detectedDslVariable == false);
               ROSE_ASSERT(detectedDslVarRefExp == false);
#if 1
               printf ("Identified a DSL function abstraction: astNode = %p = %s = %s \n",astNode,astNode->class_name().c_str(),SageInterface::get_name(astNode).c_str());
#endif
             }

          if (detectedDslVarRefExp == true)
             {
            // Select the attribute for this DSL variable.
               ROSE_ASSERT(detectedDslVariable == false);
               ROSE_ASSERT(detectedDslFunction == false);
#if 1
               printf ("Identified a DSL varRefExp abstraction: astNode = %p = %s = %s \n",astNode,astNode->class_name().c_str(),SageInterface::get_name(astNode).c_str());
#endif
             }

#if 0
          printf ("Identified a DSL abstraction: astNode = %p = %s = %s \n",astNode,astNode->class_name().c_str(),SageInterface::get_name(astNode).c_str());
#endif
          returnValue = true;
        }

     return returnValue;
   }


VariableIdMapping variableIdMapping;

// Control generation of DOT graphs of the AST for debugging.
#define DEBUG_USING_DOT_GRAPHS 1

int
DSL_Support::dslProcessing(SgProject* project)
   {
  // This is the main processing function for any DSL compiler built using this EDSL ROSE infrastructure.

     int status = 0;

     try
        {
          variableIdMapping.computeVariableSymbolMapping(project);
        }
     catch(char* str)
        {
          cout << "*Exception raised: " << str << endl;
        } 
     catch(const char* str) 
        {
          cout << "Exception raised: " << str << endl;
        } 
     catch(string str)
        {
          cout << "Exception raised: " << str << endl;
        }

  // variableIdMapping.toStream(cout);

  // DQ (3/21/2016): Call the support to generate unique names for class and function declarations. These
  // names will be unique across translation units (which re require to generate code for the DSL compiler).
     SageInterface::computeUniqueNameForUseAsIdentifier(project);

#if 1
     printf ("variableIdMapping.getVariableIdSet().size() = %zu \n",variableIdMapping.getVariableIdSet().size());
     ROSE_ASSERT(variableIdMapping.getVariableIdSet().size() > 0);
#endif

#if 0
     printf ("Exiting as a test after calling variableIdMapping.computeVariableSymbolMapping(project) \n");
     ROSE_ASSERT(false);
#endif

#if 0
     printf ("Calling constant folding \n");
     ConstantFolding::constantFoldingOptimization(project,false);

#if 0
     printf ("Exiting as a test after calling ConstantFolding::constantFoldingOptimization() \n");
     ROSE_ASSERT(false);
#endif
#endif

  // DQ (2/8/2015): Find the associated SgFile so we can restrict processing to the current file.
     ROSE_ASSERT(project->get_fileList().empty() == false);
     SgFile* firstFile = project->get_fileList()[0];
     ROSE_ASSERT(firstFile != NULL);

#if DEBUG_USING_DOT_GRAPHS
  // generateDOTforMultipleFile(*project);
     generateDOT(*project,"_before_transformation");
  // generateDOT_withIncludes(*project,"_before_transformation");
  // AstDOTGeneration astdotgen;
  // astdotgen.generateWithinFile(firstFile,DOTGeneration<SgNode*>::TOPDOWNBOTTOMUP,"_before_transformation");
#endif
#if DEBUG_USING_DOT_GRAPHS && 1
     const int MAX_NUMBER_OF_IR_NODES_TO_GRAPH_FOR_WHOLE_GRAPH = 12000;
#endif
#if DEBUG_USING_DOT_GRAPHS && 1
  // Output an optional graph of the AST (the whole graph, of bounded complexity, when active)
     generateAstGraph(project,MAX_NUMBER_OF_IR_NODES_TO_GRAPH_FOR_WHOLE_GRAPH,"_before");
#endif

  // DQ (3/22/2016): Output the date collected from the DSL compiler's geneated code.
     printf ("dsl_type_names.size()            = %zu \n",dsl_type_names.size());
     for (size_t i = 0; i < dsl_type_names.size(); i++)
        {
          printf ("   --- dsl_type_name[%zu] = %s \n",i,dsl_type_names[i].c_str());
        }

     printf ("dsl_function_names.size()        = %zu \n",dsl_function_names.size());
     for (size_t i = 0; i < dsl_function_names.size(); i++)
        {
          printf ("   --- dsl_function_name[%zu] = %s \n",i,dsl_function_names[i].c_str());
        }

     printf ("dsl_member_function_names.size() = %zu \n",dsl_member_function_names.size());
     for (size_t i = 0; i < dsl_member_function_names.size(); i++)
        {
          printf ("   --- dsl_member_function_name[%zu] = (%s,%s) \n",i,dsl_member_function_names[i].first.c_str(),dsl_member_function_names[i].second.c_str());
        }

     printf ("dsl_attribute_map.size()         = %zu \n",dsl_attribute_map.size());
     size_t counter = 0;
  // for (std::map<std::string,dsl_attribute>::iterator i = dsl_attribute_map.begin(); i != dsl_attribute_map.end(); i++)
     for (std::map<std::string,dsl_attribute*>::iterator i = dsl_attribute_map.begin(); i != dsl_attribute_map.end(); i++)
        {
       // printf ("   --- dsl_attribute_map: counter = %zu value = (%s,%p) \n",counter,i->first.c_str(),i->second.c_str());
          printf ("   --- dsl_attribute_map: counter = %zu value = (%s,dsl_attribute value) \n",counter,i->first.c_str());
          counter++;
        }

#if 0
     printf ("\nExiting after output of generated code for DSL compiler \n");
     ROSE_ASSERT(false);
#endif

  // Generate maps from generated DSL data structures.
     DSL_Support::outputGeneratedData();

  // Build the inherited attribute
     Detection_InheritedAttribute inheritedAttribute;

  // Define the traversal
  // DetectionTraversal shiftCalculus_DetectionTraversal;
     DetectionTraversal shiftCalculus_DetectionTraversal(project);

#if 1
     printf ("\n*************************************************************************** \n");
     printf ("Call the Detection traversal starting at the project (root) node of the AST \n");
     printf ("*************************************************************************** \n\n");
#endif

  // Call the traversal starting at the project (root) node of the AST
  // Detection_SynthesizedAttribute result = shiftCalculus_DetectionTraversal.traverse(project,inheritedAttribute);
     Detection_SynthesizedAttribute result = shiftCalculus_DetectionTraversal.traverseWithinFile(firstFile,inheritedAttribute);

#if 1
     printf ("\n********************************************************************************* \n");
     printf ("DONE: Call the Detection traversal starting at the project (root) node of the AST \n");
     printf ("********************************************************************************* \n\n");
#endif

#if DEBUG_USING_DOT_GRAPHS
  // generateDOTforMultipleFile(*project);
     generateDOT(*project,"_after_transformation");
  // generateDOT_withIncludes(*project,"_before_transformation");
  // AstDOTGeneration astdotgen;
  // astdotgen.generateWithinFile(firstFile,DOTGeneration<SgNode*>::TOPDOWNBOTTOMUP,"_before_transformation");
#endif


  // Abstraction of evaluation is similar to the previous implementation.

  // Steps not yet in this version of the code.
  // Connection to HPC code generation is through generation of nieve affine loops (same as in array translator project).

  // Call the HPC code generation (same as for Stencil abstraction code generator).

  // Generate defined number of variants via calls to the HPC code generator API.

  // Ignore selection of optimial generated loops (or construct connection to OpenTuner for autotuning).

     return status;
   }

// Implementation of dsl_attribute support.

dsl_attribute::dsl_attribute() {}

dsl_attribute::~dsl_attribute() {}

// virtual dsl_attribute* factory_copy() { return NULL; };
dsl_attribute* 
dsl_attribute::factory_copy()
   {
     printf ("ERROR: base class virtual function called: dsl_attribute::factory_copy() \n");
     ROSE_ASSERT(false);

     return NULL;
   };

string
dsl_attribute::toString()
   {
     return "DSL_Attribute";
   }

string 
dsl_attribute::additionalNodeOptions()
   {
  // Base class additionalNodeOptions() function should be an error to be called.

     printf ("Error: base class function called: needs an implementation on the derived function \n");
#ifndef SKIP_ROSE_HEADERS
     ROSE_ASSERT(false);
#endif
  // return "fillcolor=\"green\",style=filled";
     return "";
   }

string
dsl_attribute::get_name()
   {
     return "DSL-child";
   }

string
dsl_attribute::get_color()
   {
#if 0
  // Base class get_color() function should be an error to be called.

     printf ("Error: base class function called: needs an implementation on the derived function \n");
     ROSE_ASSERT(false);

     return "";
#else
     return "blue";
#endif
   }

vector<AstAttribute::AttributeEdgeInfo>
dsl_attribute::additionalEdgeInfo()
   {
     vector<AstAttribute::AttributeEdgeInfo> v;

     vector<SgNode*>::iterator i = dslChildren.begin();
     while ( i != dslChildren.end() )
        {
#ifndef SKIP_ROSE_HEADERS
          ROSE_ASSERT(currentNode != NULL);
#endif
#if 0
          printf ("Adding an edge from %p = %s to %p = %s \n",currentNode,currentNode->class_name().c_str(),*i,(*i)->class_name().c_str());
#endif
          string name  = get_name();
          string color = get_color();

       // string options = " arrowsize=7.0 style=\"setlinewidth(7)\" constraint=false color=" + color + " ";
          string options = " arrowsize=4.0 style=\"setlinewidth(7)\" constraint=true color=" + color + " ";

#ifndef SKIP_ROSE_HEADERS
          AstAttribute::AttributeEdgeInfo additional_edge ( (SgNode*) currentNode,*i,name,options);

          v.push_back(additional_edge);
#endif
          i++;
        }

     return v;
   }

