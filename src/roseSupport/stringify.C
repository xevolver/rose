// DO NOT EDIT -- This file was generated by /home/matzke/mounts/GS-CAD/ROSE/sources/devel/scripts/stringify.pl.

#include "stringify.h"
#include <cassert>
#include <cstdio>
#include <cstring>
#include <sstream>

namespace rose {

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AST_Graph::pointerHandling is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/astVisualization/astGraph.h:13
/** Converts an enum of type AST_Graph::pointerHandling to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAST_Graph_pointerHandling(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "graph_NULL"; break;
        case 1l: retval = "do_not_graph_NULL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AST_Graph::pointerHandling)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AST_Graph::pointerHandling::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AST_Graph::traversalType is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/astVisualization/astGraph.h:20
/** Converts an enum of type AST_Graph::traversalType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAST_Graph_traversalType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "memory_pool_traversal"; break;
        case 1l: retval = "whole_graph_AST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AST_Graph::traversalType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AST_Graph::traversalType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AbstractMemoryObject::IndexSet::Index_type is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/abstractMemoryObject/memory_object_impl.h:84
/** Converts an enum of type AbstractMemoryObject::IndexSet::Index_type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAbstractMemoryObjectIndexSetIndex_type(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Integer_type"; break;
        case 1l: retval = "Unknown_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AbstractMemoryObject::IndexSet::Index_type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AbstractMemoryObject::IndexSet::Index_type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmInstructionCondition is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/armInstructionEnum.h:124
/** Converts an enum of type ArmInstructionCondition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmInstructionCondition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "arm_cond_unknown"; break;
        case 1l: retval = "arm_cond_eq"; break;
        case 2l: retval = "arm_cond_ne"; break;
        case 3l: retval = "arm_cond_hs"; break;
        case 4l: retval = "arm_cond_lo"; break;
        case 5l: retval = "arm_cond_mi"; break;
        case 6l: retval = "arm_cond_pl"; break;
        case 7l: retval = "arm_cond_vs"; break;
        case 8l: retval = "arm_cond_vc"; break;
        case 9l: retval = "arm_cond_hi"; break;
        case 10l: retval = "arm_cond_ls"; break;
        case 11l: retval = "arm_cond_ge"; break;
        case 12l: retval = "arm_cond_lt"; break;
        case 13l: retval = "arm_cond_gt"; break;
        case 14l: retval = "arm_cond_le"; break;
        case 15l: retval = "arm_cond_al"; break;
        case 16l: retval = "arm_cond_nv"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ArmInstructionCondition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmInstructionCondition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmInstructionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/armInstructionEnum.h:19
/** Converts an enum of type ArmInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmInstructionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "arm_unknown_instruction"; break;
        case 1l: retval = "arm_adc"; break;
        case 2l: retval = "arm_adcs"; break;
        case 3l: retval = "arm_add"; break;
        case 4l: retval = "arm_adds"; break;
        case 5l: retval = "arm_and"; break;
        case 6l: retval = "arm_ands"; break;
        case 7l: retval = "arm_b"; break;
        case 8l: retval = "arm_bic"; break;
        case 9l: retval = "arm_bics"; break;
        case 10l: retval = "arm_bkpt"; break;
        case 11l: retval = "arm_bl"; break;
        case 12l: retval = "arm_blx"; break;
        case 13l: retval = "arm_bx"; break;
        case 14l: retval = "arm_bxj"; break;
        case 15l: retval = "arm_clz"; break;
        case 16l: retval = "arm_cmn"; break;
        case 17l: retval = "arm_cmp"; break;
        case 18l: retval = "arm_eor"; break;
        case 19l: retval = "arm_eors"; break;
        case 20l: retval = "arm_ldm"; break;
        case 21l: retval = "arm_ldmda"; break;
        case 22l: retval = "arm_ldmdb"; break;
        case 23l: retval = "arm_ldmia"; break;
        case 24l: retval = "arm_ldmib"; break;
        case 25l: retval = "arm_ldr"; break;
        case 26l: retval = "arm_ldrb"; break;
        case 27l: retval = "arm_ldrbt"; break;
        case 28l: retval = "arm_ldrd"; break;
        case 29l: retval = "arm_ldrsb"; break;
        case 30l: retval = "arm_ldrsh"; break;
        case 31l: retval = "arm_ldrt"; break;
        case 32l: retval = "arm_ldruh"; break;
        case 33l: retval = "arm_mla"; break;
        case 34l: retval = "arm_mlas"; break;
        case 35l: retval = "arm_mov"; break;
        case 36l: retval = "arm_movs"; break;
        case 37l: retval = "arm_mrs"; break;
        case 38l: retval = "arm_msr"; break;
        case 39l: retval = "arm_mul"; break;
        case 40l: retval = "arm_muls"; break;
        case 41l: retval = "arm_mvn"; break;
        case 42l: retval = "arm_mvns"; break;
        case 43l: retval = "arm_orr"; break;
        case 44l: retval = "arm_orrs"; break;
        case 45l: retval = "arm_qadd"; break;
        case 46l: retval = "arm_qdadd"; break;
        case 47l: retval = "arm_qdsub"; break;
        case 48l: retval = "arm_qsub"; break;
        case 49l: retval = "arm_rsb"; break;
        case 50l: retval = "arm_rsbs"; break;
        case 51l: retval = "arm_rsc"; break;
        case 52l: retval = "arm_rscs"; break;
        case 53l: retval = "arm_sbc"; break;
        case 54l: retval = "arm_sbcs"; break;
        case 55l: retval = "arm_setend"; break;
        case 56l: retval = "arm_smlabb"; break;
        case 57l: retval = "arm_smlabt"; break;
        case 58l: retval = "arm_smlal"; break;
        case 59l: retval = "arm_smlalbb"; break;
        case 60l: retval = "arm_smlalbt"; break;
        case 61l: retval = "arm_smlals"; break;
        case 62l: retval = "arm_smlaltb"; break;
        case 63l: retval = "arm_smlaltt"; break;
        case 64l: retval = "arm_smlatb"; break;
        case 65l: retval = "arm_smlatt"; break;
        case 66l: retval = "arm_smlawb"; break;
        case 67l: retval = "arm_smlawt"; break;
        case 68l: retval = "arm_smluwb"; break;
        case 69l: retval = "arm_smluwt"; break;
        case 70l: retval = "arm_smulbb"; break;
        case 71l: retval = "arm_smulbt"; break;
        case 72l: retval = "arm_smull"; break;
        case 73l: retval = "arm_smulls"; break;
        case 74l: retval = "arm_smultb"; break;
        case 75l: retval = "arm_smultt"; break;
        case 76l: retval = "arm_stm"; break;
        case 77l: retval = "arm_stmda"; break;
        case 78l: retval = "arm_stmdb"; break;
        case 79l: retval = "arm_stmia"; break;
        case 80l: retval = "arm_stmib"; break;
        case 81l: retval = "arm_str"; break;
        case 82l: retval = "arm_strb"; break;
        case 83l: retval = "arm_strbt"; break;
        case 84l: retval = "arm_strd"; break;
        case 85l: retval = "arm_strh"; break;
        case 86l: retval = "arm_strt"; break;
        case 87l: retval = "arm_sub"; break;
        case 88l: retval = "arm_subs"; break;
        case 89l: retval = "arm_swi"; break;
        case 90l: retval = "arm_swp"; break;
        case 91l: retval = "arm_teq"; break;
        case 92l: retval = "arm_tst"; break;
        case 93l: retval = "arm_umaal"; break;
        case 94l: retval = "arm_umlal"; break;
        case 95l: retval = "arm_umlals"; break;
        case 96l: retval = "arm_umull"; break;
        case 97l: retval = "arm_umulls"; break;
        case 98l: retval = "arm_undefined"; break;
        case 99l: retval = "arm_last_instruction"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ArmInstructionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmProgramStatusRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/armInstructionEnum.h:13
/** Converts an enum of type ArmProgramStatusRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmProgramStatusRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "arm_psr_current"; break;
        case 1l: retval = "arm_psr_saved"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ArmProgramStatusRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmProgramStatusRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmRegisterClass is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/armInstructionEnum.h:7
/** Converts an enum of type ArmRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmRegisterClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "arm_regclass_gpr"; break;
        case 1l: retval = "arm_regclass_psr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ArmRegisterClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmSignForExpressionUnparsing is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/asmUnparser/AsmUnparser_compat.h:45
/** Converts an enum of type ArmSignForExpressionUnparsing to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmSignForExpressionUnparsing(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "arm_sign_none"; break;
        case 1l: retval = "arm_sign_plus"; break;
        case 2l: retval = "arm_sign_minus"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ArmSignForExpressionUnparsing)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmSignForExpressionUnparsing::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Assembler::EncodingType is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/Assembler.h:72
/** Converts an enum of type Assembler::EncodingType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerEncodingType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ET_SHORTEST"; break;
        case 1l: retval = "ET_LONGEST"; break;
        case 2l: retval = "ET_MATCHES"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Assembler::EncodingType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Assembler::EncodingType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AssemblerX86::MemoryReferencePattern is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/AssemblerX86.h:383
/** Converts an enum of type AssemblerX86::MemoryReferencePattern to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerX86MemoryReferencePattern(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "mrp_unknown"; break;
        case 1l: retval = "mrp_disp"; break;
        case 2l: retval = "mrp_index"; break;
        case 3l: retval = "mrp_index_disp"; break;
        case 4l: retval = "mrp_base"; break;
        case 5l: retval = "mrp_base_disp"; break;
        case 6l: retval = "mrp_base_index"; break;
        case 7l: retval = "mrp_base_index_disp"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AssemblerX86::MemoryReferencePattern)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssemblerX86::MemoryReferencePattern::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AssemblerX86::OperandDefn is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/AssemblerX86.h:142
/** Converts an enum of type AssemblerX86::OperandDefn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerX86OperandDefn(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "od_none"; break;
        case 1l: retval = "od_AL"; break;
        case 2l: retval = "od_AX"; break;
        case 3l: retval = "od_EAX"; break;
        case 4l: retval = "od_RAX"; break;
        case 5l: retval = "od_DX"; break;
        case 6l: retval = "od_CS"; break;
        case 7l: retval = "od_DS"; break;
        case 8l: retval = "od_ES"; break;
        case 9l: retval = "od_FS"; break;
        case 10l: retval = "od_GS"; break;
        case 11l: retval = "od_SS"; break;
        case 12l: retval = "od_rel8"; break;
        case 13l: retval = "od_rel16"; break;
        case 14l: retval = "od_rel32"; break;
        case 15l: retval = "od_rel64"; break;
        case 16l: retval = "od_ptr16_16"; break;
        case 17l: retval = "od_ptr16_32"; break;
        case 18l: retval = "od_ptr16_64"; break;
        case 19l: retval = "od_r8"; break;
        case 20l: retval = "od_r16"; break;
        case 21l: retval = "od_r32"; break;
        case 22l: retval = "od_r64"; break;
        case 23l: retval = "od_imm8"; break;
        case 24l: retval = "od_imm16"; break;
        case 25l: retval = "od_imm32"; break;
        case 26l: retval = "od_imm64"; break;
        case 27l: retval = "od_r_m8"; break;
        case 28l: retval = "od_r_m16"; break;
        case 29l: retval = "od_r_m32"; break;
        case 30l: retval = "od_r_m64"; break;
        case 31l: retval = "od_m"; break;
        case 32l: retval = "od_m8"; break;
        case 33l: retval = "od_m16"; break;
        case 34l: retval = "od_m32"; break;
        case 35l: retval = "od_m64"; break;
        case 36l: retval = "od_m128"; break;
        case 37l: retval = "od_m16_16"; break;
        case 38l: retval = "od_m16_32"; break;
        case 39l: retval = "od_m16_64"; break;
        case 40l: retval = "od_m16a16"; break;
        case 41l: retval = "od_m16a32"; break;
        case 42l: retval = "od_m32a32"; break;
        case 43l: retval = "od_m16a64"; break;
        case 44l: retval = "od_moffs8"; break;
        case 45l: retval = "od_moffs16"; break;
        case 46l: retval = "od_moffs32"; break;
        case 47l: retval = "od_moffs64"; break;
        case 48l: retval = "od_sreg"; break;
        case 49l: retval = "od_m32fp"; break;
        case 50l: retval = "od_m64fp"; break;
        case 51l: retval = "od_m80fp"; break;
        case 52l: retval = "od_st0"; break;
        case 53l: retval = "od_st1"; break;
        case 54l: retval = "od_st2"; break;
        case 55l: retval = "od_st3"; break;
        case 56l: retval = "od_st4"; break;
        case 57l: retval = "od_st5"; break;
        case 58l: retval = "od_st6"; break;
        case 59l: retval = "od_st7"; break;
        case 60l: retval = "od_sti"; break;
        case 61l: retval = "od_mm"; break;
        case 62l: retval = "od_mm_m32"; break;
        case 63l: retval = "od_mm_m64"; break;
        case 64l: retval = "od_xmm"; break;
        case 65l: retval = "od_xmm_m16"; break;
        case 66l: retval = "od_xmm_m32"; break;
        case 67l: retval = "od_xmm_m64"; break;
        case 68l: retval = "od_xmm_m128"; break;
        case 69l: retval = "od_XMM0"; break;
        case 70l: retval = "od_0"; break;
        case 71l: retval = "od_1"; break;
        case 72l: retval = "od_m80"; break;
        case 73l: retval = "od_dec"; break;
        case 74l: retval = "od_m80bcd"; break;
        case 75l: retval = "od_m2byte"; break;
        case 76l: retval = "od_m14_28byte"; break;
        case 77l: retval = "od_m94_108byte"; break;
        case 78l: retval = "od_m512byte"; break;
        case 79l: retval = "od_r16_m16"; break;
        case 80l: retval = "od_r32_m8"; break;
        case 81l: retval = "od_r32_m16"; break;
        case 82l: retval = "od_r64_m16"; break;
        case 83l: retval = "od_CR0"; break;
        case 84l: retval = "od_CR7"; break;
        case 85l: retval = "od_CR8"; break;
        case 86l: retval = "od_CR0CR7"; break;
        case 87l: retval = "od_DR0DR7"; break;
        case 88l: retval = "od_reg"; break;
        case 89l: retval = "od_CL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AssemblerX86::OperandDefn)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssemblerX86::OperandDefn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AssociativitySpecifier is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h:17
/** Converts an enum of type AssociativitySpecifier to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssociativitySpecifier(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_assoc_none"; break;
        case 1l: retval = "e_assoc_right"; break;
        case 2l: retval = "e_assoc_left"; break;
        case 3l: retval = "e_assoc_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AssociativitySpecifier)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssociativitySpecifier::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstAttribute::OwnershipPolicy is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astProcessing/AstAttributeMechanism.h:42
/** Converts an enum of type AstAttribute::OwnershipPolicy to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstAttributeOwnershipPolicy(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CONTAINER_OWNERSHIP"; break;
        case 1l: retval = "NO_OWNERSHIP"; break;
        case 2l: retval = "CUSTOM_OWNERSHIP"; break;
        case 3l: retval = "UNKNOWN_OWNERSHIP"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstAttribute::OwnershipPolicy)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstAttribute::OwnershipPolicy::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstAttributeDOT::DOTStyles is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/astVisualization/AstAttributeDOT.h:22
/** Converts an enum of type AstAttributeDOT::DOTStyles to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstAttributeDOT_DOTStyles(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementDOTStyles"; break;
        case 1l: retval = "filled"; break;
        case 2l: retval = "not_filled"; break;
        case 3l: retval = "END_OF_NODE_TYPE_LIST_DOTStyles"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstAttributeDOT::DOTStyles)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstAttributeDOT::DOTStyles::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstDisplayInfo::NodeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/util/AstDisplayInfo.h:15
/** Converts an enum of type AstDisplayInfo::NodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstDisplayInfoNodeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ROOT"; break;
        case 1l: retval = "INCLUDE_ROOT"; break;
        case 2l: retval = "SRC_FILE"; break;
        case 3l: retval = "INCLUDE_FILE"; break;
        case 4l: retval = "NAMESPACE"; break;
        case 5l: retval = "CLASS"; break;
        case 6l: retval = "FUNCTION"; break;
        case 7l: retval = "LOOP"; break;
        case 8l: retval = "UNKNOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstDisplayInfo::NodeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstDisplayInfo::NodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstNodeClass::TypeEvaluation is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/AstNodeClass.h:332
/** Converts an enum of type AstNodeClass::TypeEvaluation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstNodeClassTypeEvaluation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CHAR_POINTER"; break;
        case 1l: retval = "CONST_CHAR_POINTER"; break;
        case 2l: retval = "ATTACHEDPREPROCESSINGINFOTYPE"; break;
        case 3l: retval = "ROSE_HASH_MULTIMAP"; break;
        case 4l: retval = "ROSE_GRAPH_HASH_MULTIMAP"; break;
        case 5l: retval = "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP"; break;
        case 6l: retval = "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP"; break;
        case 7l: retval = "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP"; break;
        case 8l: retval = "ROSE_GRAPH_INTEGER_NODE_HASH_MAP"; break;
        case 9l: retval = "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP"; break;
        case 10l: retval = "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP"; break;
        case 11l: retval = "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP"; break;
        case 12l: retval = "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP"; break;
        case 13l: retval = "SGCLASS_POINTER"; break;
        case 14l: retval = "ROSEATTRUBUTESLISTCONTAINER"; break;
        case 15l: retval = "SGCLASS_POINTER_LIST"; break;
        case 16l: retval = "SGCLASS_POINTER_VECTOR"; break;
        case 17l: retval = "SGCLASS_POINTER_VECTOR_NAMED_LIST"; break;
        case 18l: retval = "STL_CONTAINER"; break;
        case 19l: retval = "STL_SET"; break;
        case 20l: retval = "STL_MULTIMAP"; break;
        case 21l: retval = "STL_MAP"; break;
        case 22l: retval = "STRING"; break;
        case 23l: retval = "SGNAME"; break;
        case 24l: retval = "BIT_VECTOR"; break;
        case 25l: retval = "MODIFIERCLASS"; break;
        case 26l: retval = "MODIFIERCLASS_WITHOUTEASYSTORAGE"; break;
        case 27l: retval = "ASTATTRIBUTEMECHANISM"; break;
        case 28l: retval = "TO_HANDLE"; break;
        case 29l: retval = "OSTREAM"; break;
        case 30l: retval = "ENUM_TYPE"; break;
        case 31l: retval = "BASIC_DATA_TYPE"; break;
        case 32l: retval = "SKIP_TYPE"; break;
        case 33l: retval = "SGCLASS_POINTER_LIST_POINTER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstNodeClass::TypeEvaluation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstNodeClass::TypeEvaluation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstNodeClass::includeExcludeMechanism is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/AstNodeClass.h:125
/** Converts an enum of type AstNodeClass::includeExcludeMechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstNodeClass_includeExcludeMechanism(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INCLUDE_LIST"; break;
        case 1l: retval = "EXCLUDE_LIST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstNodeClass::includeExcludeMechanism)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstNodeClass::includeExcludeMechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstNodeClass::locationInTree is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/AstNodeClass.h:119
/** Converts an enum of type AstNodeClass::locationInTree to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstNodeClass_locationInTree(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "LOCAL_LIST"; break;
        case 1l: retval = "SUBTREE_LIST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstNodeClass::locationInTree)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstNodeClass::locationInTree::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstQueryNamespace::QueryDepth is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/astQuery.h:97
/** Converts an enum of type AstQueryNamespace::QueryDepth to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstQueryNamespaceQueryDepth(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementTypeQueryDepth"; break;
        case 1l: retval = "ChildrenOnly"; break;
        case 2l: retval = "AllNodes"; break;
        case 3l: retval = "ExtractTypes"; break;
        case 4l: retval = "END_OF_NODE_TYPE_LIST_QUERY_DEPTH"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstQueryNamespace::QueryDepth)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstQueryNamespace::QueryDepth::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstUnparseAttribute::RelativePositionType is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/unparser/astUnparseAttribute.h:34
/** Converts an enum of type AstUnparseAttribute::RelativePositionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstUnparseAttributeRelativePositionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_defaultValue"; break;
        case 1l: retval = "e_undef"; break;
        case 2l: retval = "e_before"; break;
        case 3l: retval = "e_after"; break;
        case 4l: retval = "e_inside"; break;
        case 5l: retval = "e_replace"; break;
        case 6l: retval = "e_before_syntax"; break;
        case 7l: retval = "e_after_syntax"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(AstUnparseAttribute::RelativePositionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstUnparseAttribute::RelativePositionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BaseGraph::BiDirNodesIterator::dirType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h:261
/** Converts an enum of type BaseGraph::BiDirNodesIterator::dirType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBaseGraphBiDirNodesIterator_dirType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Forward"; break;
        case 1l: retval = "Reverse"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BaseGraph::BiDirNodesIterator::dirType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::AsmUnparser::Organization is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/asmUnparser/AsmUnparser.h:251
/** Converts an enum of type BinaryAnalysis::AsmUnparser::Organization to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisAsmUnparserOrganization(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ORGANIZED_BY_AST"; break;
        case 1l: retval = "ORGANIZED_BY_ADDRESS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::AsmUnparser::Organization)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::AsmUnparser::Organization::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::BinaryDebugger::DetachMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/BinaryDebugger.h:14
/** Converts an enum of type BinaryAnalysis::BinaryDebugger::DetachMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisBinaryDebuggerDetachMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "KILL"; break;
        case 1l: retval = "DETACH"; break;
        case 2l: retval = "CONTINUE"; break;
        case 3l: retval = "NOTHING"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::BinaryDebugger::DetachMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::BinaryDebugger::DetachMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::BinaryDebugger::RegPageStatus is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/BinaryDebugger.h:17
/** Converts an enum of type BinaryAnalysis::BinaryDebugger::RegPageStatus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisBinaryDebuggerRegPageStatus(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "REGPAGE_NONE"; break;
        case 1l: retval = "REGPAGE_REGS"; break;
        case 2l: retval = "REGPAGE_FPREGS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::BinaryDebugger::RegPageStatus)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::BinaryDebugger::RegPageStatus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::ParameterLocation::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryCallingConvention.h:82
/** Converts an enum of type BinaryAnalysis::CallingConvention::ParameterLocation::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionParameterLocationType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NO_LOCATION"; break;
        case 1l: retval = "REGISTER"; break;
        case 2l: retval = "STACK"; break;
        case 3l: retval = "ABSOLUTE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::CallingConvention::ParameterLocation::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::ParameterLocation::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::StackCleanup is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryCallingConvention.h:58
/** Converts an enum of type BinaryAnalysis::CallingConvention::StackCleanup to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionStackCleanup(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CLEANUP_BY_CALLER"; break;
        case 1l: retval = "CLEANUP_BY_CALLEE"; break;
        case 2l: retval = "CLEANUP_UNSPECIFIED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::CallingConvention::StackCleanup)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::StackCleanup::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::StackDirection is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryCallingConvention.h:52
/** Converts an enum of type BinaryAnalysis::CallingConvention::StackDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionStackDirection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "GROWS_UP"; break;
        case 1l: retval = "GROWS_DOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::CallingConvention::StackDirection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::StackDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::StackParameterOrder is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryCallingConvention.h:45
/** Converts an enum of type BinaryAnalysis::CallingConvention::StackParameterOrder to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionStackParameterOrder(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "LEFT_TO_RIGHT"; break;
        case 1l: retval = "RIGHT_TO_LEFT"; break;
        case 2l: retval = "ORDER_UNSPECIFIED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::CallingConvention::StackParameterOrder)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::StackParameterOrder::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Disassembler::SearchHeuristic is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/Disassembler.h:162
/** Converts an enum of type BinaryAnalysis::Disassembler::SearchHeuristic to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerSearchHeuristic(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "SEARCH_FOLLOWING"; break;
        case 2l: retval = "SEARCH_IMMEDIATE"; break;
        case 4l: retval = "SEARCH_WORDS"; break;
        case 8l: retval = "SEARCH_ALLBYTES"; break;
        case 16l: retval = "SEARCH_UNUSED"; break;
        case 32l: retval = "SEARCH_NONEXE"; break;
        case 64l: retval = "SEARCH_DEADEND"; break;
        case 128l: retval = "SEARCH_UNKNOWN"; break;
        case 256l: retval = "SEARCH_FUNCSYMS"; break;
        case 257l: retval = "SEARCH_DEFAULT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Disassembler::SearchHeuristic)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Disassembler::SearchHeuristic::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DisassemblerMips::Mips32::Architecture is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/DisassemblerMips.h:32
/** Converts an enum of type BinaryAnalysis::DisassemblerMips::Mips32::Architecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerMipsMips32Architecture(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Release1"; break;
        case 1l: retval = "Release2"; break;
        case 2l: retval = "Release3"; break;
        case 3l: retval = "Micro"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::DisassemblerMips::Mips32::Architecture)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DisassemblerMips::Mips32::Architecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DisassemblerX86::MMPrefix is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/DisassemblerX86.h:71
/** Converts an enum of type BinaryAnalysis::DisassemblerX86::MMPrefix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerX86MMPrefix(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "mmNone"; break;
        case 1l: retval = "mmF3"; break;
        case 2l: retval = "mm66"; break;
        case 3l: retval = "mmF2"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::DisassemblerX86::MMPrefix)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DisassemblerX86::MMPrefix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DisassemblerX86::RegisterMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/DisassemblerX86.h:65
/** Converts an enum of type BinaryAnalysis::DisassemblerX86::RegisterMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerX86RegisterMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "rmLegacyByte"; break;
        case 1l: retval = "rmRexByte"; break;
        case 2l: retval = "rmWord"; break;
        case 3l: retval = "rmDWord"; break;
        case 4l: retval = "rmQWord"; break;
        case 5l: retval = "rmSegment"; break;
        case 6l: retval = "rmST"; break;
        case 7l: retval = "rmMM"; break;
        case 8l: retval = "rmXMM"; break;
        case 9l: retval = "rmControl"; break;
        case 10l: retval = "rmDebug"; break;
        case 11l: retval = "rmReturnNull"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::DisassemblerX86::RegisterMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DisassemblerX86::RegisterMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DwarfLineMapper::Direction is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/DwarfLineMapper.h:16
/** Converts an enum of type BinaryAnalysis::DwarfLineMapper::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDwarfLineMapperDirection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "ADDR2SRC"; break;
        case 2l: retval = "SRC2ADDR"; break;
        case 3l: retval = "BIDIRECTIONAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::DwarfLineMapper::Direction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DwarfLineMapper::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/BaseSemantics2.h:430
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2BaseSemanticsInputOutputProperty(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "IO_READ"; break;
        case 1l: retval = "IO_WRITE"; break;
        case 2l: retval = "IO_INIT"; break;
        case 3l: retval = "IO_READ_BEFORE_WRITE"; break;
        case 4l: retval = "IO_READ_AFTER_WRITE"; break;
        case 5l: retval = "IO_READ_UNINITIALIZED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/DataFlowSemantics2.h:35
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2DataFlowSemanticsDataFlowEdgeEdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CLOBBER"; break;
        case 1l: retval = "AUGMENT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/IntervalSemantics2.C:583
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2IntervalSemanticsCarry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "C_FALSE"; break;
        case 1l: retval = "C_TRUE"; break;
        case 2l: retval = "C_UNKNOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/SymbolicSemantics2.h:686
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsDefinersMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "TRACK_NO_DEFINERS"; break;
        case 1l: retval = "TRACK_LATEST_DEFINER"; break;
        case 2l: retval = "TRACK_ALL_DEFINERS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/SymbolicSemantics2.h:679
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsWritersMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "TRACK_NO_WRITERS"; break;
        case 1l: retval = "TRACK_LATEST_WRITER"; break;
        case 2l: retval = "TRACK_ALL_WRITERS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/IntervalSemantics.h:470
/** Converts an enum of type BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemanticsIntervalSemanticsPolicyCarry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "C_FALSE"; break;
        case 1l: retval = "C_TRUE"; break;
        case 2l: retval = "C_UNKNOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/PartialSymbolicSemantics.h:470
/** Converts an enum of type BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemanticsPartialSymbolicSemanticsPolicyMemRefType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "MRT_STACK_PTR"; break;
        case 1l: retval = "MRT_FRAME_PTR"; break;
        case 2l: retval = "MRT_OTHER_PTR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::MagicNumber::Mechanism is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryMagic.h:16
/** Converts an enum of type BinaryAnalysis::MagicNumber::Mechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisMagicNumberMechanism(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FAST"; break;
        case 1l: retval = "SLOW"; break;
        case 2l: retval = "NONE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::MagicNumber::Mechanism)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::MagicNumber::Mechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/Modules.h:44
/** Converts an enum of type BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CONTINUE_DISCOVERY"; break;
        case 1l: retval = "TERMINATE_NOW"; break;
        case 2l: retval = "TERMINATE_PRIOR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Confidence is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/BasicTypes.h:49
/** Converts an enum of type BinaryAnalysis::Partitioner2::Confidence to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2Confidence(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ASSUMED"; break;
        case 1l: retval = "PROVED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::Confidence)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Confidence::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/DataFlow.h:28
/** Converts an enum of type BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "BBLOCK"; break;
        case 1l: retval = "FAKED_CALL"; break;
        case 2l: retval = "FUNCRET"; break;
        case 3l: retval = "INDET"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::EdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/BasicTypes.h:25
/** Converts an enum of type BinaryAnalysis::Partitioner2::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2EdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "E_NORMAL"; break;
        case 1l: retval = "E_FUNCTION_CALL"; break;
        case 2l: retval = "E_FUNCTION_RETURN"; break;
        case 3l: retval = "E_CALL_RETURN"; break;
        case 4l: retval = "E_FUNCTION_XFER"; break;
        case 5l: retval = "E_USER_DEFINED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::EdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Function::Ownership is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/Function.h:41
/** Converts an enum of type BinaryAnalysis::Partitioner2::Function::Ownership to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2FunctionOwnership(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "OWN_UNOWNED"; break;
        case 1l: retval = "OWN_EXPLICIT"; break;
        case 2l: retval = "OWN_PROVISIONAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::Function::Ownership)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Function::Ownership::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::FunctionReturnAnalysis is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/BasicTypes.h:194
/** Converts an enum of type BinaryAnalysis::Partitioner2::FunctionReturnAnalysis to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "MAYRETURN_DEFAULT_YES"; break;
        case 1l: retval = "MAYRETURN_DEFAULT_NO"; break;
        case 2l: retval = "MAYRETURN_ALWAYS_YES"; break;
        case 3l: retval = "MAYRETURN_ALWAYS_NO"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::FunctionReturnAnalysis::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Inliner::HowInline is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/CfgPath.h:329
/** Converts an enum of type BinaryAnalysis::Partitioner2::Inliner::HowInline to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2InlinerHowInline(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INLINE_NONE"; break;
        case 1l: retval = "INLINE_NORMAL"; break;
        case 2l: retval = "INLINE_USER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::Inliner::HowInline)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Inliner::HowInline::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::MemoryDataAdjustment is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/BasicTypes.h:141
/** Converts an enum of type BinaryAnalysis::Partitioner2::MemoryDataAdjustment to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "DATA_IS_CONSTANT"; break;
        case 1l: retval = "DATA_IS_INITIALIZED"; break;
        case 2l: retval = "DATA_NO_CHANGE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::MemoryDataAdjustment::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/Partitioner.h:1212
/** Converts an enum of type BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INIT"; break;
        case 1l: retval = "CALCULATING"; break;
        case 2l: retval = "FINISHED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Reference::Granularity is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/Reference.h:29
/** Converts an enum of type BinaryAnalysis::Partitioner2::Reference::Granularity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2ReferenceGranularity(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "EMPTY"; break;
        case 1l: retval = "ADDRESS"; break;
        case 2l: retval = "INSTRUCTION"; break;
        case 3l: retval = "BASIC_BLOCK"; break;
        case 4l: retval = "FUNCTION"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::Reference::Granularity)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Reference::Granularity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::SemanticMemoryParadigm is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/BasicTypes.h:55
/** Converts an enum of type BinaryAnalysis::Partitioner2::SemanticMemoryParadigm to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "LIST_BASED_MEMORY"; break;
        case 1l: retval = "MAP_BASED_MEMORY"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::SemanticMemoryParadigm::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::VertexType is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Partitioner2/BasicTypes.h:14
/** Converts an enum of type BinaryAnalysis::Partitioner2::VertexType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2VertexType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "V_BASIC_BLOCK"; break;
        case 1l: retval = "V_UNDISCOVERED"; break;
        case 2l: retval = "V_INDETERMINATE"; break;
        case 3l: retval = "V_NONEXISTING"; break;
        case 4l: retval = "V_USER_DEFINED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner2::VertexType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::VertexType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/Partitioner.h:757
/** Converts an enum of type BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitionerRegionStatsAnalysisEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RA_NBYTES"; break;
        case 1l: retval = "RA_NINSNS"; break;
        case 2l: retval = "RA_NCOVERAGE"; break;
        case 3l: retval = "RA_RCOVERAGE"; break;
        case 4l: retval = "RA_NSTARTS"; break;
        case 5l: retval = "RA_NFAILS"; break;
        case 6l: retval = "RA_RFAILS"; break;
        case 7l: retval = "RA_NOVERLAPS"; break;
        case 8l: retval = "RA_ROVERLAPS"; break;
        case 9l: retval = "RA_NINCOMPLETE"; break;
        case 10l: retval = "RA_RINCOMPLETE"; break;
        case 11l: retval = "RA_NBRANCHES"; break;
        case 12l: retval = "RA_RBRANCHES"; break;
        case 13l: retval = "RA_NCALLS"; break;
        case 14l: retval = "RA_RCALLS"; break;
        case 15l: retval = "RA_NNONCALLS"; break;
        case 16l: retval = "RA_RNONCALLS"; break;
        case 17l: retval = "RA_NINTERNAL"; break;
        case 18l: retval = "RA_RINTERNAL"; break;
        case 19l: retval = "RA_NICFGEDGES"; break;
        case 20l: retval = "RA_RICFGEDGES"; break;
        case 21l: retval = "RA_NCOMPS"; break;
        case 22l: retval = "RA_RCOMPS"; break;
        case 23l: retval = "RA_NIUNIQUE"; break;
        case 24l: retval = "RA_RIUNIQUE"; break;
        case 25l: retval = "RA_NREGREFS"; break;
        case 26l: retval = "RA_RREGREFS"; break;
        case 27l: retval = "RA_REGSZ"; break;
        case 28l: retval = "RA_REGVAR"; break;
        case 29l: retval = "RA_NPRIV"; break;
        case 30l: retval = "RA_RPRIV"; break;
        case 31l: retval = "RA_NFLOAT"; break;
        case 32l: retval = "RA_RFLOAT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SMTSolver::Satisfiable is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/SMTSolver.h:27
/** Converts an enum of type BinaryAnalysis::SMTSolver::Satisfiable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSMTSolverSatisfiable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SAT_NO"; break;
        case 1l: retval = "SAT_YES"; break;
        case 2l: retval = "SAT_UNKNOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SMTSolver::Satisfiable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SMTSolver::Satisfiable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SRecord::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryFormats/SRecord.h:18
/** Converts an enum of type BinaryAnalysis::SRecord::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSRecordType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SREC_HEADER"; break;
        case 1l: retval = "SREC_DATA16"; break;
        case 2l: retval = "SREC_DATA24"; break;
        case 3l: retval = "SREC_DATA32"; break;
        case 4l: retval = "SREC_RESERVED"; break;
        case 5l: retval = "SREC_COUNT16"; break;
        case 6l: retval = "SREC_COUNT24"; break;
        case 7l: retval = "SREC_START32"; break;
        case 8l: retval = "SREC_START24"; break;
        case 9l: retval = "SREC_START16"; break;
        case 10l: retval = "SREC_NONE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SRecord::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SRecord::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Strings::State is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryString.h:194
/** Converts an enum of type BinaryAnalysis::Strings::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisStringsState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -4l: retval = "ERROR_STATE"; break;
        case -3l: retval = "INITIAL_STATE"; break;
        case -2l: retval = "COMPLETED_STATE"; break;
        case -1l: retval = "FINAL_STATE"; break;
        case 0l: retval = "USER_DEFINED_0"; break;
        case 1l: retval = "USER_DEFINED_1"; break;
        case 2l: retval = "USER_DEFINED_2"; break;
        case 128l: retval = "USER_DEFINED_MAX"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::Strings::State)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Strings::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::Formatter::ShowComments is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinarySymbolicExpr.h:114
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::Formatter::ShowComments to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprFormatterShowComments(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CMT_SILENT"; break;
        case 1l: retval = "CMT_AFTER"; break;
        case 2l: retval = "CMT_INSTEAD"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SymbolicExpr::Formatter::ShowComments)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::Formatter::ShowComments::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::Leaf::LeafType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinarySymbolicExpr.h:853
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::Leaf::LeafType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprLeafLeafType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CONSTANT"; break;
        case 1l: retval = "BITVECTOR"; break;
        case 2l: retval = "MEMORY"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SymbolicExpr::Leaf::LeafType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::Leaf::LeafType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::Operator is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinarySymbolicExpr.h:48
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::Operator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprOperator(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "OP_ADD"; break;
        case 1l: retval = "OP_AND"; break;
        case 2l: retval = "OP_ASR"; break;
        case 3l: retval = "OP_BV_AND"; break;
        case 4l: retval = "OP_BV_OR"; break;
        case 5l: retval = "OP_BV_XOR"; break;
        case 6l: retval = "OP_CONCAT"; break;
        case 7l: retval = "OP_EQ"; break;
        case 8l: retval = "OP_EXTRACT"; break;
        case 9l: retval = "OP_INVERT"; break;
        case 10l: retval = "OP_ITE"; break;
        case 11l: retval = "OP_LSSB"; break;
        case 12l: retval = "OP_MSSB"; break;
        case 13l: retval = "OP_NE"; break;
        case 14l: retval = "OP_NEGATE"; break;
        case 15l: retval = "OP_NOOP"; break;
        case 16l: retval = "OP_OR"; break;
        case 17l: retval = "OP_READ"; break;
        case 18l: retval = "OP_ROL"; break;
        case 19l: retval = "OP_ROR"; break;
        case 20l: retval = "OP_SDIV"; break;
        case 21l: retval = "OP_SET"; break;
        case 22l: retval = "OP_SEXTEND"; break;
        case 23l: retval = "OP_SGE"; break;
        case 24l: retval = "OP_SGT"; break;
        case 25l: retval = "OP_SHL0"; break;
        case 26l: retval = "OP_SHL1"; break;
        case 27l: retval = "OP_SHR0"; break;
        case 28l: retval = "OP_SHR1"; break;
        case 29l: retval = "OP_SLE"; break;
        case 30l: retval = "OP_SLT"; break;
        case 31l: retval = "OP_SMOD"; break;
        case 32l: retval = "OP_SMUL"; break;
        case 33l: retval = "OP_UDIV"; break;
        case 34l: retval = "OP_UEXTEND"; break;
        case 35l: retval = "OP_UGE"; break;
        case 36l: retval = "OP_UGT"; break;
        case 37l: retval = "OP_ULE"; break;
        case 38l: retval = "OP_ULT"; break;
        case 39l: retval = "OP_UMOD"; break;
        case 40l: retval = "OP_UMUL"; break;
        case 41l: retval = "OP_WRITE"; break;
        case 42l: retval = "OP_ZEROP"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SymbolicExpr::Operator)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::Operator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::VisitAction is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinarySymbolicExpr.h:134
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::VisitAction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprVisitAction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CONTINUE"; break;
        case 1l: retval = "TRUNCATE"; break;
        case 2l: retval = "TERMINATE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SymbolicExpr::VisitAction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::VisitAction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExprParser::Token::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinarySymbolicExprParser.h:40
/** Converts an enum of type BinaryAnalysis::SymbolicExprParser::Token::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprParserTokenType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NONE"; break;
        case 1l: retval = "LTPAREN"; break;
        case 2l: retval = "RTPAREN"; break;
        case 3l: retval = "BITVECTOR"; break;
        case 4l: retval = "SYMBOL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::SymbolicExprParser::Token::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExprParser::Token::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::TaintedFlow::Approximation is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryTaintedFlow.h:30
/** Converts an enum of type BinaryAnalysis::TaintedFlow::Approximation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisTaintedFlowApproximation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UNDER_APPROXIMATE"; break;
        case 1l: retval = "OVER_APPROXIMATE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::TaintedFlow::Approximation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::TaintedFlow::Approximation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::TaintedFlow::Taintedness is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/BinaryTaintedFlow.h:23
/** Converts an enum of type BinaryAnalysis::TaintedFlow::Taintedness to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisTaintedFlowTaintedness(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "BOTTOM"; break;
        case 1l: retval = "NOT_TAINTED"; break;
        case 2l: retval = "TAINTED"; break;
        case 3l: retval = "TOP"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::TaintedFlow::Taintedness)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::TaintedFlow::Taintedness::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::YicesSolver::LinkMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/binaryAnalyses/instructionSemantics/YicesSolver.h:26
/** Converts an enum of type BinaryAnalysis::YicesSolver::LinkMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisYicesSolverLinkMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "LM_NONE"; break;
        case 1l: retval = "LM_LIBRARY"; break;
        case 2l: retval = "LM_EXECUTABLE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryAnalysis::YicesSolver::LinkMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::YicesSolver::LinkMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryLoader::ConflictResolution is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryLoader/BinaryLoader.h:61
/** Converts an enum of type BinaryLoader::ConflictResolution to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryLoaderConflictResolution(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RESOLVE_THROW"; break;
        case 1l: retval = "RESOLVE_OVERMAP"; break;
        case 2l: retval = "RESOLVE_REMAP"; break;
        case 3l: retval = "RESOLVE_REMAP_ABOVE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryLoader::ConflictResolution)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryLoader::ConflictResolution::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryLoader::MappingContribution is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryLoader/BinaryLoader.h:53
/** Converts an enum of type BinaryLoader::MappingContribution to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryLoaderMappingContribution(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CONTRIBUTE_NONE"; break;
        case 1l: retval = "CONTRIBUTE_ADD"; break;
        case 2l: retval = "CONTRIBUTE_SUB"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BinaryLoader::MappingContribution)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryLoader::MappingContribution::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BooleanQuery::TypeOfQueryType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/booleanQuery.h:44
/** Converts an enum of type BooleanQuery::TypeOfQueryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBooleanQueryTypeOfQueryType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementType"; break;
        case 1l: retval = "VariableDeclaration"; break;
        case 2l: retval = "Type"; break;
        case 3l: retval = "FunctionDeclaration"; break;
        case 4l: retval = "MemberFunctionDeclaration"; break;
        case 5l: retval = "ClassDeclaration"; break;
        case 6l: retval = "Argument"; break;
        case 7l: retval = "Field"; break;
        case 8l: retval = "UnionedField"; break;
        case 9l: retval = "Struct"; break;
        case 10l: retval = "ContainedInSubtreeOfType"; break;
        case 11l: retval = "END_OF_BOOLEAN_QUERY_TYPE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BooleanQuery::TypeOfQueryType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BooleanQuery::TypeOfQueryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BuildAccessEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/grammar.h:95
/** Converts an enum of type BuildAccessEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBuildAccessEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NO_ACCESS_FUNCTIONS"; break;
        case 1l: retval = "BUILD_ACCESS_FUNCTIONS"; break;
        case 2l: retval = "BUILD_FLAG_ACCESS_FUNCTIONS"; break;
        case 3l: retval = "BUILD_LIST_ACCESS_FUNCTIONS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(BuildAccessEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BuildAccessEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ByteOrder::Endianness is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryFormats/ByteOrder.h:7
/** Converts an enum of type ByteOrder::Endianness to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyByteOrderEndianness(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ORDER_UNSPECIFIED"; break;
        case 1l: retval = "ORDER_LSB"; break;
        case 2l: retval = "ORDER_MSB"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ByteOrder::Endianness)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ByteOrder::Endianness::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CFG::EdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h:84
/** Converts an enum of type CFG::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCFG_EdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "TRUE_EDGE"; break;
        case 1l: retval = "FALLTHROUGH_EDGE"; break;
        case 2l: retval = "FALSE_EDGE"; break;
        case 3l: retval = "BACK_EDGE"; break;
        case 4l: retval = "MULTIWAY_EDGE"; break;
        case 5l: retval = "BREAK_EDGE"; break;
        case 6l: retval = "CONTINUE_EDGE"; break;
        case 7l: retval = "RETURN_EDGE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CFG::EdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CFG::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CGFunction::iterator::direction is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/genericDataflow/cfgUtils/CallGraphTraverse.h:121
/** Converts an enum of type CGFunction::iterator::direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCGFunction_iterator_direction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "fw"; break;
        case 1l: retval = "bw"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CGFunction::iterator::direction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CGFunction::iterator::direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CallGraph::EdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h:73
/** Converts an enum of type CallGraph::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCallGraphEdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NORMAL_EDGE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CallGraph::EdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CallGraph::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ClangToSageTranslator::Language is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/CxxFrontend/Clang/clang-frontend-private.hpp:137
/** Converts an enum of type ClangToSageTranslator::Language to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyClangToSageTranslatorLanguage(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "C"; break;
        case 1l: retval = "CPLUSPLUS"; break;
        case 2l: retval = "OBJC"; break;
        case 3l: retval = "CUDA"; break;
        case 4l: retval = "OPENCL"; break;
        case 5l: retval = "unknown"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ClangToSageTranslator::Language)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ClangToSageTranslator::Language::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CollectAliasRelations::COLOR is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h:278
/** Converts an enum of type CollectAliasRelations::COLOR to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCollectAliasRelationsCOLOR(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "WHITE"; break;
        case 1l: retval = "GREY"; break;
        case 2l: retval = "BLACK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CollectAliasRelations::COLOR)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CollectAliasRelations::COLOR::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CollectAliasRelations::TRAVERSAL_TYPE is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h:279
/** Converts an enum of type CollectAliasRelations::TRAVERSAL_TYPE to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCollectAliasRelationsTRAVERSAL_TYPE(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "TOPOLOGICAL"; break;
        case 1l: retval = "NON_TOPOLOGICAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CollectAliasRelations::TRAVERSAL_TYPE)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CollectAliasRelations::TRAVERSAL_TYPE::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CompilerOutputWidget::PatternType is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/TaskSystem/CompilerOutputWidget.h:25
/** Converts an enum of type CompilerOutputWidget::PatternType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCompilerOutputWidgetPatternType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Unknown"; break;
        case 1l: retval = "Warning"; break;
        case 2l: retval = "Error"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CompilerOutputWidget::PatternType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CompilerOutputWidget::PatternType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ConstrGraph::levels is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/genericDataflow/lattice/ConstrGraph.h:42
/** Converts an enum of type ConstrGraph::levels to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyConstrGraph_levels(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "uninitialized"; break;
        case 1l: retval = "bottom"; break;
        case 2l: retval = "constrKnown"; break;
        case 3l: retval = "top"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ConstrGraph::levels)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ConstrGraph::levels::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ConstructParamEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/grammar.h:90
/** Converts an enum of type ConstructParamEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyConstructParamEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NO_CONSTRUCTOR_PARAMETER"; break;
        case 1l: retval = "CONSTRUCTOR_PARAMETER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ConstructParamEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ConstructParamEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CopyConfigEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/grammar.h:103
/** Converts an enum of type CopyConfigEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCopyConfigEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NO_COPY_DATA"; break;
        case 1l: retval = "COPY_DATA"; break;
        case 2l: retval = "CLONE_PTR"; break;
        case 3l: retval = "CLONE_TREE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(CopyConfigEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CopyConfigEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Cxx_GrammarVariants is defined at frontend/SageIII/Cxx_Grammar.h:18
/** Converts an enum of type Cxx_GrammarVariants to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCxx_GrammarVariants(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "AccessModifierTag"; break;
        case 2l: retval = "ACTUAL_ARGUMENT_EXPRESSION"; break;
        case 3l: retval = "ADD_OP"; break;
        case 4l: retval = "ADDRESS_OP"; break;
        case 5l: retval = "AGGREGATE_INIT"; break;
        case 6l: retval = "ALIAS_SYMBOL"; break;
        case 7l: retval = "TEMP_Allocate_Statement"; break;
        case 8l: retval = "AND_ASSIGN_OP"; break;
        case 9l: retval = "AND_OP"; break;
        case 10l: retval = "TEMP_Arithmetic_If_Statement"; break;
        case 11l: retval = "T_ARRAY"; break;
        case 12l: retval = "POINTST_OP"; break;
        case 13l: retval = "ARROWSTAR_OP"; break;
        case 14l: retval = "AsmArmInstructionTag"; break;
        case 15l: retval = "AsmBasicStringTag"; break;
        case 16l: retval = "AsmBinaryAddTag"; break;
        case 17l: retval = "AsmBinaryAddPostupdateTag"; break;
        case 18l: retval = "AsmBinaryAddPreupdateTag"; break;
        case 19l: retval = "AsmBinaryAsrTag"; break;
        case 20l: retval = "AsmBinaryDivideTag"; break;
        case 21l: retval = "AsmBinaryExpressionTag"; break;
        case 22l: retval = "AsmBinaryLslTag"; break;
        case 23l: retval = "AsmBinaryLsrTag"; break;
        case 24l: retval = "AsmBinaryModTag"; break;
        case 25l: retval = "AsmBinaryMultiplyTag"; break;
        case 26l: retval = "AsmBinaryRorTag"; break;
        case 27l: retval = "AsmBinarySubtractTag"; break;
        case 28l: retval = "AsmBinarySubtractPostupdateTag"; break;
        case 29l: retval = "AsmBinarySubtractPreupdateTag"; break;
        case 30l: retval = "AsmBlockTag"; break;
        case 31l: retval = "AsmCoffStrtabTag"; break;
        case 32l: retval = "AsmCoffSymbolTag"; break;
        case 33l: retval = "AsmCoffSymbolListTag"; break;
        case 34l: retval = "AsmCoffSymbolTableTag"; break;
        case 35l: retval = "AsmCommonSubExpressionTag"; break;
        case 36l: retval = "AsmControlFlagsExpressionTag"; break;
        case 37l: retval = "AsmConstantExpressionTag"; break;
        case 38l: retval = "AsmDOSExtendedHeaderTag"; break;
        case 39l: retval = "AsmDOSFileHeaderTag"; break;
        case 40l: retval = "AsmSynthesizedDataStructureDeclarationTag"; break;
        case 41l: retval = "AsmSynthesizedDeclarationTag"; break;
        case 42l: retval = "AsmDirectRegisterExpressionTag"; break;
        case 43l: retval = "AsmDwarfAccessDeclarationTag"; break;
        case 44l: retval = "AsmDwarfArrayTypeTag"; break;
        case 45l: retval = "AsmDwarfBaseTypeTag"; break;
        case 46l: retval = "AsmDwarfCatchBlockTag"; break;
        case 47l: retval = "AsmDwarfClassTemplateTag"; break;
        case 48l: retval = "AsmDwarfClassTypeTag"; break;
        case 49l: retval = "AsmDwarfCommonBlockTag"; break;
        case 50l: retval = "AsmDwarfCommonInclusionTag"; break;
        case 51l: retval = "AsmDwarfCompilationUnitTag"; break;
        case 52l: retval = "AsmDwarfCompilationUnitListTag"; break;
        case 53l: retval = "AsmDwarfConditionTag"; break;
        case 54l: retval = "AsmDwarfConstTypeTag"; break;
        case 55l: retval = "AsmDwarfConstantTag"; break;
        case 56l: retval = "AsmDwarfConstructTag"; break;
        case 57l: retval = "AsmDwarfConstructListTag"; break;
        case 58l: retval = "AsmDwarfDwarfProcedureTag"; break;
        case 59l: retval = "AsmDwarfEntryPointTag"; break;
        case 60l: retval = "AsmDwarfEnumerationTypeTag"; break;
        case 61l: retval = "AsmDwarfEnumeratorTag"; break;
        case 62l: retval = "AsmDwarfFileTypeTag"; break;
        case 63l: retval = "AsmDwarfFormalParameterTag"; break;
        case 64l: retval = "AsmDwarfFormatLabelTag"; break;
        case 65l: retval = "AsmDwarfFriendTag"; break;
        case 66l: retval = "AsmDwarfFunctionTemplateTag"; break;
        case 67l: retval = "AsmDwarfImportedDeclarationTag"; break;
        case 68l: retval = "AsmDwarfImportedModuleTag"; break;
        case 69l: retval = "AsmDwarfImportedUnitTag"; break;
        case 70l: retval = "AsmDwarfInformationTag"; break;
        case 71l: retval = "AsmDwarfInheritanceTag"; break;
        case 72l: retval = "AsmDwarfInlinedSubroutineTag"; break;
        case 73l: retval = "AsmDwarfInterfaceTypeTag"; break;
        case 74l: retval = "AsmDwarfLabelTag"; break;
        case 75l: retval = "AsmDwarfLexicalBlockTag"; break;
        case 76l: retval = "AsmDwarfLineTag"; break;
        case 77l: retval = "AsmDwarfLineListTag"; break;
        case 78l: retval = "AsmDwarfMacroTag"; break;
        case 79l: retval = "AsmDwarfMacroListTag"; break;
        case 80l: retval = "AsmDwarfMemberTag"; break;
        case 81l: retval = "AsmDwarfModuleTag"; break;
        case 82l: retval = "AsmDwarfMutableTypeTag"; break;
        case 83l: retval = "AsmDwarfNamelistTag"; break;
        case 84l: retval = "AsmDwarfNamelistItemTag"; break;
        case 85l: retval = "AsmDwarfNamespaceTag"; break;
        case 86l: retval = "AsmDwarfPackedTypeTag"; break;
        case 87l: retval = "AsmDwarfPartialUnitTag"; break;
        case 88l: retval = "AsmDwarfPointerTypeTag"; break;
        case 89l: retval = "AsmDwarfPtrToMemberTypeTag"; break;
        case 90l: retval = "AsmDwarfReferenceTypeTag"; break;
        case 91l: retval = "AsmDwarfRestrictTypeTag"; break;
        case 92l: retval = "AsmDwarfSetTypeTag"; break;
        case 93l: retval = "AsmDwarfSharedTypeTag"; break;
        case 94l: retval = "AsmDwarfStringTypeTag"; break;
        case 95l: retval = "AsmDwarfStructureTypeTag"; break;
        case 96l: retval = "AsmDwarfSubprogramTag"; break;
        case 97l: retval = "AsmDwarfSubrangeTypeTag"; break;
        case 98l: retval = "AsmDwarfSubroutineTypeTag"; break;
        case 99l: retval = "AsmDwarfTemplateTypeParameterTag"; break;
        case 100l: retval = "AsmDwarfTemplateValueParameterTag"; break;
        case 101l: retval = "AsmDwarfThrownTypeTag"; break;
        case 102l: retval = "AsmDwarfTryBlockTag"; break;
        case 103l: retval = "AsmDwarfTypedefTag"; break;
        case 104l: retval = "AsmDwarfUnionTypeTag"; break;
        case 105l: retval = "AsmDwarfUnknownConstructTag"; break;
        case 106l: retval = "AsmDwarfUnspecifiedParametersTag"; break;
        case 107l: retval = "AsmDwarfUnspecifiedTypeTag"; break;
        case 108l: retval = "AsmDwarfUpcRelaxedTypeTag"; break;
        case 109l: retval = "AsmDwarfUpcSharedTypeTag"; break;
        case 110l: retval = "AsmDwarfUpcStrictTypeTag"; break;
        case 111l: retval = "AsmDwarfVariableTag"; break;
        case 112l: retval = "AsmDwarfVariantTag"; break;
        case 113l: retval = "AsmDwarfVariantPartTag"; break;
        case 114l: retval = "AsmDwarfVolatileTypeTag"; break;
        case 115l: retval = "AsmDwarfWithStmtTag"; break;
        case 116l: retval = "AsmElfDynamicEntryTag"; break;
        case 117l: retval = "AsmElfDynamicEntryListTag"; break;
        case 118l: retval = "AsmElfDynamicSectionTag"; break;
        case 119l: retval = "AsmElfEHFrameEntryCITag"; break;
        case 120l: retval = "AsmElfEHFrameEntryCIListTag"; break;
        case 121l: retval = "AsmElfEHFrameEntryFDTag"; break;
        case 122l: retval = "AsmElfEHFrameEntryFDListTag"; break;
        case 123l: retval = "AsmElfEHFrameSection"; break;
        case 124l: retval = "AsmElfFileHeaderTag"; break;
        case 125l: retval = "AsmElfNoteEntryTag"; break;
        case 126l: retval = "AsmElfNoteEntryListTag"; break;
        case 127l: retval = "AsmElfNoteSection"; break;
        case 128l: retval = "AsmElfRelocEntryTag"; break;
        case 129l: retval = "AsmElfRelocEntryListTag"; break;
        case 130l: retval = "AsmElfRelocSectionTag"; break;
        case 131l: retval = "AsmElfSectionTag"; break;
        case 132l: retval = "AsmElfSectionTableTag"; break;
        case 133l: retval = "AsmElfSectionTableEntryTag"; break;
        case 134l: retval = "AsmElfSegmentTableTag"; break;
        case 135l: retval = "AsmElfSegmentTableEntryTag"; break;
        case 136l: retval = "AsmElfSegmentTableEntryListTag"; break;
        case 137l: retval = "AsmElfStringSectionTag"; break;
        case 138l: retval = "AsmElfStrtabTag"; break;
        case 139l: retval = "AsmElfSymbolTag"; break;
        case 140l: retval = "AsmElfSymbolListTag"; break;
        case 141l: retval = "AsmElfSymbolSectionTag"; break;
        case 142l: retval = "AsmElfSymverDefinedAuxTag"; break;
        case 143l: retval = "AsmElfSymverDefinedAuxListTag"; break;
        case 144l: retval = "AsmElfSymverDefinedEntryTag"; break;
        case 145l: retval = "AsmElfSymverDefinedEntryListTag"; break;
        case 146l: retval = "AsmElfSymverDefinedSection"; break;
        case 147l: retval = "AsmElfSymverEntryTag"; break;
        case 148l: retval = "AsmElfSymverEntryListTag"; break;
        case 149l: retval = "AsmElfSymverNeededAuxTag"; break;
        case 150l: retval = "AsmElfSymverNeededAuxListTag"; break;
        case 151l: retval = "AsmElfSymverNeededEntryTag"; break;
        case 152l: retval = "AsmElfSymverNeededEntryListTag"; break;
        case 153l: retval = "AsmElfSymverNeededSection"; break;
        case 154l: retval = "AsmElfSymverSection"; break;
        case 155l: retval = "AsmExecutableFileFormatTag"; break;
        case 156l: retval = "AsmExprListExpTag"; break;
        case 157l: retval = "AsmExpressionTag"; break;
        case 158l: retval = "AsmSynthesizedFieldDeclarationTag"; break;
        case 159l: retval = "AsmFloatTypeTag"; break;
        case 160l: retval = "AsmFloatValueExpressionTag"; break;
        case 161l: retval = "AsmFunctionTag"; break;
        case 163l: retval = "AsmGenericDLLTag"; break;
        case 164l: retval = "AsmGenericDLLListTag"; break;
        case 165l: retval = "AsmGenericFileTag"; break;
        case 166l: retval = "AsmGenericFileListTag"; break;
        case 167l: retval = "AsmGenericFormatTag"; break;
        case 168l: retval = "AsmGenericHeaderTag"; break;
        case 169l: retval = "AsmGenericHeaderListTag"; break;
        case 170l: retval = "AsmGenericSectionTag"; break;
        case 171l: retval = "AsmGenericSectionListTag"; break;
        case 172l: retval = "AsmGenericStringTag"; break;
        case 173l: retval = "AsmGenericStrtabTag"; break;
        case 174l: retval = "AsmGenericSymbolTag"; break;
        case 175l: retval = "AsmGenericSymbolListTag"; break;
        case 176l: retval = "AsmIndirectRegisterExpressionTag"; break;
        case 177l: retval = "AsmInstructionTag"; break;
        case 178l: retval = "AsmIntegerValueExpressionTag"; break;
        case 179l: retval = "AsmIntegerTypeTag"; break;
        case 180l: retval = "AsmInterpretationTag"; break;
        case 181l: retval = "AsmInterpretationListTag"; break;
        case 182l: retval = "AsmLEEntryPointTag"; break;
        case 183l: retval = "AsmLEEntryTableTag"; break;
        case 184l: retval = "AsmLEFileHeaderTag"; break;
        case 185l: retval = "AsmLENameTableTag"; break;
        case 186l: retval = "AsmLEPageTableTag"; break;
        case 187l: retval = "AsmLEPageTableEntryTag"; break;
        case 188l: retval = "AsmLERelocTableTag"; break;
        case 189l: retval = "AsmLESectionTag"; break;
        case 190l: retval = "AsmLESectionTableTag"; break;
        case 191l: retval = "AsmLESectionTableEntryTag"; break;
        case 192l: retval = "AsmM68kInstructionTag"; break;
        case 194l: retval = "AsmMemoryReferenceExpressionTag"; break;
        case 195l: retval = "AsmMipsInstructionTag"; break;
        case 196l: retval = "AsmNEEntryPointTag"; break;
        case 197l: retval = "AsmNEEntryTableTag"; break;
        case 198l: retval = "AsmNEFileHeaderTag"; break;
        case 199l: retval = "AsmNEModuleTableTag"; break;
        case 200l: retval = "AsmNENameTableTag"; break;
        case 202l: retval = "AsmNERelocEntryTag"; break;
        case 203l: retval = "AsmNERelocTableTag"; break;
        case 204l: retval = "AsmNESectionTag"; break;
        case 205l: retval = "AsmNESectionTableTag"; break;
        case 206l: retval = "AsmNESectionTableEntryTag"; break;
        case 207l: retval = "AsmNEStringTableTag"; break;
        case 208l: retval = "AsmNodeTag"; break;
        case 209l: retval = "ASM_OP"; break;
        case 210l: retval = "AsmOperandListTag"; break;
        case 211l: retval = "AsmPEExportDirectoryTag"; break;
        case 212l: retval = "AsmPEExportEntryTag"; break;
        case 213l: retval = "AsmPEExportEntryListTag"; break;
        case 214l: retval = "AsmPEExportSectionTag"; break;
        case 215l: retval = "AsmPEFileHeaderTag"; break;
        case 216l: retval = "AsmPEImportDirectoryTag"; break;
        case 217l: retval = "AsmPEImportDirectoryListTag"; break;
        case 218l: retval = "AsmPEImportItemTag"; break;
        case 219l: retval = "AsmPEImportItemListTag"; break;
        case 220l: retval = "AsmPEImportSectionTag"; break;
        case 221l: retval = "AsmPERVASizePairTag"; break;
        case 222l: retval = "AsmPERVASizePairListTag"; break;
        case 223l: retval = "AsmPESectionTag"; break;
        case 224l: retval = "AsmPESectionTableTag"; break;
        case 225l: retval = "AsmPESectionTableEntryTag"; break;
        case 226l: retval = "AsmPEStringSectionTag"; break;
        case 227l: retval = "AsmPowerpcInstructionTag"; break;
        case 230l: retval = "AsmRegisterNamesTag"; break;
        case 231l: retval = "AsmRegisterReferenceExpressionTag"; break;
        case 232l: retval = "AsmRiscOperationTag"; break;
        case 233l: retval = "AsmScalarTypeTag"; break;
        case 236l: retval = "AsmStatementTag"; break;
        case 237l: retval = "AsmStaticDataTag"; break;
        case 238l: retval = "ASM_STMT"; break;
        case 239l: retval = "AsmStoredStringTag"; break;
        case 240l: retval = "AsmStringStorageTag"; break;
        case 241l: retval = "AsmTypeTag"; break;
        case 242l: retval = "AsmUnaryArmSpecialRegisterListTag"; break;
        case 243l: retval = "AsmUnaryExpressionTag"; break;
        case 244l: retval = "AsmUnaryMinusTag"; break;
        case 245l: retval = "AsmUnaryPlusTag"; break;
        case 246l: retval = "AsmUnaryRrxTag"; break;
        case 247l: retval = "AsmValueExpressionTag"; break;
        case 248l: retval = "AsmVectorTypeTag"; break;
        case 249l: retval = "AsmX86InstructionTag"; break;
        case 250l: retval = "BINARY_ADDRESS_SYMBOL"; break;
        case 251l: retval = "BINARY_DATA_SYMBOL"; break;
        case 252l: retval = "ASSERT_STMT"; break;
        case 253l: retval = "ASSIGN_INIT"; break;
        case 254l: retval = "ASSIGN_OP"; break;
        case 255l: retval = "TEMP_Assign_Statement"; break;
        case 256l: retval = "TEMP_Assigned_Goto_Statement"; break;
        case 257l: retval = "TEMP_Associate_Statement"; break;
        case 258l: retval = "TEMP_AsteriskShapeExp"; break;
        case 259l: retval = "ATERM"; break;
        case 260l: retval = "AttributeTag"; break;
        case 261l: retval = "TEMP_Attribute_Specification_Statement"; break;
        case 262l: retval = "BACKSPACE_STATEMENT"; break;
        case 263l: retval = "BaseClassTag"; break;
        case 264l: retval = "ExpBaseClassTag"; break;
        case 265l: retval = "BaseClassModifierTag"; break;
        case 266l: retval = "BASIC_BLOCK_STMT"; break;
        case 267l: retval = "BidirectionalGraphTag"; break;
        case 268l: retval = "BinaryCompositeTag"; break;
        case 269l: retval = "BINARY_EXPRESSION"; break;
        case 270l: retval = "BITAND_OP"; break;
        case 271l: retval = "BitAttributeTag"; break;
        case 272l: retval = "BIT_COMPLEMENT_OP"; break;
        case 273l: retval = "BITOR_OP"; break;
        case 274l: retval = "BITXOR_OP"; break;
        case 275l: retval = "TEMP_Block_Data_Statement"; break;
        case 276l: retval = "BOOL_VAL"; break;
        case 277l: retval = "BREAK_STMT"; break;
        case 278l: retval = "CPP_DIRECTIVE_STMT"; break;
        case 279l: retval = "CASE_STMT"; break;
        case 280l: retval = "CAST_OP"; break;
        case 281l: retval = "CATCH_STMT"; break;
        case 282l: retval = "CATCH_STATEMENT_SEQ"; break;
        case 283l: retval = "CHAR_VAL"; break;
        case 284l: retval = "ClassDecl_attrTag"; break;
        case 285l: retval = "CLASS_DECL_STMT"; break;
        case 286l: retval = "CLASS_DEFN_STMT"; break;
        case 287l: retval = "CLASSNAME_REF"; break;
        case 288l: retval = "CLASS_NAME"; break;
        case 289l: retval = "T_CLASS"; break;
        case 290l: retval = "C_LINKAGE_DECLARATION_STMT"; break;
        case 291l: retval = "C_LINKAGE_END_STMT"; break;
        case 292l: retval = "C_LINKAGE_START_STMT"; break;
        case 293l: retval = "CLOSE_STATEMENT"; break;
        case 294l: retval = "TEMP_ColonShapeExp"; break;
        case 295l: retval = "COMMA_OP"; break;
        case 296l: retval = "COMMON_BLOCK"; break;
        case 297l: retval = "TEMP_CommonBlockObject"; break;
        case 298l: retval = "COMMON_SYMBOL"; break;
        case 299l: retval = "COMPLEX_VAL"; break;
        case 300l: retval = "COMPREHENSION"; break;
        case 302l: retval = "COMPOUND_ASSIGN_OP"; break;
        case 303l: retval = "COMPOUND_INIT"; break;
        case 304l: retval = "COMPOUND_LITERAL"; break;
        case 305l: retval = "TEMP_Computed_Goto_Statement"; break;
        case 306l: retval = "CONCATENATION_OP"; break;
        case 307l: retval = "EXPR_CONDITIONAL"; break;
        case 308l: retval = "CONJUGATE_OP"; break;
        case 309l: retval = "ConstVolatileModifierTag"; break;
        case 310l: retval = "CONSTRUCTOR_INIT"; break;
        case 311l: retval = "TEMP_Contains_Statement"; break;
        case 312l: retval = "CONTINUE_STMT"; break;
        case 313l: retval = "CTOR_INITIALIZER_LIST"; break;
        case 314l: retval = "TEMP_DataStatementGroup"; break;
        case 315l: retval = "TEMP_DataStatementObject"; break;
        case 316l: retval = "TEMP_DataStatementValue"; break;
        case 317l: retval = "DEAD_IF_DIRECTIVE_STMT"; break;
        case 318l: retval = "TEMP_Deallocate_Statement"; break;
        case 319l: retval = "DeclarationModifierTag"; break;
        case 320l: retval = "DECL_STMT"; break;
        case 321l: retval = "T_DECLTYPE"; break;
        case 322l: retval = "DEFAULT_STMT"; break;
        case 323l: retval = "DEFAULT_NAME"; break;
        case 324l: retval = "DEFINE_DIRECTIVE_STMT"; break;
        case 325l: retval = "DELETE_OP"; break;
        case 326l: retval = "TEMP_Derived_Type_Statement"; break;
        case 327l: retval = "DESIGNATED_INITIALIZER"; break;
        case 328l: retval = "DICTIONARY_COMPREHENSION"; break;
        case 329l: retval = "DICT_EXP"; break;
        case 330l: retval = "TEMP_DimensionObject"; break;
        case 332l: retval = "DirectedGraphEdgeTag"; break;
        case 334l: retval = "DirectoryTag"; break;
        case 335l: retval = "DirectoryListTag"; break;
        case 336l: retval = "DIV_ASSIGN_OP"; break;
        case 337l: retval = "DIV_OP"; break;
        case 338l: retval = "DO_WHILE_STMT"; break;
        case 339l: retval = "RECORD_REF"; break;
        case 340l: retval = "DOTSTAR_OP"; break;
        case 341l: retval = "DOUBLE_VAL"; break;
        case 342l: retval = "ElaboratedTypeModifierTag"; break;
        case 343l: retval = "ELEMENT_WISE_OP"; break;
        case 344l: retval = "ELEMENT_ADD_OP"; break;
        case 345l: retval = "ELEMENT_DIVIDE_OP"; break;
        case 346l: retval = "ELEMENT_LEFT_DIVIDE_OP"; break;
        case 347l: retval = "ELEMENT_MULT_OP"; break;
        case 348l: retval = "ELEMENT_POWER_OP"; break;
        case 349l: retval = "ELEMENT_SUBTRACT_OP"; break;
        case 350l: retval = "ELSE_DIRECTIVE_STMT"; break;
        case 351l: retval = "TEMP_Else_Where_Statement"; break;
        case 352l: retval = "ELSEIF_DIRECTIVE_STMT"; break;
        case 353l: retval = "EMPTY_DIRECTIVE_STMT"; break;
        case 354l: retval = "ENDFILE_STATEMENT"; break;
        case 355l: retval = "ENDIF_DIRECTIVE_STMT"; break;
        case 356l: retval = "ENTRY_STMT"; break;
        case 357l: retval = "ENUM_DECL_STMT"; break;
        case 358l: retval = "FIELD_NAME"; break;
        case 359l: retval = "ENUM_NAME"; break;
        case 360l: retval = "T_ENUM"; break;
        case 361l: retval = "ENUM_VAL"; break;
        case 362l: retval = "EQ_OP"; break;
        case 363l: retval = "TEMP_Equivalence_Statement"; break;
        case 364l: retval = "ERROR_DIRECTIVE_STMT"; break;
        case 365l: retval = "EXEC_STMT"; break;
        case 366l: retval = "EXPONENTIATION_OP"; break;
        case 367l: retval = "EXP_ASSIGN_OP"; break;
        case 368l: retval = "EXPR_LIST"; break;
        case 369l: retval = "EXPR_STMT"; break;
        case 370l: retval = "ExpressionTag"; break;
        case 371l: retval = "EXPRESSION_ROOT"; break;
        case 372l: retval = "FileTag"; break;
        case 373l: retval = "FileListTag"; break;
        case 374l: retval = "FLOAT_VAL"; break;
        case 375l: retval = "FLUSH_STATEMENT"; break;
        case 376l: retval = "FOR_ALL_STMT"; break;
        case 377l: retval = "FOR_INIT_STMT"; break;
        case 378l: retval = "FOR_STMT"; break;
        case 379l: retval = "TEMP_FormatItem"; break;
        case 380l: retval = "TEMP_FormatItemList"; break;
        case 381l: retval = "FORMAT_STATEMENT"; break;
        case 382l: retval = "FORTRAN_DO"; break;
        case 383l: retval = "TEMP_Fortran_Include_Line"; break;
        case 384l: retval = "FORTRAN_NONBLOCKED_DO"; break;
        case 385l: retval = "FuncDecl_attrTag"; break;
        case 386l: retval = "FUNC_CALL"; break;
        case 387l: retval = "FUNC_DECL_STMT"; break;
        case 388l: retval = "FUNC_DEFN_STMT"; break;
        case 389l: retval = "FUNCTION_PARAMETER_SCOPE"; break;
        case 390l: retval = "FunctionModifierTag"; break;
        case 391l: retval = "FUNCTION_PARAMETER_LIST"; break;
        case 392l: retval = "FUNCTION_PARAMETER_REF_EXP"; break;
        case 393l: retval = "T_FUNCTION_PARAMETER_TYPE_LIST"; break;
        case 394l: retval = "FUNCTION_REF"; break;
        case 395l: retval = "FUNCTION_NAME"; break;
        case 396l: retval = "T_FUNCTION"; break;
        case 397l: retval = "FUNCTYPE_NAME"; break;
        case 398l: retval = "FUNC_TBL_STMT"; break;
        case 399l: retval = "TYPE_TABLE"; break;
        case 400l: retval = "GLOBAL_STMT"; break;
        case 401l: retval = "GOTO_STMT"; break;
        case 402l: retval = "GraphTag"; break;
        case 403l: retval = "GraphEdgeTag"; break;
        case 404l: retval = "GraphEdgeListTag"; break;
        case 405l: retval = "GraphNodeTag"; break;
        case 406l: retval = "GraphNodeListTag"; break;
        case 407l: retval = "GE_OP"; break;
        case 408l: retval = "GT_OP"; break;
        case 409l: retval = "IO_ITEM_EXPR"; break;
        case 410l: retval = "IO_STATEMENT"; break;
        case 411l: retval = "IDENT_DIRECTIVE_STMT"; break;
        case 412l: retval = "IF_DIRECTIVE_STMT"; break;
        case 413l: retval = "IF_STMT"; break;
        case 414l: retval = "IFDEF_DIRECTIVE_STMT"; break;
        case 415l: retval = "IFNDEF_DIRECTIVE_STMT"; break;
        case 416l: retval = "IMAG_PART_OP"; break;
        case 417l: retval = "TEMP_Implicit_Statement"; break;
        case 418l: retval = "IMPLIED_DO"; break;
        case 419l: retval = "TEMP_Import_Statement"; break;
        case 420l: retval = "IncidenceDirectedGraphTag"; break;
        case 421l: retval = "IncidenceUndirectedGraphTag"; break;
        case 422l: retval = "INCLUDE_DIRECTIVE_STMT"; break;
        case 423l: retval = "INCLUDE_NEXT_DIRECTIVE_STMT"; break;
        case 424l: retval = "InitializedNameTag"; break;
        case 425l: retval = "EXPR_INIT"; break;
        case 426l: retval = "INQUIRE_STATEMENT"; break;
        case 427l: retval = "IntKeyedBidirectionalGraphTag"; break;
        case 428l: retval = "INT_VAL"; break;
        case 429l: retval = "INTEGER_DIV_OP"; break;
        case 430l: retval = "IDIV_ASSIGN_OP"; break;
        case 431l: retval = "TEMP_Interface_Body"; break;
        case 432l: retval = "TEMP_Header_File_Body"; break;
        case 433l: retval = "INTERFACE_STATEMENT"; break;
        case 434l: retval = "INTERFACE_SYMBOL"; break;
        case 435l: retval = "INTRINSIC_SYMBOL"; break;
        case 436l: retval = "IS_OP"; break;
        case 437l: retval = "IS_NOT_OP"; break;
        case 438l: retval = "IOR_ASSIGN_OP"; break;
        case 439l: retval = "KEY_DATUM_PAIR"; break;
        case 440l: retval = "EXEC_CONF"; break;
        case 441l: retval = "KERN_CALL"; break;
        case 442l: retval = "LABEL_REF"; break;
        case 443l: retval = "LABEL_STMT"; break;
        case 444l: retval = "JAVA_LABEL_STMT"; break;
        case 445l: retval = "LABEL_NAME"; break;
        case 446l: retval = "JAVA_LABEL_NAME"; break;
        case 447l: retval = "LambdaCaptureTag"; break;
        case 448l: retval = "LambdaCaptureListTag"; break;
        case 449l: retval = "LAMBDA_EXP"; break;
        case 450l: retval = "LAMBDA_REF_EXP"; break;
        case 451l: retval = "LEFT_DIVIDE_OP"; break;
        case 452l: retval = "LE_OP"; break;
        case 453l: retval = "LT_OP"; break;
        case 454l: retval = "LINE_DIRECTIVE_STMT"; break;
        case 455l: retval = "LINEMARKER_DIRECTIVE_STMT"; break;
        case 456l: retval = "LinkageModifierTag"; break;
        case 457l: retval = "LIST_COMPREHENSION"; break;
        case 458l: retval = "LIST_EXP"; break;
        case 459l: retval = "LocatedNodeTag"; break;
        case 460l: retval = "LocatedNodeSupportTag"; break;
        case 461l: retval = "LONG_DOUBLE_VAL"; break;
        case 462l: retval = "LONG_INT_VAL"; break;
        case 463l: retval = "LONG_LONG_INT_VAL"; break;
        case 464l: retval = "LSHIFT_ASSIGN_OP"; break;
        case 465l: retval = "LSHIFT_OP"; break;
        case 466l: retval = "MAGIC_COLON_EXP"; break;
        case 467l: retval = "MATRIX_EXP"; break;
        case 468l: retval = "MATRIX_TRANSPOSE_OP"; break;
        case 469l: retval = "MATLAB_FOR_STATEMENT"; break;
        case 470l: retval = "MFUNC_DECL_STMT"; break;
        case 471l: retval = "MEMBER_FUNCTION_REF"; break;
        case 472l: retval = "MEMBER_FUNC_NAME"; break;
        case 473l: retval = "T_MEMBERFUNCTION"; break;
        case 474l: retval = "MEMBERSHIP_OP"; break;
        case 475l: retval = "MS_ATTRIBUTE_DECL_STMT"; break;
        case 476l: retval = "MINUS_ASSIGN_OP"; break;
        case 477l: retval = "MINUSMINUS_OP"; break;
        case 478l: retval = "UNARY_MINUS_OP"; break;
        case 479l: retval = "MOD_ASSIGN_OP"; break;
        case 480l: retval = "MOD_OP"; break;
        case 481l: retval = "ModifierTag"; break;
        case 482l: retval = "ModifierNodesTag"; break;
        case 483l: retval = "T_MODIFIER"; break;
        case 484l: retval = "MODULE_STATEMENT"; break;
        case 485l: retval = "MODULE_SYMBOL"; break;
        case 486l: retval = "MULT_ASSIGN_OP"; break;
        case 487l: retval = "MULT_OP"; break;
        case 488l: retval = "NameTag"; break;
        case 489l: retval = "TEMP_Name_Group"; break;
        case 490l: retval = "T_NAME"; break;
        case 491l: retval = "TEMP_Namelist_Statement"; break;
        case 492l: retval = "NAMESPACE_ALIAS_DECLARATION_STMT"; break;
        case 493l: retval = "NAMESPACE_DECLARATION_STMT"; break;
        case 494l: retval = "NAMESPACE_DEFINITION_STMT"; break;
        case 495l: retval = "NAMESPACE_NAME"; break;
        case 496l: retval = "NARY_EXPRESSION"; break;
        case 497l: retval = "NARY_BOOLEAN_OP"; break;
        case 498l: retval = "NARY_COMPARISON_OP"; break;
        case 499l: retval = "NEW_OP"; break;
        case 500l: retval = "NodeTag"; break;
        case 501l: retval = "NOEXCEPT_OP"; break;
        case 502l: retval = "NE_OP"; break;
        case 503l: retval = "NOT_OP"; break;
        case 504l: retval = "NON_MEMBERSHIP_OP"; break;
        case 505l: retval = "NULL_EXPR"; break;
        case 506l: retval = "NULLPTR_VAL"; break;
        case 507l: retval = "NULL_STMT"; break;
        case 508l: retval = "TEMP_Nullify_Statement"; break;
        case 509l: retval = "OMP_ATOMIC_STMT"; break;
        case 510l: retval = "OMP_BARRIER_STMT"; break;
        case 511l: retval = "OMP_CRITICAL_STMT"; break;
        case 512l: retval = "OMP_CLAUSEBODY_STMT"; break;
        case 513l: retval = "OMP_BODY_STMT"; break;
        case 514l: retval = "OMP_DO_STMT"; break;
        case 515l: retval = "OMP_FLUSH_STMT"; break;
        case 516l: retval = "OMP_FOR_STMT"; break;
        case 517l: retval = "OMP_MASTER_STMT"; break;
        case 518l: retval = "OMP_ORDERED_STMT"; break;
        case 519l: retval = "OMP_PARALLEL_STMT"; break;
        case 520l: retval = "OMP_SECTION_STMT"; break;
        case 521l: retval = "OMP_SECTIONS_STMT"; break;
        case 522l: retval = "OMP_SINGLE_STMT"; break;
        case 523l: retval = "OMP_TASK_STMT"; break;
        case 524l: retval = "OMP_TASKWAIT_STMT"; break;
        case 525l: retval = "OMP_THREADPRIVATE_STMT"; break;
        case 526l: retval = "OMP_WORKSHARE_STMT"; break;
        case 527l: retval = "OMP_TARGET_STMT"; break;
        case 528l: retval = "OMP_TARGET_DATA_STMT"; break;
        case 529l: retval = "OMP_SIMD_STMT"; break;
        case 530l: retval = "OmpClauseTag"; break;
        case 531l: retval = "OmpBeginClauseTag"; break;
        case 532l: retval = "OmpCollapseClauseTag"; break;
        case 533l: retval = "OmpCopyinClauseTag"; break;
        case 534l: retval = "OmpCopyprivateClauseTag"; break;
        case 535l: retval = "OmpDefaultClauseTag"; break;
        case 536l: retval = "OmpEndClauseTag"; break;
        case 537l: retval = "OmpExpressionClauseTag"; break;
        case 538l: retval = "OmpFirstprivateClauseTag"; break;
        case 539l: retval = "OmpIfClauseTag"; break;
        case 540l: retval = "OmpIfDeviceTag"; break;
        case 541l: retval = "OmpLastprivateClauseTag"; break;
        case 542l: retval = "OmpNowaitClauseTag"; break;
        case 543l: retval = "OmpNumThreadsClauseTag"; break;
        case 544l: retval = "OmpOrderedClauseTag"; break;
        case 545l: retval = "OmpPrivateClauseTag"; break;
        case 546l: retval = "OmpReductionClauseTag"; break;
        case 547l: retval = "OmpScheduleClauseTag"; break;
        case 548l: retval = "OmpSharedClauseTag"; break;
        case 549l: retval = "OmpUntiedClauseTag"; break;
        case 550l: retval = "OmpVariablesClauseTag"; break;
        case 551l: retval = "OmpMapClauseTag"; break;
        case 552l: retval = "OmpSafelenTag"; break;
        case 553l: retval = "OmpLinearClauseTag"; break;
        case 554l: retval = "OmpUniformClauseTag"; break;
        case 555l: retval = "OmpAlignedClauseTag"; break;
        case 556l: retval = "OPENCL_ACCESS_MODE"; break;
        case 557l: retval = "OPEN_STATEMENT"; break;
        case 558l: retval = "OptionsTag"; break;
        case 559l: retval = "OR_OP"; break;
        case 560l: retval = "PARAMETER_STATEMENT"; break;
        case 561l: retval = "T_PARTIAL_FUNCTION_MODIFIER"; break;
        case 562l: retval = "T_PARTIAL_FUNCTION"; break;
        case 563l: retval = "PASS_STATEMENT"; break;
        case 564l: retval = "PLUS_ASSIGN_OP"; break;
        case 565l: retval = "PLUSPLUS_OP"; break;
        case 566l: retval = "ARRAY_OP"; break;
        case 567l: retval = "POINTER_ASSIGN_OP"; break;
        case 568l: retval = "DEREF_OP"; break;
        case 569l: retval = "T_MEMBER_POINTER"; break;
        case 570l: retval = "T_POINTER"; break;
        case 571l: retval = "POWER_OP"; break;
        case 572l: retval = "PragmaTag"; break;
        case 573l: retval = "PRAGMA_DECL"; break;
        case 574l: retval = "PRINT_STATEMENT"; break;
        case 575l: retval = "PROCEDURE_HEADER_STMT"; break;
        case 576l: retval = "PROGRAM_HEADER_STMT"; break;
        case 577l: retval = "ProjectTag"; break;
        case 578l: retval = "PSEUDO_DESTRUCTOR_REF"; break;
        case 579l: retval = "PYTHON_GLOBAL_STMT"; break;
        case 580l: retval = "PYTHON_PRINT_STMT"; break;
        case 581l: retval = "QualifiedNameTag"; break;
        case 582l: retval = "T_QUALIFIED_NAME"; break;
        case 583l: retval = "RANGE_EXP"; break;
        case 584l: retval = "READ_STATEMENT"; break;
        case 585l: retval = "REAL_PART_OP"; break;
        case 586l: retval = "TYPE_REF"; break;
        case 587l: retval = "T_REFERENCE"; break;
        case 588l: retval = "TEMP_Rename_Pair"; break;
        case 589l: retval = "RENAME_SYMBOL"; break;
        case 590l: retval = "RETURN_STMT"; break;
        case 591l: retval = "REWIND_STATEMENT"; break;
        case 592l: retval = "RSHIFT_ASSIGN_OP"; break;
        case 593l: retval = "RSHIFT_OP"; break;
        case 594l: retval = "T_RVALUE_REFERENCE"; break;
        case 595l: retval = "JAVA_UNSIGNED_RSHIFT_ASSIGN_OP"; break;
        case 596l: retval = "JAVA_UNSIGNED_RSHIFT_OP"; break;
        case 597l: retval = "SCOPE_OP"; break;
        case 598l: retval = "SCOPE_STMT"; break;
        case 599l: retval = "TEMP_Sequence_Statement"; break;
        case 600l: retval = "SET_COMPREHENSION"; break;
        case 601l: retval = "SHORT_VAL"; break;
        case 602l: retval = "SIZEOF_OP"; break;
        case 603l: retval = "ALIGNOF_OP"; break;
        case 604l: retval = "JAVA_INSTANCEOF_OP"; break;
        case 605l: retval = "SourceFileTag"; break;
        case 606l: retval = "SPAWN_STMT"; break;
        case 607l: retval = "JAVE_THROW_STMT"; break;
        case 608l: retval = "JAVA_FOREACH_STMT"; break;
        case 609l: retval = "JAVA_SYNC_STMT"; break;
        case 610l: retval = "T_JAVA_PARAM"; break;
        case 611l: retval = "T_JAVA_WILD"; break;
        case 612l: retval = "SpecialFunctionModifierTag"; break;
        case 613l: retval = "StatementTag"; break;
        case 614l: retval = "STATIC_ASSERTION_DECLARATION"; break;
        case 615l: retval = "STMT_DECL_STMT"; break;
        case 616l: retval = "STMT_EXPR"; break;
        case 617l: retval = "TEMP_Statement_Function_Statement"; break;
        case 618l: retval = "STOP_OR_PAUSE_STATEMENT"; break;
        case 619l: retval = "StorageModifierTag"; break;
        case 620l: retval = "STR_CONV"; break;
        case 621l: retval = "StringKeyedBidirectionalGraphTag"; break;
        case 622l: retval = "STRING_VAL"; break;
        case 623l: retval = "SUBSCRIPT_EXPR"; break;
        case 624l: retval = "SUBT_OP"; break;
        case 625l: retval = "SupportTag"; break;
        case 626l: retval = "SWITCH_STMT"; break;
        case 627l: retval = "SymbolTag"; break;
        case 628l: retval = "SymbolTableTag"; break;
        case 629l: retval = "TemplateArgumentTag"; break;
        case 630l: retval = "TemplateArgumentListTag"; break;
        case 631l: retval = "TEMPLATE_DECL_STMT"; break;
        case 632l: retval = "TEMPLATE_CLASS_DECL_STMT"; break;
        case 633l: retval = "TEMPLATE_CLASS_NAME"; break;
        case 634l: retval = "TEMPLATE_FUNCTION_DECL_STMT"; break;
        case 635l: retval = "TEMPLATE_FUNCTION_REF"; break;
        case 636l: retval = "TEMPLATE_FUNC_NAME"; break;
        case 637l: retval = "TEMPLATE_MEMBER_FUNCTION_DECL_STMT"; break;
        case 638l: retval = "TEMPLATE_MEMBER_FUNCTION_REF"; break;
        case 639l: retval = "TEMPLATE_MEMBER_FUNC_NAME"; break;
        case 640l: retval = "TEMPLATE_TYPEDEF_DECL_STMT"; break;
        case 641l: retval = "TEMPLATE_TYPEDEF_NAME"; break;
        case 642l: retval = "TEMPLATE_VARIABLE_DECL_STMT"; break;
        case 643l: retval = "TEMPLATE_VARIABLE_NAME"; break;
        case 644l: retval = "TEMPLATE_CLASS_DEF_STMT"; break;
        case 645l: retval = "TEMPLATE_FUNCTION_DEF_STMT"; break;
        case 646l: retval = "TEMPLATE_INST_DECL_STMT"; break;
        case 647l: retval = "TEMPLATE_INST_DEFN_STMT"; break;
        case 648l: retval = "TEMPLATE_INST_DIRECTIVE_STMT"; break;
        case 649l: retval = "TEMPLATE_INST_FUNCTION_DECL_STMT"; break;
        case 650l: retval = "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT"; break;
        case 651l: retval = "TEMPLATE_INST_TYPEDEF_DECL_STMT"; break;
        case 652l: retval = "TemplateParameterTag"; break;
        case 653l: retval = "TEMPLATE_PARAMETER_VAL"; break;
        case 654l: retval = "TemplateParameterListTag"; break;
        case 655l: retval = "TEMPLATE_NAME"; break;
        case 656l: retval = "T_TEMPLATE"; break;
        case 657l: retval = "THIS_NODE"; break;
        case 658l: retval = "TYPE_TRAIT_BUILTIN_OPERATOR"; break;
        case 659l: retval = "SUPER_NODE"; break;
        case 660l: retval = "THROW_OP"; break;
        case 661l: retval = "TOKEN"; break;
        case 662l: retval = "TRY_STMT"; break;
        case 663l: retval = "TUPLE_EXP"; break;
        case 664l: retval = "TypeTag"; break;
        case 665l: retval = "T_BOOL"; break;
        case 666l: retval = "T_CHAR"; break;
        case 667l: retval = "T_COMPLEX"; break;
        case 668l: retval = "T_DEFAULT"; break;
        case 669l: retval = "TYPE_EXPRESSION"; break;
        case 670l: retval = "T_LABEL"; break;
        case 671l: retval = "T_DOUBLE"; break;
        case 672l: retval = "T_ELLIPSE"; break;
        case 673l: retval = "T_FLOAT"; break;
        case 674l: retval = "T_GLOBAL_VOID"; break;
        case 675l: retval = "TYPEID_OP"; break;
        case 676l: retval = "T_IMAGINARY"; break;
        case 677l: retval = "T_INT"; break;
        case 678l: retval = "T_LONG"; break;
        case 679l: retval = "T_LONG_DOUBLE"; break;
        case 680l: retval = "T_LONG_LONG"; break;
        case 681l: retval = "TypeModifierTag"; break;
        case 682l: retval = "T_MATRIX"; break;
        case 683l: retval = "T_TUPLE"; break;
        case 684l: retval = "T_NULLPTR"; break;
        case 685l: retval = "T_TYPEOF_TYPE"; break;
        case 686l: retval = "T_SHORT"; break;
        case 687l: retval = "T_SIGNED_128BIT_INTEGER"; break;
        case 688l: retval = "T_SIGNED_CHAR"; break;
        case 689l: retval = "T_SIGNED_INT"; break;
        case 690l: retval = "T_SIGNED_LONG"; break;
        case 691l: retval = "T_SIGNED_LONG_LONG"; break;
        case 692l: retval = "T_SIGNED_SHORT"; break;
        case 693l: retval = "T_STRING"; break;
        case 694l: retval = "T_UNKNOWN"; break;
        case 695l: retval = "T_UNSIGNED_128BIT_INTEGER"; break;
        case 696l: retval = "T_UNSIGNED_CHAR"; break;
        case 697l: retval = "T_UNSIGNED_INT"; break;
        case 698l: retval = "T_UNSIGNED_LONG"; break;
        case 699l: retval = "T_UNSIGNED_LONG_LONG"; break;
        case 700l: retval = "T_UNSIGNED_SHORT"; break;
        case 701l: retval = "T_VOID"; break;
        case 702l: retval = "T_WCHAR"; break;
        case 703l: retval = "TYPEDEF_STMT"; break;
        case 704l: retval = "T_TYPEDEF_SEQ"; break;
        case 705l: retval = "TYPEDEF_NAME"; break;
        case 706l: retval = "T_TYPEDEF"; break;
        case 707l: retval = "UPC_AccessModifierTag"; break;
        case 708l: retval = "UNARY_ADD_OP"; break;
        case 709l: retval = "UNARY_EXPRESSION"; break;
        case 710l: retval = "UNDEF_DIRECTIVE_STMT"; break;
        case 711l: retval = "UndirectedGraphEdgeTag"; break;
        case 712l: retval = "TEMP_UnknownArrayOrFunctionReference"; break;
        case 713l: retval = "UnknownFileTag"; break;
        case 715l: retval = "Unparse_InfoTag"; break;
        case 716l: retval = "UNSIGNED_CHAR_VAL"; break;
        case 717l: retval = "UNSIGNED_INT_VAL"; break;
        case 718l: retval = "UNSIGNED_LONG_LONG_INT_VAL"; break;
        case 719l: retval = "UNSIGNED_LONG_INT_VAL"; break;
        case 720l: retval = "UNSIGNED_SHORT_VAL"; break;
        case 721l: retval = "UntypedNodeTag"; break;
        case 722l: retval = "UntypedExpressionTag"; break;
        case 723l: retval = "TEMP_UntypedUnaryOperator"; break;
        case 724l: retval = "TEMP_UntypedBinaryOperator"; break;
        case 725l: retval = "TEMP_UntypedValueExpression"; break;
        case 726l: retval = "TEMP_UntypedArrayReferenceExpression"; break;
        case 727l: retval = "TEMP_UntypedOtherExpression"; break;
        case 728l: retval = "TEMP_UntypedFunctionCallOrArrayReferenceExpression"; break;
        case 729l: retval = "UntypedStatementTag"; break;
        case 730l: retval = "TEMP_UntypedNamedStatement"; break;
        case 731l: retval = "TEMP_UntypedAssignmentStatement"; break;
        case 732l: retval = "TEMP_UntypedFunctionCallStatement"; break;
        case 733l: retval = "TEMP_UntypedBlockStatement"; break;
        case 734l: retval = "TEMP_UntypedOtherStatement"; break;
        case 735l: retval = "UntypedDeclarationStatementTag"; break;
        case 736l: retval = "TEMP_UntypedInitializedName"; break;
        case 737l: retval = "TEMP_UntypedImplicitDeclaration"; break;
        case 738l: retval = "TEMP_UntypedVariableDeclaration"; break;
        case 739l: retval = "TEMP_UntypedProgramHeaderDeclaration"; break;
        case 740l: retval = "UntypedFunctionDeclarationTag"; break;
        case 741l: retval = "TEMP_UntypedSubroutineDeclaration"; break;
        case 742l: retval = "TEMP_UntypedReferenceExpression"; break;
        case 743l: retval = "UntypedTypeTag"; break;
        case 744l: retval = "TEMP_UntypedArrayType"; break;
        case 745l: retval = "TEMP_UntypedAttribute"; break;
        case 746l: retval = "TEMP_UntypedFile"; break;
        case 747l: retval = "UntypedScopeTag"; break;
        case 748l: retval = "TEMP_UntypedFunctionScope"; break;
        case 749l: retval = "TEMP_UntypedModuleScope"; break;
        case 750l: retval = "TEMP_UntypedGlobalScope"; break;
        case 751l: retval = "TEMP_UntypedModuleDeclaration"; break;
        case 752l: retval = "TEMP_UntypedStatementList"; break;
        case 753l: retval = "TEMP_UntypedDeclarationStatementList"; break;
        case 754l: retval = "TEMP_UntypedFunctionDeclarationList"; break;
        case 755l: retval = "TEMP_UntypedInitializedNameList"; break;
        case 756l: retval = "UPC_BARRIER_STMT"; break;
        case 757l: retval = "UPC_BLOCK_SIZEOF_EXPR"; break;
        case 758l: retval = "UPC_ELEM_SIZEOF_EXPR"; break;
        case 759l: retval = "UPC_FENCE_STMT"; break;
        case 760l: retval = "UPC_FORALL_STMT"; break;
        case 761l: retval = "UPC_LOCAL_SIZEOF_EXPR"; break;
        case 762l: retval = "UPC_MYTHREAD"; break;
        case 763l: retval = "UPC_NOTIFY_STMT"; break;
        case 764l: retval = "UPC_THREADS"; break;
        case 765l: retval = "UPC_WAIT_STMT"; break;
        case 766l: retval = "USE_STATEMENT"; break;
        case 767l: retval = "USER_DEFINED_BINARY_OP"; break;
        case 768l: retval = "USER_DEFINED_UNARY_OP"; break;
        case 769l: retval = "USING_DECLARATION_STMT"; break;
        case 770l: retval = "USING_DIRECTIVE_STMT"; break;
        case 771l: retval = "ValueExpTag"; break;
        case 772l: retval = "VA_COPY_OP"; break;
        case 773l: retval = "VA_END_OP"; break;
        case 774l: retval = "VA_OP"; break;
        case 775l: retval = "VA_START_ONE_OPERAND_OP"; break;
        case 776l: retval = "VA_START_OP"; break;
        case 777l: retval = "VAR_REF"; break;
        case 778l: retval = "VAR_DECL_STMT"; break;
        case 779l: retval = "VAR_DEFN_STMT"; break;
        case 780l: retval = "VARIABLE_NAME"; break;
        case 781l: retval = "VARIANT_EXPR"; break;
        case 782l: retval = "VARIANT_STMT"; break;
        case 783l: retval = "WAIT_STATEMENT"; break;
        case 784l: retval = "WARNING_DIRECTIVE_STMT"; break;
        case 785l: retval = "WITH_STATEMENT"; break;
        case 786l: retval = "WCHAR_VAL"; break;
        case 787l: retval = "TEMP_Where_Statement"; break;
        case 788l: retval = "WHILE_STMT"; break;
        case 789l: retval = "WRITE_STATEMENT"; break;
        case 790l: retval = "XOR_ASSIGN_OP"; break;
        case 791l: retval = "YIELD_EXP"; break;
        case 792l: retval = "_File_InfoTag"; break;
        case 793l: retval = "T_CAFTEAM"; break;
        case 794l: retval = "WITHTEAM_STMT"; break;
        case 795l: retval = "COARRAY_REF_EXPR"; break;
        case 796l: retval = "CALL_EXPRESSION"; break;
        case 797l: retval = "T_CRAY_POINTER"; break;
        case 798l: retval = "TEMP_JavaImportStatement"; break;
        case 799l: retval = "TEMP_JavaPackageDeclaration"; break;
        case 800l: retval = "TEMP_JavaPackageStatement"; break;
        case 801l: retval = "JavaImportStatementListTag"; break;
        case 802l: retval = "JavaClassDeclarationListTag"; break;
        case 803l: retval = "JavaMemberValuePairTag"; break;
        case 804l: retval = "JAVA_ANNOTATION"; break;
        case 805l: retval = "JAVA_MARKER_ANNOTATION"; break;
        case 806l: retval = "JAVA_SINGLE_MEMBER_ANNOTATION"; break;
        case 807l: retval = "JAVA_NORMAL_ANNOTATION"; break;
        case 808l: retval = "JAVA_TYPE_EXPRESSION"; break;
        case 809l: retval = "T_JAVA_QUALIFIED"; break;
        case 810l: retval = "CLASS_NODE"; break;
        case 811l: retval = "T_JAVA_UNION"; break;
        case 812l: retval = "T_JAVA_PARAMETER"; break;
        case 813l: retval = "ASYNC_STMT"; break;
        case 814l: retval = "FINISH_STMT"; break;
        case 815l: retval = "AT_STMT"; break;
        case 816l: retval = "HERE_NODE"; break;
        case 818l: retval = "Cxx_Grammar_UNKNOWN_GRAMMAR"; break;
        case 819l: retval = "Cxx_Grammar_LAST_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Cxx_GrammarVariants)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Cxx_GrammarVariants::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DOTGraphEdge::DOTArrowTypes is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/astVisualization/AstAttributeDOT.h:134
/** Converts an enum of type DOTGraphEdge::DOTArrowTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDOTGraphEdgeDOTArrowTypes(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementArrowTypes"; break;
        case 1l: retval = "normal"; break;
        case 2l: retval = "inv"; break;
        case 3l: retval = "dot"; break;
        case 4l: retval = "invdot"; break;
        case 5l: retval = "odot"; break;
        case 6l: retval = "invodot"; break;
        case 7l: retval = "none"; break;
        case 8l: retval = "tee"; break;
        case 9l: retval = "empty"; break;
        case 10l: retval = "invempty"; break;
        case 11l: retval = "diamond"; break;
        case 12l: retval = "odiamond"; break;
        case 13l: retval = "ediamond"; break;
        case 14l: retval = "crow"; break;
        case 15l: retval = "box"; break;
        case 16l: retval = "obox"; break;
        case 17l: retval = "open"; break;
        case 18l: retval = "halfopen"; break;
        case 19l: retval = "vee"; break;
        case 20l: retval = "END_OF_NODE_TYPE_LIST_DOTArrowTypes"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DOTGraphEdge::DOTArrowTypes)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DOTGraphNode::DOTShapeTypes is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/astVisualization/AstAttributeDOT.h:87
/** Converts an enum of type DOTGraphNode::DOTShapeTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDOTGraphNodeDOTShapeTypes(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementDOTShapeTypes"; break;
        case 1l: retval = "polygon"; break;
        case 2l: retval = "ellipse"; break;
        case 3l: retval = "record"; break;
        case 4l: retval = "mrecord"; break;
        case 5l: retval = "END_OF_NODE_TYPE_LIST_DOTShapeTypes"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DOTGraphNode::DOTShapeTypes)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DOTGraphNode::DOTShapeTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DeleteEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/grammar.h:129
/** Converts an enum of type DeleteEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDeleteEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "DEF_DELETE"; break;
        case 1l: retval = "NO_DELETE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DeleteEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DeleteEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DependencyInfo::State is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/ProjectManager/DependencyInfo.h:21
/** Converts an enum of type DependencyInfo::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDependencyInfoState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "VALID"; break;
        case 1l: retval = "INVALID"; break;
        case 2l: retval = "ERROR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DependencyInfo::State)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DependencyInfo::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DisplayEdge::PaintMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/AstGraphWidget/DisplayEdge.h:40
/** Converts an enum of type DisplayEdge::PaintMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDisplayEdgePaintMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "STRAIGHT"; break;
        case 1l: retval = "RECTANGULAR"; break;
        case 2l: retval = "BEZIER_QUAD"; break;
        case 3l: retval = "BEZIER_CUBIC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DisplayEdge::PaintMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DisplayEdge::PaintMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::Dir_ection is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h:14
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::Dir_ection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersDir_ection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PRE_DOMINATOR"; break;
        case 1l: retval = "POST_DOMINATOR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DominatorTreesAndDominanceFrontiers::Dir_ection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::DominatorTree::Direction is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h:51
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::DominatorTree::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PRE"; break;
        case 1l: retval = "POST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgActualArgumentExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1042
/** Converts an enum of type E_SgActualArgumentExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgActualArgumentExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgActualArgumentExpression_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgActualArgumentExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgActualArgumentExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:796
/** Converts an enum of type E_SgAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAddOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAddOp_lhs_operand_i"; break;
        case 1l: retval = "SgAddOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAddOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAddressOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:730
/** Converts an enum of type E_SgAddressOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAddressOfOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAddressOfOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAddressOfOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAddressOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAggregateInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:997
/** Converts an enum of type E_SgAggregateInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAggregateInitializer(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAggregateInitializer_initializers"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAggregateInitializer)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAggregateInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAliasSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1156
/** Converts an enum of type E_SgAliasSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAliasSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAliasSymbol_alias"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAliasSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAliasSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAlignOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1090
/** Converts an enum of type E_SgAlignOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAlignOfOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAlignOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAlignOfOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAlignOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAllocateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:619
/** Converts an enum of type E_SgAllocateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAllocateStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAllocateStatement_expr_list"; break;
        case 1l: retval = "SgAllocateStatement_stat_expression"; break;
        case 2l: retval = "SgAllocateStatement_errmsg_expression"; break;
        case 3l: retval = "SgAllocateStatement_source_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAllocateStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAllocateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAndAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:868
/** Converts an enum of type E_SgAndAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAndAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAndAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgAndAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAndAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAndAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:814
/** Converts an enum of type E_SgAndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAndOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAndOp_lhs_operand_i"; break;
        case 1l: retval = "SgAndOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAndOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArithmeticIfStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:607
/** Converts an enum of type E_SgArithmeticIfStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArithmeticIfStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgArithmeticIfStatement_conditional"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgArithmeticIfStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArithmeticIfStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:175
/** Converts an enum of type E_SgArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrayType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgArrayType_type_kind"; break;
        case 1l: retval = "SgArrayType_index"; break;
        case 2l: retval = "SgArrayType_dim_info"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgArrayType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArrowExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:766
/** Converts an enum of type E_SgArrowExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrowExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgArrowExp_lhs_operand_i"; break;
        case 1l: retval = "SgArrowExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgArrowExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrowExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArrowStarOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:775
/** Converts an enum of type E_SgArrowStarOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrowStarOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgArrowStarOp_lhs_operand_i"; break;
        case 1l: retval = "SgArrowStarOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgArrowStarOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrowStarOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmArmInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1171
/** Converts an enum of type E_SgAsmArmInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmArmInstruction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmArmInstruction_operandList"; break;
        case 1l: retval = "SgAsmArmInstruction_semantics"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmArmInstruction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmArmInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAdd is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1198
/** Converts an enum of type E_SgAsmBinaryAdd to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAdd(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryAdd_lhs"; break;
        case 1l: retval = "SgAsmBinaryAdd_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryAdd)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAdd::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAddPostupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1219
/** Converts an enum of type E_SgAsmBinaryAddPostupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAddPostupdate(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryAddPostupdate_lhs"; break;
        case 1l: retval = "SgAsmBinaryAddPostupdate_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryAddPostupdate)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAddPostupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAddPreupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1213
/** Converts an enum of type E_SgAsmBinaryAddPreupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAddPreupdate(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryAddPreupdate_lhs"; break;
        case 1l: retval = "SgAsmBinaryAddPreupdate_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryAddPreupdate)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAddPreupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAsr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1231
/** Converts an enum of type E_SgAsmBinaryAsr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAsr(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryAsr_lhs"; break;
        case 1l: retval = "SgAsmBinaryAsr_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryAsr)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAsr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryDivide is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1207
/** Converts an enum of type E_SgAsmBinaryDivide to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryDivide(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryDivide_lhs"; break;
        case 1l: retval = "SgAsmBinaryDivide_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryDivide)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryDivide::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1237
/** Converts an enum of type E_SgAsmBinaryExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryExpression_lhs"; break;
        case 1l: retval = "SgAsmBinaryExpression_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryLsl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1225
/** Converts an enum of type E_SgAsmBinaryLsl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryLsl(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryLsl_lhs"; break;
        case 1l: retval = "SgAsmBinaryLsl_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryLsl)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryLsl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryLsr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1228
/** Converts an enum of type E_SgAsmBinaryLsr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryLsr(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryLsr_lhs"; break;
        case 1l: retval = "SgAsmBinaryLsr_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryLsr)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryLsr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryMod is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1210
/** Converts an enum of type E_SgAsmBinaryMod to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryMod(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryMod_lhs"; break;
        case 1l: retval = "SgAsmBinaryMod_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryMod)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryMod::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryMultiply is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1204
/** Converts an enum of type E_SgAsmBinaryMultiply to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryMultiply(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryMultiply_lhs"; break;
        case 1l: retval = "SgAsmBinaryMultiply_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryMultiply)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryMultiply::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryRor is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1234
/** Converts an enum of type E_SgAsmBinaryRor to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryRor(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinaryRor_lhs"; break;
        case 1l: retval = "SgAsmBinaryRor_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinaryRor)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryRor::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinarySubtract is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1201
/** Converts an enum of type E_SgAsmBinarySubtract to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtract(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinarySubtract_lhs"; break;
        case 1l: retval = "SgAsmBinarySubtract_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinarySubtract)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtract::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinarySubtractPostupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1222
/** Converts an enum of type E_SgAsmBinarySubtractPostupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtractPostupdate(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinarySubtractPostupdate_lhs"; break;
        case 1l: retval = "SgAsmBinarySubtractPostupdate_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinarySubtractPostupdate)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtractPostupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinarySubtractPreupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1216
/** Converts an enum of type E_SgAsmBinarySubtractPreupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtractPreupdate(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBinarySubtractPreupdate_lhs"; break;
        case 1l: retval = "SgAsmBinarySubtractPreupdate_rhs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBinarySubtractPreupdate)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtractPreupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1165
/** Converts an enum of type E_SgAsmBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBlock(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmBlock_statementList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmBlock)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCoffSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1369
/** Converts an enum of type E_SgAsmCoffSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmCoffSymbol_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmCoffSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCoffSymbolList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1438
/** Converts an enum of type E_SgAsmCoffSymbolList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbolList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmCoffSymbolList_symbols"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmCoffSymbolList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbolList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCoffSymbolTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1342
/** Converts an enum of type E_SgAsmCoffSymbolTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbolTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmCoffSymbolTable_symbols"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmCoffSymbolTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbolTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCommonSubExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1258
/** Converts an enum of type E_SgAsmCommonSubExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCommonSubExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmCommonSubExpression_subexpression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmCommonSubExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCommonSubExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmConstantExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1192
/** Converts an enum of type E_SgAsmConstantExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmConstantExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmConstantExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmConstantExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmConstantExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDOSFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1291
/** Converts an enum of type E_SgAsmDOSFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDOSFileHeader(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDOSFileHeader_exec_format"; break;
        case 1l: retval = "SgAsmDOSFileHeader_dlls"; break;
        case 2l: retval = "SgAsmDOSFileHeader_sections"; break;
        case 3l: retval = "SgAsmDOSFileHeader_relocs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDOSFileHeader)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDOSFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1462
/** Converts an enum of type E_SgAsmDwarfArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfArrayType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfArrayType_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfArrayType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfClassType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1465
/** Converts an enum of type E_SgAsmDwarfClassType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfClassType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfClassType_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfClassType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfClassType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfCommonBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1486
/** Converts an enum of type E_SgAsmDwarfCommonBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCommonBlock(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfCommonBlock_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfCommonBlock)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCommonBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfCompilationUnit is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1474
/** Converts an enum of type E_SgAsmDwarfCompilationUnit to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCompilationUnit(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfCompilationUnit_line_info"; break;
        case 1l: retval = "SgAsmDwarfCompilationUnit_language_constructs"; break;
        case 2l: retval = "SgAsmDwarfCompilationUnit_macro_info"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfCompilationUnit)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCompilationUnit::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfCompilationUnitList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1459
/** Converts an enum of type E_SgAsmDwarfCompilationUnitList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCompilationUnitList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfCompilationUnitList_cu_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfCompilationUnitList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCompilationUnitList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfConstructList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1498
/** Converts an enum of type E_SgAsmDwarfConstructList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfConstructList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfConstructList_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfConstructList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfConstructList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfEnumerationType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1468
/** Converts an enum of type E_SgAsmDwarfEnumerationType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfEnumerationType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfEnumerationType_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfEnumerationType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfEnumerationType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfInlinedSubroutine is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1489
/** Converts an enum of type E_SgAsmDwarfInlinedSubroutine to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfInlinedSubroutine(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfInlinedSubroutine_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfInlinedSubroutine)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfInlinedSubroutine::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfLexicalBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1471
/** Converts an enum of type E_SgAsmDwarfLexicalBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfLexicalBlock(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfLexicalBlock_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfLexicalBlock)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfLexicalBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfLineList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1456
/** Converts an enum of type E_SgAsmDwarfLineList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfLineList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfLineList_line_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfLineList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfLineList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfMacroList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1453
/** Converts an enum of type E_SgAsmDwarfMacroList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfMacroList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfMacroList_macro_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfMacroList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfMacroList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfNamespace is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1495
/** Converts an enum of type E_SgAsmDwarfNamespace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfNamespace(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfNamespace_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfNamespace)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfNamespace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfStructureType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1477
/** Converts an enum of type E_SgAsmDwarfStructureType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfStructureType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfStructureType_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfStructureType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfStructureType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfSubprogram is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1492
/** Converts an enum of type E_SgAsmDwarfSubprogram to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfSubprogram(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfSubprogram_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfSubprogram)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfSubprogram::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfSubroutineType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1480
/** Converts an enum of type E_SgAsmDwarfSubroutineType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfSubroutineType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfSubroutineType_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfSubroutineType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfSubroutineType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfUnionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1483
/** Converts an enum of type E_SgAsmDwarfUnionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfUnionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmDwarfUnionType_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmDwarfUnionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfUnionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfDynamicEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1396
/** Converts an enum of type E_SgAsmElfDynamicEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfDynamicEntry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfDynamicEntry_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfDynamicEntry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfDynamicEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfDynamicSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1306
/** Converts an enum of type E_SgAsmElfDynamicSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfDynamicSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfDynamicSection_section_entry"; break;
        case 1l: retval = "SgAsmElfDynamicSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfDynamicSection_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfDynamicSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfDynamicSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfEHFrameEntryCI is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1444
/** Converts an enum of type E_SgAsmElfEHFrameEntryCI to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfEHFrameEntryCI(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfEHFrameEntryCI_fd_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfEHFrameEntryCI)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfEHFrameEntryCI::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfEHFrameSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1315
/** Converts an enum of type E_SgAsmElfEHFrameSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfEHFrameSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfEHFrameSection_section_entry"; break;
        case 1l: retval = "SgAsmElfEHFrameSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfEHFrameSection_ci_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfEHFrameSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfEHFrameSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1294
/** Converts an enum of type E_SgAsmElfFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfFileHeader(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfFileHeader_exec_format"; break;
        case 1l: retval = "SgAsmElfFileHeader_dlls"; break;
        case 2l: retval = "SgAsmElfFileHeader_sections"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfFileHeader)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfNoteEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1402
/** Converts an enum of type E_SgAsmElfNoteEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfNoteEntry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfNoteEntry_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfNoteEntry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfNoteEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfNoteSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1312
/** Converts an enum of type E_SgAsmElfNoteSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfNoteSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfNoteSection_section_entry"; break;
        case 1l: retval = "SgAsmElfNoteSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfNoteSection_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfNoteSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfNoteSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfRelocEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1387
/** Converts an enum of type E_SgAsmElfRelocEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfRelocEntryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfRelocEntryList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfRelocEntryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfRelocEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfRelocSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1303
/** Converts an enum of type E_SgAsmElfRelocSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfRelocSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfRelocSection_section_entry"; break;
        case 1l: retval = "SgAsmElfRelocSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfRelocSection_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfRelocSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfRelocSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1327
/** Converts an enum of type E_SgAsmElfSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSection_section_entry"; break;
        case 1l: retval = "SgAsmElfSection_segment_entry"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSegmentTableEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1399
/** Converts an enum of type E_SgAsmElfSegmentTableEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSegmentTableEntryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSegmentTableEntryList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSegmentTableEntryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSegmentTableEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfStringSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1309
/** Converts an enum of type E_SgAsmElfStringSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfStringSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfStringSection_section_entry"; break;
        case 1l: retval = "SgAsmElfStringSection_segment_entry"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfStringSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfStringSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1372
/** Converts an enum of type E_SgAsmElfSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymbol_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymbolList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1384
/** Converts an enum of type E_SgAsmElfSymbolList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbolList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymbolList_symbols"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymbolList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbolList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymbolSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1300
/** Converts an enum of type E_SgAsmElfSymbolSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbolSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymbolSection_section_entry"; break;
        case 1l: retval = "SgAsmElfSymbolSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfSymbolSection_symbols"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymbolSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbolSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedAux is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1414
/** Converts an enum of type E_SgAsmElfSymverDefinedAux to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedAux(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverDefinedAux_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverDefinedAux)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedAux::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedAuxList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1417
/** Converts an enum of type E_SgAsmElfSymverDefinedAuxList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedAuxList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverDefinedAuxList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverDefinedAuxList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedAuxList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1408
/** Converts an enum of type E_SgAsmElfSymverDefinedEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedEntry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverDefinedEntry_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverDefinedEntry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1411
/** Converts an enum of type E_SgAsmElfSymverDefinedEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedEntryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverDefinedEntryList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverDefinedEntryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1321
/** Converts an enum of type E_SgAsmElfSymverDefinedSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverDefinedSection_section_entry"; break;
        case 1l: retval = "SgAsmElfSymverDefinedSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfSymverDefinedSection_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverDefinedSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1405
/** Converts an enum of type E_SgAsmElfSymverEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverEntryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverEntryList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverEntryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededAux is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1426
/** Converts an enum of type E_SgAsmElfSymverNeededAux to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededAux(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverNeededAux_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverNeededAux)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededAux::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededAuxList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1429
/** Converts an enum of type E_SgAsmElfSymverNeededAuxList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededAuxList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverNeededAuxList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverNeededAuxList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededAuxList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1420
/** Converts an enum of type E_SgAsmElfSymverNeededEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededEntry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverNeededEntry_file_name"; break;
        case 1l: retval = "SgAsmElfSymverNeededEntry_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverNeededEntry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1423
/** Converts an enum of type E_SgAsmElfSymverNeededEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededEntryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverNeededEntryList_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverNeededEntryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1324
/** Converts an enum of type E_SgAsmElfSymverNeededSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverNeededSection_section_entry"; break;
        case 1l: retval = "SgAsmElfSymverNeededSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfSymverNeededSection_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverNeededSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1318
/** Converts an enum of type E_SgAsmElfSymverSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmElfSymverSection_section_entry"; break;
        case 1l: retval = "SgAsmElfSymverSection_segment_entry"; break;
        case 2l: retval = "SgAsmElfSymverSection_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmElfSymverSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmExprListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1261
/** Converts an enum of type E_SgAsmExprListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmExprListExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmExprListExp_expressions"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmExprListExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmExprListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmFloatValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1189
/** Converts an enum of type E_SgAsmFloatValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmFloatValueExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmFloatValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmFloatValueExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmFloatValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmFunction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1162
/** Converts an enum of type E_SgAsmFunction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmFunction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmFunction_statementList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmFunction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmFunction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericDLL is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1276
/** Converts an enum of type E_SgAsmGenericDLL to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericDLL(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericDLL_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericDLL)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericDLL::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1279
/** Converts an enum of type E_SgAsmGenericFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericFile(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericFile_dwarf_info"; break;
        case 1l: retval = "SgAsmGenericFile_headers"; break;
        case 2l: retval = "SgAsmGenericFile_holes"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericFile)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericFileList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1510
/** Converts an enum of type E_SgAsmGenericFileList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericFileList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericFileList_files"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericFileList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericFileList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1297
/** Converts an enum of type E_SgAsmGenericHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericHeader(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericHeader_exec_format"; break;
        case 1l: retval = "SgAsmGenericHeader_dlls"; break;
        case 2l: retval = "SgAsmGenericHeader_sections"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericHeader)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericHeaderList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1381
/** Converts an enum of type E_SgAsmGenericHeaderList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericHeaderList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericHeaderList_headers"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericHeaderList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericHeaderList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericSectionList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1378
/** Converts an enum of type E_SgAsmGenericSectionList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericSectionList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericSectionList_sections"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericSectionList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericSectionList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1375
/** Converts an enum of type E_SgAsmGenericSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmGenericSymbol_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmGenericSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1183
/** Converts an enum of type E_SgAsmInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInstruction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmInstruction_operandList"; break;
        case 1l: retval = "SgAsmInstruction_semantics"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmInstruction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmIntegerValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1186
/** Converts an enum of type E_SgAsmIntegerValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmIntegerValueExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmIntegerValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmIntegerValueExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmIntegerValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmInterpretation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1270
/** Converts an enum of type E_SgAsmInterpretation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInterpretation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmInterpretation_global_block"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmInterpretation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInterpretation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmInterpretationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1507
/** Converts an enum of type E_SgAsmInterpretationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInterpretationList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmInterpretationList_interpretations"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmInterpretationList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInterpretationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEEntryPoint is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1450
/** Converts an enum of type E_SgAsmLEEntryPoint to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEEntryPoint(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmLEEntryPoint_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmLEEntryPoint)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEEntryPoint::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEEntryTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1363
/** Converts an enum of type E_SgAsmLEEntryTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEEntryTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmLEEntryTable_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmLEEntryTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEEntryTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1285
/** Converts an enum of type E_SgAsmLEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEFileHeader(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmLEFileHeader_exec_format"; break;
        case 1l: retval = "SgAsmLEFileHeader_dlls"; break;
        case 2l: retval = "SgAsmLEFileHeader_sections"; break;
        case 3l: retval = "SgAsmLEFileHeader_dos2_header"; break;
        case 4l: retval = "SgAsmLEFileHeader_page_table"; break;
        case 5l: retval = "SgAsmLEFileHeader_resname_table"; break;
        case 6l: retval = "SgAsmLEFileHeader_nonresname_table"; break;
        case 7l: retval = "SgAsmLEFileHeader_entry_table"; break;
        case 8l: retval = "SgAsmLEFileHeader_reloc_table"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmLEFileHeader)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEPageTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1360
/** Converts an enum of type E_SgAsmLEPageTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEPageTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmLEPageTable_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmLEPageTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEPageTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLERelocTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1366
/** Converts an enum of type E_SgAsmLERelocTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLERelocTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmLERelocTable_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmLERelocTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLERelocTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1357
/** Converts an enum of type E_SgAsmLESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLESection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmLESection_st_entry"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmLESection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmM68kInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1180
/** Converts an enum of type E_SgAsmM68kInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmM68kInstruction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmM68kInstruction_operandList"; break;
        case 1l: retval = "SgAsmM68kInstruction_semantics"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmM68kInstruction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmM68kInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmMemoryReferenceExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1255
/** Converts an enum of type E_SgAsmMemoryReferenceExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmMemoryReferenceExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmMemoryReferenceExpression_address"; break;
        case 1l: retval = "SgAsmMemoryReferenceExpression_segment"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmMemoryReferenceExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmMemoryReferenceExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmMipsInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1177
/** Converts an enum of type E_SgAsmMipsInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmMipsInstruction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmMipsInstruction_operandList"; break;
        case 1l: retval = "SgAsmMipsInstruction_semantics"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmMipsInstruction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmMipsInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNEEntryTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1351
/** Converts an enum of type E_SgAsmNEEntryTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEEntryTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmNEEntryTable_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmNEEntryTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEEntryTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1288
/** Converts an enum of type E_SgAsmNEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEFileHeader(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmNEFileHeader_exec_format"; break;
        case 1l: retval = "SgAsmNEFileHeader_dlls"; break;
        case 2l: retval = "SgAsmNEFileHeader_sections"; break;
        case 3l: retval = "SgAsmNEFileHeader_dos2_header"; break;
        case 4l: retval = "SgAsmNEFileHeader_resname_table"; break;
        case 5l: retval = "SgAsmNEFileHeader_nonresname_table"; break;
        case 6l: retval = "SgAsmNEFileHeader_module_table"; break;
        case 7l: retval = "SgAsmNEFileHeader_entry_table"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmNEFileHeader)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNEModuleTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1348
/** Converts an enum of type E_SgAsmNEModuleTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEModuleTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmNEModuleTable_strtab"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmNEModuleTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEModuleTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNERelocTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1354
/** Converts an enum of type E_SgAsmNERelocTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNERelocTable(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmNERelocTable_entries"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmNERelocTable)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNERelocTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1345
/** Converts an enum of type E_SgAsmNESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNESection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmNESection_st_entry"; break;
        case 1l: retval = "SgAsmNESection_reloc_table"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmNESection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1039
/** Converts an enum of type E_SgAsmOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmOp_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmOperandList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1273
/** Converts an enum of type E_SgAsmOperandList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmOperandList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmOperandList_operands"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmOperandList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmOperandList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1435
/** Converts an enum of type E_SgAsmPEExportDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportDirectory(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEExportDirectory_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEExportDirectory)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1390
/** Converts an enum of type E_SgAsmPEExportEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportEntry(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEExportEntry_name"; break;
        case 1l: retval = "SgAsmPEExportEntry_forwarder"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEExportEntry)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1393
/** Converts an enum of type E_SgAsmPEExportEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportEntryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEExportEntryList_exports"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEExportEntryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1333
/** Converts an enum of type E_SgAsmPEExportSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEExportSection_section_entry"; break;
        case 1l: retval = "SgAsmPEExportSection_export_dir"; break;
        case 2l: retval = "SgAsmPEExportSection_exports"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEExportSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1282
/** Converts an enum of type E_SgAsmPEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEFileHeader(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEFileHeader_exec_format"; break;
        case 1l: retval = "SgAsmPEFileHeader_dlls"; break;
        case 2l: retval = "SgAsmPEFileHeader_sections"; break;
        case 3l: retval = "SgAsmPEFileHeader_rvasize_pairs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEFileHeader)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1432
/** Converts an enum of type E_SgAsmPEImportDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportDirectory(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEImportDirectory_dll_name"; break;
        case 1l: retval = "SgAsmPEImportDirectory_imports"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEImportDirectory)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportDirectoryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1447
/** Converts an enum of type E_SgAsmPEImportDirectoryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportDirectoryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEImportDirectoryList_vector"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEImportDirectoryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportDirectoryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportItem is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1501
/** Converts an enum of type E_SgAsmPEImportItem to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportItem(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEImportItem_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEImportItem)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportItem::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportItemList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1504
/** Converts an enum of type E_SgAsmPEImportItemList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportItemList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEImportItemList_vector"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEImportItemList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportItemList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1330
/** Converts an enum of type E_SgAsmPEImportSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEImportSection_section_entry"; break;
        case 1l: retval = "SgAsmPEImportSection_import_directories"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEImportSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPERVASizePairList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1441
/** Converts an enum of type E_SgAsmPERVASizePairList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPERVASizePairList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPERVASizePairList_pairs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPERVASizePairList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPERVASizePairList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1339
/** Converts an enum of type E_SgAsmPESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPESection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPESection_section_entry"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPESection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEStringSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1336
/** Converts an enum of type E_SgAsmPEStringSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEStringSection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPEStringSection_section_entry"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPEStringSection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEStringSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPowerpcInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1174
/** Converts an enum of type E_SgAsmPowerpcInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPowerpcInstruction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmPowerpcInstruction_operandList"; break;
        case 1l: retval = "SgAsmPowerpcInstruction_semantics"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmPowerpcInstruction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPowerpcInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmRegisterNames is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1264
/** Converts an enum of type E_SgAsmRegisterNames to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmRegisterNames(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmRegisterNames_registers"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmRegisterNames)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmRegisterNames::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmRiscOperation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1267
/** Converts an enum of type E_SgAsmRiscOperation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmRiscOperation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmRiscOperation_operands"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmRiscOperation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmRiscOperation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:445
/** Converts an enum of type E_SgAsmStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmStmt_operands"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryArmSpecialRegisterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1249
/** Converts an enum of type E_SgAsmUnaryArmSpecialRegisterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryArmSpecialRegisterList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmUnaryArmSpecialRegisterList_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmUnaryArmSpecialRegisterList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryArmSpecialRegisterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1252
/** Converts an enum of type E_SgAsmUnaryExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmUnaryExpression_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmUnaryExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryMinus is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1243
/** Converts an enum of type E_SgAsmUnaryMinus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryMinus(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmUnaryMinus_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmUnaryMinus)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryMinus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryPlus is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1240
/** Converts an enum of type E_SgAsmUnaryPlus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryPlus(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmUnaryPlus_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmUnaryPlus)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryPlus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryRrx is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1246
/** Converts an enum of type E_SgAsmUnaryRrx to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryRrx(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmUnaryRrx_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmUnaryRrx)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryRrx::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1195
/** Converts an enum of type E_SgAsmValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmValueExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmValueExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmX86Instruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1168
/** Converts an enum of type E_SgAsmX86Instruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmX86Instruction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsmX86Instruction_operandList"; break;
        case 1l: retval = "SgAsmX86Instruction_semantics"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsmX86Instruction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmX86Instruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssertStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:694
/** Converts an enum of type E_SgAssertStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssertStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAssertStmt_test"; break;
        case 1l: retval = "SgAssertStmt_exception_argument"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAssertStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssertStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1006
/** Converts an enum of type E_SgAssignInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignInitializer(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAssignInitializer_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAssignInitializer)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:844
/** Converts an enum of type E_SgAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:610
/** Converts an enum of type E_SgAssignStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAssignStatement_value"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAssignStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignedGotoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:616
/** Converts an enum of type E_SgAssignedGotoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignedGotoStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAssignedGotoStatement_targets"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAssignedGotoStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignedGotoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssociateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:403
/** Converts an enum of type E_SgAssociateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssociateStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAssociateStatement_variable_declaration"; break;
        case 1l: retval = "SgAssociateStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAssociateStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssociateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsyncStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:706
/** Converts an enum of type E_SgAsyncStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsyncStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAsyncStmt_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAsyncStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsyncStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAtStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:712
/** Converts an enum of type E_SgAtStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAtStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgAtStmt_expression"; break;
        case 1l: retval = "SgAtStmt_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgAtStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAtStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBackspaceStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:583
/** Converts an enum of type E_SgBackspaceStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBackspaceStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBackspaceStatement_io_stmt_list"; break;
        case 1l: retval = "SgBackspaceStatement_unit"; break;
        case 2l: retval = "SgBackspaceStatement_iostat"; break;
        case 3l: retval = "SgBackspaceStatement_err"; break;
        case 4l: retval = "SgBackspaceStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBackspaceStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBackspaceStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBaseClass is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:19
/** Converts an enum of type E_SgBaseClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBaseClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBaseClass_base_class"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBaseClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBaseClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBasicBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:364
/** Converts an enum of type E_SgBasicBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBasicBlock(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBasicBlock_statements"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBasicBlock)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBasicBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBinaryComposite is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:7
/** Converts an enum of type E_SgBinaryComposite to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBinaryComposite(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBinaryComposite_genericFileList"; break;
        case 1l: retval = "SgBinaryComposite_interpretations"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBinaryComposite)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBinaryComposite::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBinaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:943
/** Converts an enum of type E_SgBinaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBinaryOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBinaryOp_lhs_operand_i"; break;
        case 1l: retval = "SgBinaryOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBinaryOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBinaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitAndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:823
/** Converts an enum of type E_SgBitAndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitAndOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBitAndOp_lhs_operand_i"; break;
        case 1l: retval = "SgBitAndOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBitAndOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitAndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitComplementOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:739
/** Converts an enum of type E_SgBitComplementOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitComplementOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBitComplementOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBitComplementOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitComplementOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitOrOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:826
/** Converts an enum of type E_SgBitOrOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitOrOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBitOrOp_lhs_operand_i"; break;
        case 1l: retval = "SgBitOrOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBitOrOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitOrOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitXorOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:820
/** Converts an enum of type E_SgBitXorOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitXorOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgBitXorOp_lhs_operand_i"; break;
        case 1l: retval = "SgBitXorOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgBitXorOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitXorOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCAFCoExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1048
/** Converts an enum of type E_SgCAFCoExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCAFCoExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCAFCoExpression_referData"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCAFCoExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCAFCoExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCAFWithTeamStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:418
/** Converts an enum of type E_SgCAFWithTeamStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCAFWithTeamStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCAFWithTeamStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCAFWithTeamStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCAFWithTeamStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCallExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:967
/** Converts an enum of type E_SgCallExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCallExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCallExpression_function"; break;
        case 1l: retval = "SgCallExpression_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCallExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCallExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCaseOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:541
/** Converts an enum of type E_SgCaseOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCaseOptionStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCaseOptionStmt_key"; break;
        case 1l: retval = "SgCaseOptionStmt_body"; break;
        case 2l: retval = "SgCaseOptionStmt_key_range_end"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCaseOptionStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCaseOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCastExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:742
/** Converts an enum of type E_SgCastExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCastExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCastExp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCastExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCastExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCatchOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:397
/** Converts an enum of type E_SgCatchOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCatchOptionStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCatchOptionStmt_condition"; break;
        case 1l: retval = "SgCatchOptionStmt_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCatchOptionStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCatchOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCatchStatementSeq is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:559
/** Converts an enum of type E_SgCatchStatementSeq to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCatchStatementSeq(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCatchStatementSeq_catch_statement_seq"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCatchStatementSeq)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCatchStatementSeq::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:496
/** Converts an enum of type E_SgClassDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgClassDeclaration_definition"; break;
        case 1l: retval = "SgClassDeclaration_decoratorList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgClassDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:385
/** Converts an enum of type E_SgClassDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassDefinition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgClassDefinition_members"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgClassDefinition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1132
/** Converts an enum of type E_SgClassSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgClassSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgClassSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:139
/** Converts an enum of type E_SgClassType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgClassType_type_kind"; break;
        case 1l: retval = "SgClassType_builtin_type"; break;
        case 2l: retval = "SgClassType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgClassType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCloseStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:574
/** Converts an enum of type E_SgCloseStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCloseStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCloseStatement_io_stmt_list"; break;
        case 1l: retval = "SgCloseStatement_unit"; break;
        case 2l: retval = "SgCloseStatement_iostat"; break;
        case 3l: retval = "SgCloseStatement_err"; break;
        case 4l: retval = "SgCloseStatement_iomsg"; break;
        case 5l: retval = "SgCloseStatement_status"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCloseStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCloseStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCommaOpExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:829
/** Converts an enum of type E_SgCommaOpExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommaOpExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCommaOpExp_lhs_operand_i"; break;
        case 1l: retval = "SgCommaOpExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCommaOpExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommaOpExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCommonBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:460
/** Converts an enum of type E_SgCommonBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommonBlock(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCommonBlock_block_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCommonBlock)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommonBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCommonBlockObject is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:229
/** Converts an enum of type E_SgCommonBlockObject to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommonBlockObject(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCommonBlockObject_variable_reference_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCommonBlockObject)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommonBlockObject::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgComplexVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:958
/** Converts an enum of type E_SgComplexVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComplexVal(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgComplexVal_real_value"; break;
        case 1l: retval = "SgComplexVal_imaginary_value"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgComplexVal)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComplexVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCompoundAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:901
/** Converts an enum of type E_SgCompoundAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCompoundAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCompoundAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgCompoundAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCompoundAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCompoundAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCompoundInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1000
/** Converts an enum of type E_SgCompoundInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCompoundInitializer(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCompoundInitializer_initializers"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCompoundInitializer)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCompoundInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1063
/** Converts an enum of type E_SgComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComprehension(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgComprehension_target"; break;
        case 1l: retval = "SgComprehension_iter"; break;
        case 2l: retval = "SgComprehension_filters"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgComprehension)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgComputedGotoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:613
/** Converts an enum of type E_SgComputedGotoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComputedGotoStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgComputedGotoStatement_labelList"; break;
        case 1l: retval = "SgComputedGotoStatement_label_index"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgComputedGotoStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComputedGotoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConcatenationOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:853
/** Converts an enum of type E_SgConcatenationOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConcatenationOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgConcatenationOp_lhs_operand_i"; break;
        case 1l: retval = "SgConcatenationOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgConcatenationOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConcatenationOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConditionalExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:988
/** Converts an enum of type E_SgConditionalExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConditionalExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgConditionalExp_conditional_exp"; break;
        case 1l: retval = "SgConditionalExp_true_exp"; break;
        case 2l: retval = "SgConditionalExp_false_exp"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgConditionalExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConditionalExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConjugateOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:754
/** Converts an enum of type E_SgConjugateOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConjugateOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgConjugateOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgConjugateOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConjugateOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConstructorInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1003
/** Converts an enum of type E_SgConstructorInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConstructorInitializer(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgConstructorInitializer_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgConstructorInitializer)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConstructorInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCtorInitializerList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:475
/** Converts an enum of type E_SgCtorInitializerList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCtorInitializerList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCtorInitializerList_ctors"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCtorInitializerList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCtorInitializerList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCudaKernelCallExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:961
/** Converts an enum of type E_SgCudaKernelCallExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCudaKernelCallExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCudaKernelCallExp_function"; break;
        case 1l: retval = "SgCudaKernelCallExp_args"; break;
        case 2l: retval = "SgCudaKernelCallExp_exec_config"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCudaKernelCallExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCudaKernelCallExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCudaKernelExecConfig is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1051
/** Converts an enum of type E_SgCudaKernelExecConfig to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCudaKernelExecConfig(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgCudaKernelExecConfig_grid"; break;
        case 1l: retval = "SgCudaKernelExecConfig_blocks"; break;
        case 2l: retval = "SgCudaKernelExecConfig_shared"; break;
        case 3l: retval = "SgCudaKernelExecConfig_stream"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgCudaKernelExecConfig)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCudaKernelExecConfig::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDeallocateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:622
/** Converts an enum of type E_SgDeallocateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeallocateStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDeallocateStatement_expr_list"; break;
        case 1l: retval = "SgDeallocateStatement_stat_expression"; break;
        case 2l: retval = "SgDeallocateStatement_errmsg_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDeallocateStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeallocateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDeclType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:214
/** Converts an enum of type E_SgDeclType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeclType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDeclType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDeclType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeclType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDefaultOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:547
/** Converts an enum of type E_SgDefaultOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDefaultOptionStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDefaultOptionStmt_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDefaultOptionStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDefaultOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDeleteExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:994
/** Converts an enum of type E_SgDeleteExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeleteExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDeleteExp_variable"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDeleteExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeleteExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDerivedTypeStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:487
/** Converts an enum of type E_SgDerivedTypeStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDerivedTypeStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDerivedTypeStatement_definition"; break;
        case 1l: retval = "SgDerivedTypeStatement_decoratorList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDerivedTypeStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDerivedTypeStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDesignatedInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1009
/** Converts an enum of type E_SgDesignatedInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDesignatedInitializer(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDesignatedInitializer_designatorList"; break;
        case 1l: retval = "SgDesignatedInitializer_memberInit"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDesignatedInitializer)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDesignatedInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDictionaryComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1072
/** Converts an enum of type E_SgDictionaryComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDictionaryComprehension(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDictionaryComprehension_element"; break;
        case 1l: retval = "SgDictionaryComprehension_generators"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDictionaryComprehension)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDictionaryComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDictionaryExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1057
/** Converts an enum of type E_SgDictionaryExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDictionaryExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDictionaryExp_key_datum_pairs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDictionaryExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDictionaryExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:28
/** Converts an enum of type E_SgDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDirectory(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDirectory_fileList"; break;
        case 1l: retval = "SgDirectory_directoryList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDirectory)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDirectoryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:34
/** Converts an enum of type E_SgDirectoryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDirectoryList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDirectoryList_listOfDirectories"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDirectoryList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDirectoryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDivAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:877
/** Converts an enum of type E_SgDivAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDivAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDivAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgDivAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDivAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDivAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:805
/** Converts an enum of type E_SgDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDivideOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDivideOp_lhs_operand_i"; break;
        case 1l: retval = "SgDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDivideOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDoWhileStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:391
/** Converts an enum of type E_SgDoWhileStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDoWhileStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDoWhileStmt_body"; break;
        case 1l: retval = "SgDoWhileStmt_condition"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDoWhileStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDoWhileStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDotExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:769
/** Converts an enum of type E_SgDotExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDotExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDotExp_lhs_operand_i"; break;
        case 1l: retval = "SgDotExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDotExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDotExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDotStarOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:772
/** Converts an enum of type E_SgDotStarOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDotStarOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgDotStarOp_lhs_operand_i"; break;
        case 1l: retval = "SgDotStarOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgDotStarOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDotStarOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:928
/** Converts an enum of type E_SgElementwiseAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseAddOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwiseAddOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwiseAddOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwiseAddOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:925
/** Converts an enum of type E_SgElementwiseDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseDivideOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwiseDivideOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwiseDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwiseDivideOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseLeftDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:922
/** Converts an enum of type E_SgElementwiseLeftDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseLeftDivideOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwiseLeftDivideOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwiseLeftDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwiseLeftDivideOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseLeftDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseMultiplyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:916
/** Converts an enum of type E_SgElementwiseMultiplyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseMultiplyOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwiseMultiplyOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwiseMultiplyOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwiseMultiplyOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseMultiplyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:934
/** Converts an enum of type E_SgElementwiseOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwiseOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwiseOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwiseOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwisePowerOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:919
/** Converts an enum of type E_SgElementwisePowerOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwisePowerOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwisePowerOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwisePowerOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwisePowerOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwisePowerOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseSubtractOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:931
/** Converts an enum of type E_SgElementwiseSubtractOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseSubtractOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElementwiseSubtractOp_lhs_operand_i"; break;
        case 1l: retval = "SgElementwiseSubtractOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElementwiseSubtractOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseSubtractOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElseWhereStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:601
/** Converts an enum of type E_SgElseWhereStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElseWhereStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgElseWhereStatement_condition"; break;
        case 1l: retval = "SgElseWhereStatement_body"; break;
        case 2l: retval = "SgElseWhereStatement_elsewhere"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgElseWhereStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElseWhereStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEndfileStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:589
/** Converts an enum of type E_SgEndfileStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEndfileStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgEndfileStatement_io_stmt_list"; break;
        case 1l: retval = "SgEndfileStatement_unit"; break;
        case 2l: retval = "SgEndfileStatement_iostat"; break;
        case 3l: retval = "SgEndfileStatement_err"; break;
        case 4l: retval = "SgEndfileStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgEndfileStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEndfileStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEntryStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:523
/** Converts an enum of type E_SgEntryStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEntryStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgEntryStatement_parameterList"; break;
        case 1l: retval = "SgEntryStatement_decoratorList"; break;
        case 2l: retval = "SgEntryStatement_definition"; break;
        case 3l: retval = "SgEntryStatement_result_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgEntryStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEntryStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEnumDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:442
/** Converts an enum of type E_SgEnumDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgEnumDeclaration_enumerators"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgEnumDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEnumSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1138
/** Converts an enum of type E_SgEnumSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgEnumSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgEnumSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEnumType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:148
/** Converts an enum of type E_SgEnumType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgEnumType_type_kind"; break;
        case 1l: retval = "SgEnumType_builtin_type"; break;
        case 2l: retval = "SgEnumType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgEnumType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEqualityOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:778
/** Converts an enum of type E_SgEqualityOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEqualityOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgEqualityOp_lhs_operand_i"; break;
        case 1l: retval = "SgEqualityOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgEqualityOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEqualityOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExecStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:697
/** Converts an enum of type E_SgExecStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExecStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExecStatement_executable"; break;
        case 1l: retval = "SgExecStatement_globals"; break;
        case 2l: retval = "SgExecStatement_locals"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExecStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExecStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExpBaseClass is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:16
/** Converts an enum of type E_SgExpBaseClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExpBaseClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExpBaseClass_base_class"; break;
        case 1l: retval = "SgExpBaseClass_base_class_exp"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExpBaseClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExpBaseClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExponentiationAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:898
/** Converts an enum of type E_SgExponentiationAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExponentiationAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExponentiationAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgExponentiationAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExponentiationAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExponentiationAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExponentiationOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:847
/** Converts an enum of type E_SgExponentiationOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExponentiationOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExponentiationOp_lhs_operand_i"; break;
        case 1l: retval = "SgExponentiationOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExponentiationOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExponentiationOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExprListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:955
/** Converts an enum of type E_SgExprListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExprListExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExprListExp_expressions"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExprListExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExprListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExprStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:538
/** Converts an enum of type E_SgExprStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExprStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExprStatement_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExprStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExprStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExpressionRoot is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:715
/** Converts an enum of type E_SgExpressionRoot to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExpressionRoot(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgExpressionRoot_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgExpressionRoot)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExpressionRoot::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFileList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:31
/** Converts an enum of type E_SgFileList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFileList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFileList_listOfFiles"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFileList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFileList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFinishStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:709
/** Converts an enum of type E_SgFinishStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFinishStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFinishStmt_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFinishStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFinishStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFlushStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:580
/** Converts an enum of type E_SgFlushStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFlushStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFlushStatement_io_stmt_list"; break;
        case 1l: retval = "SgFlushStatement_unit"; break;
        case 2l: retval = "SgFlushStatement_iostat"; break;
        case 3l: retval = "SgFlushStatement_err"; break;
        case 4l: retval = "SgFlushStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFlushStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFlushStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgForAllStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:412
/** Converts an enum of type E_SgForAllStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForAllStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgForAllStatement_forall_header"; break;
        case 1l: retval = "SgForAllStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgForAllStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForAllStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgForInitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:556
/** Converts an enum of type E_SgForInitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForInitStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgForInitStatement_init_stmt"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgForInitStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForInitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:370
/** Converts an enum of type E_SgForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgForStatement_for_init_stmt"; break;
        case 1l: retval = "SgForStatement_test"; break;
        case 2l: retval = "SgForStatement_increment"; break;
        case 3l: retval = "SgForStatement_loop_body"; break;
        case 4l: retval = "SgForStatement_else_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgForStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFortranDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:409
/** Converts an enum of type E_SgFortranDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFortranDo(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFortranDo_initialization"; break;
        case 1l: retval = "SgFortranDo_bound"; break;
        case 2l: retval = "SgFortranDo_increment"; break;
        case 3l: retval = "SgFortranDo_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFortranDo)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFortranDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFortranNonblockedDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:406
/** Converts an enum of type E_SgFortranNonblockedDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFortranNonblockedDo(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFortranNonblockedDo_initialization"; break;
        case 1l: retval = "SgFortranNonblockedDo_bound"; break;
        case 2l: retval = "SgFortranNonblockedDo_increment"; break;
        case 3l: retval = "SgFortranNonblockedDo_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFortranNonblockedDo)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFortranNonblockedDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionCallExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:964
/** Converts an enum of type E_SgFunctionCallExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionCallExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionCallExp_function"; break;
        case 1l: retval = "SgFunctionCallExp_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionCallExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionCallExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:526
/** Converts an enum of type E_SgFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionDeclaration_parameterList"; break;
        case 1l: retval = "SgFunctionDeclaration_decoratorList"; break;
        case 2l: retval = "SgFunctionDeclaration_definition"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:376
/** Converts an enum of type E_SgFunctionDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionDefinition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionDefinition_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionDefinition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionParameterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:430
/** Converts an enum of type E_SgFunctionParameterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionParameterList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionParameterList_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionParameterList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionParameterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionParameterRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1102
/** Converts an enum of type E_SgFunctionParameterRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionParameterRefExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionParameterRefExp_parameter_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionParameterRefExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionParameterRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1126
/** Converts an enum of type E_SgFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:172
/** Converts an enum of type E_SgFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgFunctionType_type_kind"; break;
        case 1l: retval = "SgFunctionType_return_type"; break;
        case 2l: retval = "SgFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgFunctionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgGlobal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:361
/** Converts an enum of type E_SgGlobal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGlobal(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgGlobal_declarations"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgGlobal)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGlobal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgGreaterOrEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:793
/** Converts an enum of type E_SgGreaterOrEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGreaterOrEqualOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgGreaterOrEqualOp_lhs_operand_i"; break;
        case 1l: retval = "SgGreaterOrEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgGreaterOrEqualOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGreaterOrEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgGreaterThanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:784
/** Converts an enum of type E_SgGreaterThanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGreaterThanOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgGreaterThanOp_lhs_operand_i"; break;
        case 1l: retval = "SgGreaterThanOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgGreaterThanOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGreaterThanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgHereExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1108
/** Converts an enum of type E_SgHereExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgHereExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgHereExp_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgHereExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgHereExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIOItemExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1033
/** Converts an enum of type E_SgIOItemExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIOItemExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIOItemExpression_io_item"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIOItemExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIOItemExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIOStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:595
/** Converts an enum of type E_SgIOStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIOStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIOStatement_io_stmt_list"; break;
        case 1l: retval = "SgIOStatement_unit"; break;
        case 2l: retval = "SgIOStatement_iostat"; break;
        case 3l: retval = "SgIOStatement_err"; break;
        case 4l: retval = "SgIOStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIOStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIOStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIfStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:367
/** Converts an enum of type E_SgIfStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIfStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIfStmt_conditional"; break;
        case 1l: retval = "SgIfStmt_true_body"; break;
        case 2l: retval = "SgIfStmt_false_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIfStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIfStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgImagPartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:751
/** Converts an enum of type E_SgImagPartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImagPartOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgImagPartOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgImagPartOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImagPartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgImplicitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:499
/** Converts an enum of type E_SgImplicitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImplicitStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgImplicitStatement_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgImplicitStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImplicitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgImpliedDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1030
/** Converts an enum of type E_SgImpliedDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImpliedDo(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgImpliedDo_do_var_initialization"; break;
        case 1l: retval = "SgImpliedDo_last_val"; break;
        case 2l: retval = "SgImpliedDo_increment"; break;
        case 3l: retval = "SgImpliedDo_object_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgImpliedDo)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImpliedDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIncludeDirectiveStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:529
/** Converts an enum of type E_SgIncludeDirectiveStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIncludeDirectiveStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIncludeDirectiveStatement_headerFileBody"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIncludeDirectiveStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIncludeDirectiveStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgInitializedName is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:232
/** Converts an enum of type E_SgInitializedName to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInitializedName(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgInitializedName_initptr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgInitializedName)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInitializedName::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgInquireStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:577
/** Converts an enum of type E_SgInquireStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInquireStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgInquireStatement_io_stmt_list"; break;
        case 1l: retval = "SgInquireStatement_unit"; break;
        case 2l: retval = "SgInquireStatement_iostat"; break;
        case 3l: retval = "SgInquireStatement_err"; break;
        case 4l: retval = "SgInquireStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgInquireStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInquireStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIntegerDivideAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:895
/** Converts an enum of type E_SgIntegerDivideAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIntegerDivideAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIntegerDivideAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgIntegerDivideAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIntegerDivideAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIntegerDivideAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIntegerDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:808
/** Converts an enum of type E_SgIntegerDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIntegerDivideOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIntegerDivideOp_lhs_operand_i"; break;
        case 1l: retval = "SgIntegerDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIntegerDivideOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIntegerDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgInterfaceStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:457
/** Converts an enum of type E_SgInterfaceStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInterfaceStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgInterfaceStatement_interface_body_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgInterfaceStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInterfaceStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIorAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:871
/** Converts an enum of type E_SgIorAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIorAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIorAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgIorAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIorAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIorAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIsNotOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:913
/** Converts an enum of type E_SgIsNotOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIsNotOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIsNotOp_lhs_operand_i"; break;
        case 1l: retval = "SgIsNotOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIsNotOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIsNotOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIsOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:910
/** Converts an enum of type E_SgIsOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIsOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgIsOp_lhs_operand_i"; break;
        case 1l: retval = "SgIsOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgIsOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIsOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaClassDeclarationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:46
/** Converts an enum of type E_SgJavaClassDeclarationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaClassDeclarationList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaClassDeclarationList_java_class_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaClassDeclarationList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaClassDeclarationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaForEachStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:421
/** Converts an enum of type E_SgJavaForEachStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaForEachStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaForEachStatement_element"; break;
        case 1l: retval = "SgJavaForEachStatement_collection"; break;
        case 2l: retval = "SgJavaForEachStatement_loop_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaForEachStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaForEachStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaImportStatementList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:43
/** Converts an enum of type E_SgJavaImportStatementList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaImportStatementList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaImportStatementList_java_import_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaImportStatementList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaImportStatementList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaInstanceOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:982
/** Converts an enum of type E_SgJavaInstanceOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaInstanceOfOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaInstanceOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaInstanceOfOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaInstanceOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaLabelStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:424
/** Converts an enum of type E_SgJavaLabelStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaLabelStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaLabelStatement_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaLabelStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaLabelStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaLabelSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1159
/** Converts an enum of type E_SgJavaLabelSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaLabelSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaLabelSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaLabelSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaLabelSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaMemberValuePair is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:235
/** Converts an enum of type E_SgJavaMemberValuePair to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaMemberValuePair(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaMemberValuePair_value"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaMemberValuePair)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaMemberValuePair::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaNormalAnnotation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1099
/** Converts an enum of type E_SgJavaNormalAnnotation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaNormalAnnotation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaNormalAnnotation_value_pair_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaNormalAnnotation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaNormalAnnotation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaPackageDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:493
/** Converts an enum of type E_SgJavaPackageDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaPackageDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaPackageDeclaration_definition"; break;
        case 1l: retval = "SgJavaPackageDeclaration_decoratorList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaPackageDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaPackageDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaParameterType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:136
/** Converts an enum of type E_SgJavaParameterType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaParameterType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaParameterType_type_kind"; break;
        case 1l: retval = "SgJavaParameterType_builtin_type"; break;
        case 2l: retval = "SgJavaParameterType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaParameterType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaParameterType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaParameterizedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:142
/** Converts an enum of type E_SgJavaParameterizedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaParameterizedType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaParameterizedType_type_kind"; break;
        case 1l: retval = "SgJavaParameterizedType_builtin_type"; break;
        case 2l: retval = "SgJavaParameterizedType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaParameterizedType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaParameterizedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaQualifiedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:145
/** Converts an enum of type E_SgJavaQualifiedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaQualifiedType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaQualifiedType_type_kind"; break;
        case 1l: retval = "SgJavaQualifiedType_builtin_type"; break;
        case 2l: retval = "SgJavaQualifiedType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaQualifiedType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaQualifiedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaSingleMemberAnnotation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1096
/** Converts an enum of type E_SgJavaSingleMemberAnnotation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaSingleMemberAnnotation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaSingleMemberAnnotation_value"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaSingleMemberAnnotation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaSingleMemberAnnotation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaSynchronizedStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:703
/** Converts an enum of type E_SgJavaSynchronizedStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaSynchronizedStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaSynchronizedStatement_expression"; break;
        case 1l: retval = "SgJavaSynchronizedStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaSynchronizedStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaSynchronizedStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaUnionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:205
/** Converts an enum of type E_SgJavaUnionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaUnionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaUnionType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaUnionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaUnionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaUnsignedRshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:892
/** Converts an enum of type E_SgJavaUnsignedRshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaUnsignedRshiftAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaUnsignedRshiftAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgJavaUnsignedRshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaUnsignedRshiftAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaUnsignedRshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaUnsignedRshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:850
/** Converts an enum of type E_SgJavaUnsignedRshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaUnsignedRshiftOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaUnsignedRshiftOp_lhs_operand_i"; break;
        case 1l: retval = "SgJavaUnsignedRshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaUnsignedRshiftOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaUnsignedRshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaWildcardType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:154
/** Converts an enum of type E_SgJavaWildcardType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaWildcardType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgJavaWildcardType_type_kind"; break;
        case 1l: retval = "SgJavaWildcardType_builtin_type"; break;
        case 2l: retval = "SgJavaWildcardType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgJavaWildcardType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaWildcardType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgKeyDatumPair is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1060
/** Converts an enum of type E_SgKeyDatumPair to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgKeyDatumPair(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgKeyDatumPair_key"; break;
        case 1l: retval = "SgKeyDatumPair_datum"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgKeyDatumPair)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgKeyDatumPair::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLabelSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1147
/** Converts an enum of type E_SgLabelSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLabelSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLabelSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLabelSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLabelSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaCapture is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:355
/** Converts an enum of type E_SgLambdaCapture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaCapture(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLambdaCapture_capture_variable"; break;
        case 1l: retval = "SgLambdaCapture_source_closure_variable"; break;
        case 2l: retval = "SgLambdaCapture_closure_variable"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLambdaCapture)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaCapture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaCaptureList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:358
/** Converts an enum of type E_SgLambdaCaptureList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaCaptureList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLambdaCaptureList_capture_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLambdaCaptureList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaCaptureList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1105
/** Converts an enum of type E_SgLambdaExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLambdaExp_lambda_capture_list"; break;
        case 1l: retval = "SgLambdaExp_lambda_function"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLambdaExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1054
/** Converts an enum of type E_SgLambdaRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaRefExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLambdaRefExp_functionDeclaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLambdaRefExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLeftDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:940
/** Converts an enum of type E_SgLeftDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLeftDivideOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLeftDivideOp_lhs_operand_i"; break;
        case 1l: retval = "SgLeftDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLeftDivideOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLeftDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLessOrEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:790
/** Converts an enum of type E_SgLessOrEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLessOrEqualOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLessOrEqualOp_lhs_operand_i"; break;
        case 1l: retval = "SgLessOrEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLessOrEqualOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLessOrEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLessThanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:781
/** Converts an enum of type E_SgLessThanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLessThanOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLessThanOp_lhs_operand_i"; break;
        case 1l: retval = "SgLessThanOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLessThanOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLessThanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgListComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1066
/** Converts an enum of type E_SgListComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgListComprehension(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgListComprehension_element"; break;
        case 1l: retval = "SgListComprehension_generators"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgListComprehension)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgListComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:946
/** Converts an enum of type E_SgListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgListExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgListExp_expressions"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgListExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:886
/** Converts an enum of type E_SgLshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLshiftAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLshiftAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgLshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLshiftAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:832
/** Converts an enum of type E_SgLshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLshiftOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgLshiftOp_lhs_operand_i"; break;
        case 1l: retval = "SgLshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgLshiftOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMatlabForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:427
/** Converts an enum of type E_SgMatlabForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMatlabForStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMatlabForStatement_index"; break;
        case 1l: retval = "SgMatlabForStatement_range"; break;
        case 2l: retval = "SgMatlabForStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMatlabForStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMatlabForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMatrixExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:952
/** Converts an enum of type E_SgMatrixExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMatrixExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMatrixExp_expressions"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMatrixExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMatrixExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMatrixTransposeOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:760
/** Converts an enum of type E_SgMatrixTransposeOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMatrixTransposeOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMatrixTransposeOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMatrixTransposeOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMatrixTransposeOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMemberFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:511
/** Converts an enum of type E_SgMemberFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMemberFunctionDeclaration_parameterList"; break;
        case 1l: retval = "SgMemberFunctionDeclaration_decoratorList"; break;
        case 2l: retval = "SgMemberFunctionDeclaration_definition"; break;
        case 3l: retval = "SgMemberFunctionDeclaration_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMemberFunctionDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMemberFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1117
/** Converts an enum of type E_SgMemberFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMemberFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMemberFunctionSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMemberFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:169
/** Converts an enum of type E_SgMemberFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMemberFunctionType_type_kind"; break;
        case 1l: retval = "SgMemberFunctionType_return_type"; break;
        case 2l: retval = "SgMemberFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMemberFunctionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMembershipOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:904
/** Converts an enum of type E_SgMembershipOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMembershipOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMembershipOp_lhs_operand_i"; break;
        case 1l: retval = "SgMembershipOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMembershipOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMembershipOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMinusAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:865
/** Converts an enum of type E_SgMinusAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMinusAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgMinusAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMinusAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMinusMinusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:733
/** Converts an enum of type E_SgMinusMinusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusMinusOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMinusMinusOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMinusMinusOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusMinusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMinusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:718
/** Converts an enum of type E_SgMinusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMinusOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMinusOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:880
/** Converts an enum of type E_SgModAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgModAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgModAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgModAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:811
/** Converts an enum of type E_SgModOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgModOp_lhs_operand_i"; break;
        case 1l: retval = "SgModOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgModOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModifierType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:160
/** Converts an enum of type E_SgModifierType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModifierType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgModifierType_type_kind"; break;
        case 1l: retval = "SgModifierType_base_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgModifierType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModifierType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModuleStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:490
/** Converts an enum of type E_SgModuleStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModuleStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgModuleStatement_definition"; break;
        case 1l: retval = "SgModuleStatement_decoratorList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgModuleStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModuleStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModuleSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1153
/** Converts an enum of type E_SgModuleSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModuleSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgModuleSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgModuleSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModuleSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMultAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:874
/** Converts an enum of type E_SgMultAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMultAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMultAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgMultAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMultAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMultAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMultiplyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:802
/** Converts an enum of type E_SgMultiplyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMultiplyOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgMultiplyOp_lhs_operand_i"; break;
        case 1l: retval = "SgMultiplyOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgMultiplyOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMultiplyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:157
/** Converts an enum of type E_SgNamedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamedType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNamedType_type_kind"; break;
        case 1l: retval = "SgNamedType_builtin_type"; break;
        case 2l: retval = "SgNamedType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNamedType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamespaceDeclarationStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:454
/** Converts an enum of type E_SgNamespaceDeclarationStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceDeclarationStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNamespaceDeclarationStatement_definition"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNamespaceDeclarationStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceDeclarationStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamespaceDefinitionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:400
/** Converts an enum of type E_SgNamespaceDefinitionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceDefinitionStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNamespaceDefinitionStatement_declarations"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNamespaceDefinitionStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceDefinitionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamespaceSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1150
/** Converts an enum of type E_SgNamespaceSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNamespaceSymbol_declaration"; break;
        case 1l: retval = "SgNamespaceSymbol_aliasDeclaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNamespaceSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNaryBooleanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1075
/** Converts an enum of type E_SgNaryBooleanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNaryBooleanOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNaryBooleanOp_operands"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNaryBooleanOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNaryBooleanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNaryComparisonOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1078
/** Converts an enum of type E_SgNaryComparisonOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNaryComparisonOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNaryComparisonOp_operands"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNaryComparisonOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNaryComparisonOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1081
/** Converts an enum of type E_SgNaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNaryOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNaryOp_operands"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNaryOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNewExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:991
/** Converts an enum of type E_SgNewExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNewExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNewExp_placement_args"; break;
        case 1l: retval = "SgNewExp_constructor_args"; break;
        case 2l: retval = "SgNewExp_builtin_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNewExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNewExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNoexceptOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1111
/** Converts an enum of type E_SgNoexceptOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNoexceptOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNoexceptOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNoexceptOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNoexceptOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNonMembershipOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:907
/** Converts an enum of type E_SgNonMembershipOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNonMembershipOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNonMembershipOp_lhs_operand_i"; break;
        case 1l: retval = "SgNonMembershipOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNonMembershipOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNonMembershipOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNotEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:787
/** Converts an enum of type E_SgNotEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNotEqualOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNotEqualOp_lhs_operand_i"; break;
        case 1l: retval = "SgNotEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNotEqualOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNotEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNotOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:724
/** Converts an enum of type E_SgNotOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNotOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNotOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNotOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNotOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNullifyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:604
/** Converts an enum of type E_SgNullifyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNullifyStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgNullifyStatement_pointer_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgNullifyStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNullifyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpAlignedClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:286
/** Converts an enum of type E_SgOmpAlignedClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpAlignedClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpAlignedClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpAlignedClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpAlignedClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpAtomicStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:637
/** Converts an enum of type E_SgOmpAtomicStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpAtomicStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpAtomicStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpAtomicStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpAtomicStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpBodyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:685
/** Converts an enum of type E_SgOmpBodyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpBodyStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpBodyStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpBodyStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpBodyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpClauseBodyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:682
/** Converts an enum of type E_SgOmpClauseBodyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpClauseBodyStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpClauseBodyStatement_body"; break;
        case 1l: retval = "SgOmpClauseBodyStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpClauseBodyStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpClauseBodyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCollapseClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:238
/** Converts an enum of type E_SgOmpCollapseClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCollapseClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpCollapseClause_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpCollapseClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCollapseClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCopyinClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:268
/** Converts an enum of type E_SgOmpCopyinClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCopyinClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpCopyinClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpCopyinClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCopyinClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCopyprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:256
/** Converts an enum of type E_SgOmpCopyprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCopyprivateClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpCopyprivateClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpCopyprivateClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCopyprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCriticalStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:646
/** Converts an enum of type E_SgOmpCriticalStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCriticalStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpCriticalStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpCriticalStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCriticalStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpDeviceClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:247
/** Converts an enum of type E_SgOmpDeviceClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpDeviceClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpDeviceClause_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpDeviceClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpDeviceClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpDoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:667
/** Converts an enum of type E_SgOmpDoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpDoStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpDoStatement_body"; break;
        case 1l: retval = "SgOmpDoStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpDoStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpDoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpExpressionClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:253
/** Converts an enum of type E_SgOmpExpressionClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpExpressionClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpExpressionClause_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpExpressionClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpExpressionClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpFirstprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:262
/** Converts an enum of type E_SgOmpFirstprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpFirstprivateClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpFirstprivateClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpFirstprivateClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpFirstprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpFlushStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:634
/** Converts an enum of type E_SgOmpFlushStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpFlushStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpFlushStatement_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpFlushStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpFlushStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:664
/** Converts an enum of type E_SgOmpForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpForStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpForStatement_body"; break;
        case 1l: retval = "SgOmpForStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpForStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpIfClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:241
/** Converts an enum of type E_SgOmpIfClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpIfClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpIfClause_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpIfClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpIfClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpLastprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:271
/** Converts an enum of type E_SgOmpLastprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpLastprivateClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpLastprivateClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpLastprivateClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpLastprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpLinearClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:280
/** Converts an enum of type E_SgOmpLinearClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpLinearClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpLinearClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpLinearClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpLinearClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpMapClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:277
/** Converts an enum of type E_SgOmpMapClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpMapClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpMapClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpMapClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpMapClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpMasterStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:640
/** Converts an enum of type E_SgOmpMasterStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpMasterStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpMasterStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpMasterStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpMasterStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpNumThreadsClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:244
/** Converts an enum of type E_SgOmpNumThreadsClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpNumThreadsClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpNumThreadsClause_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpNumThreadsClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpNumThreadsClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpOrderedStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:643
/** Converts an enum of type E_SgOmpOrderedStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpOrderedStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpOrderedStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpOrderedStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpOrderedStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpParallelStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:655
/** Converts an enum of type E_SgOmpParallelStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpParallelStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpParallelStatement_body"; break;
        case 1l: retval = "SgOmpParallelStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpParallelStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpParallelStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpPrivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:259
/** Converts an enum of type E_SgOmpPrivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpPrivateClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpPrivateClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpPrivateClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpPrivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpReductionClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:274
/** Converts an enum of type E_SgOmpReductionClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpReductionClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpReductionClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpReductionClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpReductionClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSafelenClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:250
/** Converts an enum of type E_SgOmpSafelenClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSafelenClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpSafelenClause_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpSafelenClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSafelenClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpScheduleClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:292
/** Converts an enum of type E_SgOmpScheduleClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpScheduleClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpScheduleClause_chunk_size"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpScheduleClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpScheduleClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSectionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:649
/** Converts an enum of type E_SgOmpSectionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSectionStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpSectionStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpSectionStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSectionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSectionsStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:670
/** Converts an enum of type E_SgOmpSectionsStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSectionsStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpSectionsStatement_body"; break;
        case 1l: retval = "SgOmpSectionsStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpSectionsStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSectionsStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSharedClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:265
/** Converts an enum of type E_SgOmpSharedClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSharedClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpSharedClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpSharedClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSharedClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSimdStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:679
/** Converts an enum of type E_SgOmpSimdStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSimdStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpSimdStatement_body"; break;
        case 1l: retval = "SgOmpSimdStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpSimdStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSimdStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSingleStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:658
/** Converts an enum of type E_SgOmpSingleStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSingleStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpSingleStatement_body"; break;
        case 1l: retval = "SgOmpSingleStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpSingleStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSingleStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpTargetDataStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:676
/** Converts an enum of type E_SgOmpTargetDataStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTargetDataStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpTargetDataStatement_body"; break;
        case 1l: retval = "SgOmpTargetDataStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpTargetDataStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTargetDataStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpTargetStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:673
/** Converts an enum of type E_SgOmpTargetStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTargetStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpTargetStatement_body"; break;
        case 1l: retval = "SgOmpTargetStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpTargetStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTargetStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpTaskStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:661
/** Converts an enum of type E_SgOmpTaskStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTaskStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpTaskStatement_body"; break;
        case 1l: retval = "SgOmpTaskStatement_clauses"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpTaskStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTaskStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpThreadprivateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:532
/** Converts an enum of type E_SgOmpThreadprivateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpThreadprivateStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpThreadprivateStatement_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpThreadprivateStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpThreadprivateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpUniformClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:283
/** Converts an enum of type E_SgOmpUniformClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpUniformClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpUniformClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpUniformClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpUniformClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpVariablesClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:289
/** Converts an enum of type E_SgOmpVariablesClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpVariablesClause(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpVariablesClause_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpVariablesClause)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpVariablesClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpWorkshareStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:652
/** Converts an enum of type E_SgOmpWorkshareStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpWorkshareStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOmpWorkshareStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOmpWorkshareStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpWorkshareStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOpenStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:571
/** Converts an enum of type E_SgOpenStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOpenStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOpenStatement_io_stmt_list"; break;
        case 1l: retval = "SgOpenStatement_unit"; break;
        case 2l: retval = "SgOpenStatement_iostat"; break;
        case 3l: retval = "SgOpenStatement_err"; break;
        case 4l: retval = "SgOpenStatement_iomsg"; break;
        case 5l: retval = "SgOpenStatement_file"; break;
        case 6l: retval = "SgOpenStatement_status"; break;
        case 7l: retval = "SgOpenStatement_access"; break;
        case 8l: retval = "SgOpenStatement_form"; break;
        case 9l: retval = "SgOpenStatement_recl"; break;
        case 10l: retval = "SgOpenStatement_blank"; break;
        case 11l: retval = "SgOpenStatement_position"; break;
        case 12l: retval = "SgOpenStatement_action"; break;
        case 13l: retval = "SgOpenStatement_delim"; break;
        case 14l: retval = "SgOpenStatement_pad"; break;
        case 15l: retval = "SgOpenStatement_round"; break;
        case 16l: retval = "SgOpenStatement_sign"; break;
        case 17l: retval = "SgOpenStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOpenStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOpenStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOrOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:817
/** Converts an enum of type E_SgOrOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOrOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgOrOp_lhs_operand_i"; break;
        case 1l: retval = "SgOrOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgOrOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOrOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPartialFunctionModifierType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:163
/** Converts an enum of type E_SgPartialFunctionModifierType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPartialFunctionModifierType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPartialFunctionModifierType_type_kind"; break;
        case 1l: retval = "SgPartialFunctionModifierType_return_type"; break;
        case 2l: retval = "SgPartialFunctionModifierType_orig_return_type"; break;
        case 3l: retval = "SgPartialFunctionModifierType_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPartialFunctionModifierType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPartialFunctionModifierType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPartialFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:166
/** Converts an enum of type E_SgPartialFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPartialFunctionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPartialFunctionType_type_kind"; break;
        case 1l: retval = "SgPartialFunctionType_return_type"; break;
        case 2l: retval = "SgPartialFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPartialFunctionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPartialFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPlusAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:862
/** Converts an enum of type E_SgPlusAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPlusAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPlusAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgPlusAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPlusAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPlusAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPlusPlusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:736
/** Converts an enum of type E_SgPlusPlusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPlusPlusOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPlusPlusOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPlusPlusOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPlusPlusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPntrArrRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:838
/** Converts an enum of type E_SgPntrArrRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPntrArrRefExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPntrArrRefExp_lhs_operand_i"; break;
        case 1l: retval = "SgPntrArrRefExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPntrArrRefExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPntrArrRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:856
/** Converts an enum of type E_SgPointerAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPointerAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgPointerAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPointerAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerDerefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:727
/** Converts an enum of type E_SgPointerDerefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerDerefExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPointerDerefExp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPointerDerefExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerDerefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerMemberType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:127
/** Converts an enum of type E_SgPointerMemberType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerMemberType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPointerMemberType_type_kind"; break;
        case 1l: retval = "SgPointerMemberType_base_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPointerMemberType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerMemberType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:130
/** Converts an enum of type E_SgPointerType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPointerType_type_kind"; break;
        case 1l: retval = "SgPointerType_base_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPointerType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPowerOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:937
/** Converts an enum of type E_SgPowerOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPowerOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPowerOp_lhs_operand_i"; break;
        case 1l: retval = "SgPowerOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPowerOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPowerOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPragmaDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:478
/** Converts an enum of type E_SgPragmaDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPragmaDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPragmaDeclaration_pragma"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPragmaDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPragmaDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPrintStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:562
/** Converts an enum of type E_SgPrintStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPrintStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPrintStatement_io_stmt_list"; break;
        case 1l: retval = "SgPrintStatement_unit"; break;
        case 2l: retval = "SgPrintStatement_iostat"; break;
        case 3l: retval = "SgPrintStatement_err"; break;
        case 4l: retval = "SgPrintStatement_iomsg"; break;
        case 5l: retval = "SgPrintStatement_format"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPrintStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPrintStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgProcedureHeaderStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:520
/** Converts an enum of type E_SgProcedureHeaderStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProcedureHeaderStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgProcedureHeaderStatement_parameterList"; break;
        case 1l: retval = "SgProcedureHeaderStatement_decoratorList"; break;
        case 2l: retval = "SgProcedureHeaderStatement_definition"; break;
        case 3l: retval = "SgProcedureHeaderStatement_result_name"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgProcedureHeaderStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProcedureHeaderStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgProgramHeaderStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:517
/** Converts an enum of type E_SgProgramHeaderStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProgramHeaderStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgProgramHeaderStatement_parameterList"; break;
        case 1l: retval = "SgProgramHeaderStatement_decoratorList"; break;
        case 2l: retval = "SgProgramHeaderStatement_definition"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgProgramHeaderStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProgramHeaderStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgProject is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:13
/** Converts an enum of type E_SgProject to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProject(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgProject_fileList_ptr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgProject)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProject::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPythonGlobalStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:700
/** Converts an enum of type E_SgPythonGlobalStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPythonGlobalStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPythonGlobalStmt_names"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPythonGlobalStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPythonGlobalStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPythonPrintStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:691
/** Converts an enum of type E_SgPythonPrintStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPythonPrintStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgPythonPrintStmt_destination"; break;
        case 1l: retval = "SgPythonPrintStmt_values"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgPythonPrintStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPythonPrintStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgQualifiedNameType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:184
/** Converts an enum of type E_SgQualifiedNameType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgQualifiedNameType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgQualifiedNameType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgQualifiedNameType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgQualifiedNameType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRangeExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1093
/** Converts an enum of type E_SgRangeExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRangeExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRangeExp_start"; break;
        case 1l: retval = "SgRangeExp_end"; break;
        case 2l: retval = "SgRangeExp_stride"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRangeExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRangeExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgReadStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:565
/** Converts an enum of type E_SgReadStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReadStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgReadStatement_io_stmt_list"; break;
        case 1l: retval = "SgReadStatement_unit"; break;
        case 2l: retval = "SgReadStatement_iostat"; break;
        case 3l: retval = "SgReadStatement_err"; break;
        case 4l: retval = "SgReadStatement_iomsg"; break;
        case 5l: retval = "SgReadStatement_format"; break;
        case 6l: retval = "SgReadStatement_rec"; break;
        case 7l: retval = "SgReadStatement_end"; break;
        case 8l: retval = "SgReadStatement_namelist"; break;
        case 9l: retval = "SgReadStatement_advance"; break;
        case 10l: retval = "SgReadStatement_size"; break;
        case 11l: retval = "SgReadStatement_eor"; break;
        case 12l: retval = "SgReadStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgReadStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReadStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRealPartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:748
/** Converts an enum of type E_SgRealPartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRealPartOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRealPartOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRealPartOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRealPartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgReferenceType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:133
/** Converts an enum of type E_SgReferenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReferenceType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgReferenceType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgReferenceType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReferenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRenameSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1123
/** Converts an enum of type E_SgRenameSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRenameSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRenameSymbol_declaration"; break;
        case 1l: retval = "SgRenameSymbol_original_symbol"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRenameSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRenameSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgReturnStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:550
/** Converts an enum of type E_SgReturnStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReturnStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgReturnStmt_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgReturnStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReturnStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRewindStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:586
/** Converts an enum of type E_SgRewindStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRewindStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRewindStatement_io_stmt_list"; break;
        case 1l: retval = "SgRewindStatement_unit"; break;
        case 2l: retval = "SgRewindStatement_iostat"; break;
        case 3l: retval = "SgRewindStatement_err"; break;
        case 4l: retval = "SgRewindStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRewindStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRewindStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:889
/** Converts an enum of type E_SgRshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRshiftAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRshiftAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgRshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRshiftAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:835
/** Converts an enum of type E_SgRshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRshiftOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRshiftOp_lhs_operand_i"; break;
        case 1l: retval = "SgRshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRshiftOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRvalueReferenceType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:208
/** Converts an enum of type E_SgRvalueReferenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRvalueReferenceType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgRvalueReferenceType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgRvalueReferenceType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRvalueReferenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgScopeOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:841
/** Converts an enum of type E_SgScopeOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgScopeOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgScopeOp_lhs_operand_i"; break;
        case 1l: retval = "SgScopeOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgScopeOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgScopeOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSetComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1069
/** Converts an enum of type E_SgSetComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSetComprehension(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSetComprehension_element"; break;
        case 1l: retval = "SgSetComprehension_generators"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSetComprehension)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSetComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSizeOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:970
/** Converts an enum of type E_SgSizeOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSizeOfOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSizeOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSizeOfOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSizeOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSourceFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:4
/** Converts an enum of type E_SgSourceFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSourceFile(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSourceFile_globalScope"; break;
        case 1l: retval = "SgSourceFile_package"; break;
        case 2l: retval = "SgSourceFile_import_list"; break;
        case 3l: retval = "SgSourceFile_class_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSourceFile)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSourceFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSpawnStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:553
/** Converts an enum of type E_SgSpawnStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSpawnStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSpawnStmt_the_func"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSpawnStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSpawnStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStatementExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1036
/** Converts an enum of type E_SgStatementExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStatementExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgStatementExpression_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgStatementExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStatementExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStatementFunctionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:472
/** Converts an enum of type E_SgStatementFunctionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStatementFunctionStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgStatementFunctionStatement_function"; break;
        case 1l: retval = "SgStatementFunctionStatement_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgStatementFunctionStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStatementFunctionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStmtDeclarationStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:535
/** Converts an enum of type E_SgStmtDeclarationStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStmtDeclarationStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgStmtDeclarationStatement_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgStmtDeclarationStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStmtDeclarationStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStringConversion is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1084
/** Converts an enum of type E_SgStringConversion to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStringConversion(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgStringConversion_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgStringConversion)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStringConversion::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSubscriptExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1027
/** Converts an enum of type E_SgSubscriptExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSubscriptExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSubscriptExpression_lowerBound"; break;
        case 1l: retval = "SgSubscriptExpression_upperBound"; break;
        case 2l: retval = "SgSubscriptExpression_stride"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSubscriptExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSubscriptExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSubtractOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:799
/** Converts an enum of type E_SgSubtractOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSubtractOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSubtractOp_lhs_operand_i"; break;
        case 1l: retval = "SgSubtractOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSubtractOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSubtractOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSwitchStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:394
/** Converts an enum of type E_SgSwitchStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSwitchStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgSwitchStatement_item_selector"; break;
        case 1l: retval = "SgSwitchStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgSwitchStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSwitchStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateArgument is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:25
/** Converts an enum of type E_SgTemplateArgument to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateArgument(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateArgument_expression"; break;
        case 1l: retval = "SgTemplateArgument_templateDeclaration"; break;
        case 2l: retval = "SgTemplateArgument_initializedName"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateArgument)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateArgument::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateArgumentList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:37
/** Converts an enum of type E_SgTemplateArgumentList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateArgumentList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateArgumentList_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateArgumentList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateArgumentList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateClassDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:481
/** Converts an enum of type E_SgTemplateClassDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateClassDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateClassDeclaration_definition"; break;
        case 1l: retval = "SgTemplateClassDeclaration_decoratorList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateClassDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateClassDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateClassDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:382
/** Converts an enum of type E_SgTemplateClassDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateClassDefinition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateClassDefinition_members"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateClassDefinition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateClassDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateClassSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1129
/** Converts an enum of type E_SgTemplateClassSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateClassSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateClassSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateClassSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateClassSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:502
/** Converts an enum of type E_SgTemplateFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateFunctionDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateFunctionDeclaration_parameterList"; break;
        case 1l: retval = "SgTemplateFunctionDeclaration_decoratorList"; break;
        case 2l: retval = "SgTemplateFunctionDeclaration_definition"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateFunctionDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateFunctionDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:373
/** Converts an enum of type E_SgTemplateFunctionDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateFunctionDefinition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateFunctionDefinition_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateFunctionDefinition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateFunctionDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1120
/** Converts an enum of type E_SgTemplateFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateFunctionSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateFunctionSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:484
/** Converts an enum of type E_SgTemplateInstantiationDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDecl(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateInstantiationDecl_definition"; break;
        case 1l: retval = "SgTemplateInstantiationDecl_decoratorList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateInstantiationDecl)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationDefn is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:379
/** Converts an enum of type E_SgTemplateInstantiationDefn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDefn(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateInstantiationDefn_members"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateInstantiationDefn)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDefn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationDirectiveStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:448
/** Converts an enum of type E_SgTemplateInstantiationDirectiveStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDirectiveStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateInstantiationDirectiveStatement_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateInstantiationDirectiveStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationFunctionDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:514
/** Converts an enum of type E_SgTemplateInstantiationFunctionDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationFunctionDecl(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateInstantiationFunctionDecl_parameterList"; break;
        case 1l: retval = "SgTemplateInstantiationFunctionDecl_decoratorList"; break;
        case 2l: retval = "SgTemplateInstantiationFunctionDecl_definition"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateInstantiationFunctionDecl)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationMemberFunctionDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:508
/** Converts an enum of type E_SgTemplateInstantiationMemberFunctionDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationMemberFunctionDecl(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateInstantiationMemberFunctionDecl_parameterList"; break;
        case 1l: retval = "SgTemplateInstantiationMemberFunctionDecl_decoratorList"; break;
        case 2l: retval = "SgTemplateInstantiationMemberFunctionDecl_definition"; break;
        case 3l: retval = "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateInstantiationMemberFunctionDecl)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:466
/** Converts an enum of type E_SgTemplateInstantiationTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationTypedefDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateInstantiationTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateInstantiationTypedefDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateMemberFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:505
/** Converts an enum of type E_SgTemplateMemberFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateMemberFunctionDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateMemberFunctionDeclaration_parameterList"; break;
        case 1l: retval = "SgTemplateMemberFunctionDeclaration_decoratorList"; break;
        case 2l: retval = "SgTemplateMemberFunctionDeclaration_definition"; break;
        case 3l: retval = "SgTemplateMemberFunctionDeclaration_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateMemberFunctionDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateMemberFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateMemberFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1114
/** Converts an enum of type E_SgTemplateMemberFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateMemberFunctionSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateMemberFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateMemberFunctionSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateMemberFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateParameter is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:22
/** Converts an enum of type E_SgTemplateParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateParameter(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateParameter_expression"; break;
        case 1l: retval = "SgTemplateParameter_defaultExpressionParameter"; break;
        case 2l: retval = "SgTemplateParameter_templateDeclaration"; break;
        case 3l: retval = "SgTemplateParameter_defaultTemplateDeclarationParameter"; break;
        case 4l: retval = "SgTemplateParameter_initializedName"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateParameter)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateParameterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:40
/** Converts an enum of type E_SgTemplateParameterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateParameterList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateParameterList_args"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateParameterList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateParameterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1135
/** Converts an enum of type E_SgTemplateSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:181
/** Converts an enum of type E_SgTemplateType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:463
/** Converts an enum of type E_SgTemplateTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateTypedefDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateTypedefDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateTypedefSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1141
/** Converts an enum of type E_SgTemplateTypedefSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateTypedefSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateTypedefSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateTypedefSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateTypedefSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:433
/** Converts an enum of type E_SgTemplateVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateVariableDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTemplateVariableDeclaration_baseTypeDefiningDeclaration"; break;
        case 1l: retval = "SgTemplateVariableDeclaration_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTemplateVariableDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgThrowOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:745
/** Converts an enum of type E_SgThrowOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgThrowOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgThrowOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgThrowOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgThrowOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTryStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:544
/** Converts an enum of type E_SgTryStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTryStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTryStmt_body"; break;
        case 1l: retval = "SgTryStmt_catch_statement_seq_root"; break;
        case 2l: retval = "SgTryStmt_else_body"; break;
        case 3l: retval = "SgTryStmt_finally_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTryStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTryStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTupleExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:949
/** Converts an enum of type E_SgTupleExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTupleExp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTupleExp_expressions"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTupleExp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTupleExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:226
/** Converts an enum of type E_SgType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeBool is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:124
/** Converts an enum of type E_SgTypeBool to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeBool(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeBool_type_kind"; break;
        case 1l: retval = "SgTypeBool_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeBool)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeBool::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeCAFTeam is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:196
/** Converts an enum of type E_SgTypeCAFTeam to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeCAFTeam(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeCAFTeam_type_kind"; break;
        case 1l: retval = "SgTypeCAFTeam_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeCAFTeam)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeCAFTeam::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:52
/** Converts an enum of type E_SgTypeChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeChar(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeChar_type_kind"; break;
        case 1l: retval = "SgTypeChar_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeChar)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeComplex is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:187
/** Converts an enum of type E_SgTypeComplex to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeComplex(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeComplex_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeComplex)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeComplex::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeCrayPointer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:199
/** Converts an enum of type E_SgTypeCrayPointer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeCrayPointer(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeCrayPointer_type_kind"; break;
        case 1l: retval = "SgTypeCrayPointer_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeCrayPointer)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeCrayPointer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeDefault is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:193
/** Converts an enum of type E_SgTypeDefault to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeDefault(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeDefault_type_kind"; break;
        case 1l: retval = "SgTypeDefault_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeDefault)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeDefault::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeDouble is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:100
/** Converts an enum of type E_SgTypeDouble to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeDouble(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeDouble_type_kind"; break;
        case 1l: retval = "SgTypeDouble_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeDouble)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeDouble::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeEllipse is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:178
/** Converts an enum of type E_SgTypeEllipse to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeEllipse(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeEllipse_type_kind"; break;
        case 1l: retval = "SgTypeEllipse_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeEllipse)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeEllipse::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:97
/** Converts an enum of type E_SgTypeFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeFloat(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeFloat_type_kind"; break;
        case 1l: retval = "SgTypeFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeFloat)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeGlobalVoid is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:91
/** Converts an enum of type E_SgTypeGlobalVoid to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeGlobalVoid(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeGlobalVoid_type_kind"; break;
        case 1l: retval = "SgTypeGlobalVoid_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeGlobalVoid)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeGlobalVoid::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeIdOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:985
/** Converts an enum of type E_SgTypeIdOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeIdOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeIdOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeIdOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeIdOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeImaginary is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:190
/** Converts an enum of type E_SgTypeImaginary to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeImaginary(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeImaginary_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeImaginary)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeImaginary::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:70
/** Converts an enum of type E_SgTypeInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeInt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeInt_type_kind"; break;
        case 1l: retval = "SgTypeInt_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeInt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLabel is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:202
/** Converts an enum of type E_SgTypeLabel to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLabel(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeLabel_type_kind"; break;
        case 1l: retval = "SgTypeLabel_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeLabel)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLabel::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:79
/** Converts an enum of type E_SgTypeLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLong(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeLong_type_kind"; break;
        case 1l: retval = "SgTypeLong_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeLong)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLongDouble is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:118
/** Converts an enum of type E_SgTypeLongDouble to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLongDouble(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeLongDouble_type_kind"; break;
        case 1l: retval = "SgTypeLongDouble_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeLongDouble)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLongDouble::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:103
/** Converts an enum of type E_SgTypeLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLongLong(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeLongLong_type_kind"; break;
        case 1l: retval = "SgTypeLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeLongLong)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeMatrix is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:220
/** Converts an enum of type E_SgTypeMatrix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeMatrix(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeMatrix_type_kind"; break;
        case 1l: retval = "SgTypeMatrix_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeMatrix)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeMatrix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeNullptr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:211
/** Converts an enum of type E_SgTypeNullptr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeNullptr(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeNullptr_type_kind"; break;
        case 1l: retval = "SgTypeNullptr_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeNullptr)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeNullptr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeOfType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:217
/** Converts an enum of type E_SgTypeOfType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeOfType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeOfType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeOfType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeOfType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:61
/** Converts an enum of type E_SgTypeShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeShort(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeShort_type_kind"; break;
        case 1l: retval = "SgTypeShort_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeShort)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSigned128bitInteger is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:112
/** Converts an enum of type E_SgTypeSigned128bitInteger to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSigned128bitInteger(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeSigned128bitInteger_type_kind"; break;
        case 1l: retval = "SgTypeSigned128bitInteger_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeSigned128bitInteger)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSigned128bitInteger::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:55
/** Converts an enum of type E_SgTypeSignedChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedChar(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeSignedChar_type_kind"; break;
        case 1l: retval = "SgTypeSignedChar_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeSignedChar)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:73
/** Converts an enum of type E_SgTypeSignedInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedInt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeSignedInt_type_kind"; break;
        case 1l: retval = "SgTypeSignedInt_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeSignedInt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:82
/** Converts an enum of type E_SgTypeSignedLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedLong(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeSignedLong_type_kind"; break;
        case 1l: retval = "SgTypeSignedLong_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeSignedLong)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:106
/** Converts an enum of type E_SgTypeSignedLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedLongLong(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeSignedLongLong_type_kind"; break;
        case 1l: retval = "SgTypeSignedLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeSignedLongLong)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:64
/** Converts an enum of type E_SgTypeSignedShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedShort(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeSignedShort_type_kind"; break;
        case 1l: retval = "SgTypeSignedShort_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeSignedShort)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeString is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:121
/** Converts an enum of type E_SgTypeString to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeString(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeString_type_kind"; break;
        case 1l: retval = "SgTypeString_lengthExpression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeString)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeString::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeTuple is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:223
/** Converts an enum of type E_SgTypeTuple to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeTuple(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeTuple_type_kind"; break;
        case 1l: retval = "SgTypeTuple_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeTuple)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeTuple::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnknown is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:49
/** Converts an enum of type E_SgTypeUnknown to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnknown(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnknown_type_kind"; break;
        case 1l: retval = "SgTypeUnknown_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnknown)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnknown::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsigned128bitInteger is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:115
/** Converts an enum of type E_SgTypeUnsigned128bitInteger to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsigned128bitInteger(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnsigned128bitInteger_type_kind"; break;
        case 1l: retval = "SgTypeUnsigned128bitInteger_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnsigned128bitInteger)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsigned128bitInteger::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:58
/** Converts an enum of type E_SgTypeUnsignedChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedChar(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnsignedChar_type_kind"; break;
        case 1l: retval = "SgTypeUnsignedChar_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnsignedChar)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:76
/** Converts an enum of type E_SgTypeUnsignedInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedInt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnsignedInt_type_kind"; break;
        case 1l: retval = "SgTypeUnsignedInt_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnsignedInt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:85
/** Converts an enum of type E_SgTypeUnsignedLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedLong(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnsignedLong_type_kind"; break;
        case 1l: retval = "SgTypeUnsignedLong_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnsignedLong)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:109
/** Converts an enum of type E_SgTypeUnsignedLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedLongLong(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnsignedLongLong_type_kind"; break;
        case 1l: retval = "SgTypeUnsignedLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnsignedLongLong)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:67
/** Converts an enum of type E_SgTypeUnsignedShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedShort(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeUnsignedShort_type_kind"; break;
        case 1l: retval = "SgTypeUnsignedShort_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeUnsignedShort)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeVoid is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:88
/** Converts an enum of type E_SgTypeVoid to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeVoid(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeVoid_type_kind"; break;
        case 1l: retval = "SgTypeVoid_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeVoid)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeVoid::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeWchar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:94
/** Converts an enum of type E_SgTypeWchar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeWchar(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypeWchar_type_kind"; break;
        case 1l: retval = "SgTypeWchar_builtin_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypeWchar)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeWchar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:469
/** Converts an enum of type E_SgTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypedefDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypedefSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1144
/** Converts an enum of type E_SgTypedefSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefSymbol(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypedefSymbol_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypedefSymbol)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypedefType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:151
/** Converts an enum of type E_SgTypedefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgTypedefType_type_kind"; break;
        case 1l: retval = "SgTypedefType_builtin_type"; break;
        case 2l: retval = "SgTypedefType_declaration"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgTypedefType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnaryAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:721
/** Converts an enum of type E_SgUnaryAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnaryAddOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUnaryAddOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUnaryAddOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnaryAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:763
/** Converts an enum of type E_SgUnaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnaryOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUnaryOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUnaryOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnknownArrayOrFunctionReference is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1045
/** Converts an enum of type E_SgUnknownArrayOrFunctionReference to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnknownArrayOrFunctionReference(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUnknownArrayOrFunctionReference_named_reference"; break;
        case 1l: retval = "SgUnknownArrayOrFunctionReference_expression_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUnknownArrayOrFunctionReference)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnknownFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:10
/** Converts an enum of type E_SgUnknownFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnknownFile(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUnknownFile_globalScope"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUnknownFile)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnknownFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:334
/** Converts an enum of type E_SgUntypedArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedArrayType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedArrayType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedArrayType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedAssignmentStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:316
/** Converts an enum of type E_SgUntypedAssignmentStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedAssignmentStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedAssignmentStatement_lhs_operand"; break;
        case 1l: retval = "SgUntypedAssignmentStatement_rhs_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedAssignmentStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedAssignmentStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedBinaryOperator is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:298
/** Converts an enum of type E_SgUntypedBinaryOperator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedBinaryOperator(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedBinaryOperator_lhs_operand"; break;
        case 1l: retval = "SgUntypedBinaryOperator_rhs_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedBinaryOperator)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedBinaryOperator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedBlockStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:319
/** Converts an enum of type E_SgUntypedBlockStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedBlockStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedBlockStatement_scope"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedBlockStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedBlockStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedDeclarationStatementList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:346
/** Converts an enum of type E_SgUntypedDeclarationStatementList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedDeclarationStatementList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedDeclarationStatementList_decl_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedDeclarationStatementList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedDeclarationStatementList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:340
/** Converts an enum of type E_SgUntypedFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFile(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedFile_scope"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedFile)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:310
/** Converts an enum of type E_SgUntypedFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFunctionDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedFunctionDeclaration_parameters"; break;
        case 1l: retval = "SgUntypedFunctionDeclaration_scope"; break;
        case 2l: retval = "SgUntypedFunctionDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedFunctionDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFunctionDeclarationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:349
/** Converts an enum of type E_SgUntypedFunctionDeclarationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFunctionDeclarationList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedFunctionDeclarationList_func_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedFunctionDeclarationList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFunctionDeclarationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFunctionScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:322
/** Converts an enum of type E_SgUntypedFunctionScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFunctionScope(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedFunctionScope_declaration_list"; break;
        case 1l: retval = "SgUntypedFunctionScope_statement_list"; break;
        case 2l: retval = "SgUntypedFunctionScope_function_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedFunctionScope)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFunctionScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedGlobalScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:328
/** Converts an enum of type E_SgUntypedGlobalScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedGlobalScope(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedGlobalScope_declaration_list"; break;
        case 1l: retval = "SgUntypedGlobalScope_statement_list"; break;
        case 2l: retval = "SgUntypedGlobalScope_function_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedGlobalScope)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedGlobalScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedInitializedNameList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:352
/** Converts an enum of type E_SgUntypedInitializedNameList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedInitializedNameList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedInitializedNameList_name_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedInitializedNameList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedInitializedNameList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedModuleDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:313
/** Converts an enum of type E_SgUntypedModuleDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedModuleDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedModuleDeclaration_scope"; break;
        case 1l: retval = "SgUntypedModuleDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedModuleDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedModuleDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedModuleScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:325
/** Converts an enum of type E_SgUntypedModuleScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedModuleScope(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedModuleScope_declaration_list"; break;
        case 1l: retval = "SgUntypedModuleScope_statement_list"; break;
        case 2l: retval = "SgUntypedModuleScope_function_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedModuleScope)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedModuleScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedProgramHeaderDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:304
/** Converts an enum of type E_SgUntypedProgramHeaderDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedProgramHeaderDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedProgramHeaderDeclaration_parameters"; break;
        case 1l: retval = "SgUntypedProgramHeaderDeclaration_scope"; break;
        case 2l: retval = "SgUntypedProgramHeaderDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedProgramHeaderDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedProgramHeaderDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:331
/** Converts an enum of type E_SgUntypedScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedScope(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedScope_declaration_list"; break;
        case 1l: retval = "SgUntypedScope_statement_list"; break;
        case 2l: retval = "SgUntypedScope_function_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedScope)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedStatementList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:343
/** Converts an enum of type E_SgUntypedStatementList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedStatementList(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedStatementList_stmt_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedStatementList)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedStatementList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedSubroutineDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:307
/** Converts an enum of type E_SgUntypedSubroutineDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedSubroutineDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedSubroutineDeclaration_parameters"; break;
        case 1l: retval = "SgUntypedSubroutineDeclaration_scope"; break;
        case 2l: retval = "SgUntypedSubroutineDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedSubroutineDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedSubroutineDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:337
/** Converts an enum of type E_SgUntypedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedType_type_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedUnaryOperator is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:295
/** Converts an enum of type E_SgUntypedUnaryOperator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedUnaryOperator(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedUnaryOperator_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedUnaryOperator)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedUnaryOperator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:301
/** Converts an enum of type E_SgUntypedVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedVariableDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUntypedVariableDeclaration_parameters"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUntypedVariableDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcBarrierStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:631
/** Converts an enum of type E_SgUpcBarrierStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcBarrierStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcBarrierStatement_barrier_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcBarrierStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcBarrierStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcBlocksizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:976
/** Converts an enum of type E_SgUpcBlocksizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcBlocksizeofExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcBlocksizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcBlocksizeofExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcBlocksizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcElemsizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:979
/** Converts an enum of type E_SgUpcElemsizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcElemsizeofExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcElemsizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcElemsizeofExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcElemsizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcForAllStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:415
/** Converts an enum of type E_SgUpcForAllStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcForAllStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcForAllStatement_for_init_stmt"; break;
        case 1l: retval = "SgUpcForAllStatement_test"; break;
        case 2l: retval = "SgUpcForAllStatement_increment"; break;
        case 3l: retval = "SgUpcForAllStatement_affinity"; break;
        case 4l: retval = "SgUpcForAllStatement_loop_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcForAllStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcForAllStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcLocalsizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:973
/** Converts an enum of type E_SgUpcLocalsizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcLocalsizeofExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcLocalsizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcLocalsizeofExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcLocalsizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcNotifyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:625
/** Converts an enum of type E_SgUpcNotifyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcNotifyStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcNotifyStatement_notify_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcNotifyStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcNotifyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcWaitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:628
/** Converts an enum of type E_SgUpcWaitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcWaitStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUpcWaitStatement_wait_expression"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUpcWaitStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcWaitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUseStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:451
/** Converts an enum of type E_SgUseStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUseStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUseStatement_rename_list"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUseStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUseStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUserDefinedBinaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:859
/** Converts an enum of type E_SgUserDefinedBinaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUserDefinedBinaryOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUserDefinedBinaryOp_lhs_operand_i"; break;
        case 1l: retval = "SgUserDefinedBinaryOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUserDefinedBinaryOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUserDefinedBinaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUserDefinedUnaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:757
/** Converts an enum of type E_SgUserDefinedUnaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUserDefinedUnaryOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgUserDefinedUnaryOp_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgUserDefinedUnaryOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUserDefinedUnaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgCopyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1021
/** Converts an enum of type E_SgVarArgCopyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgCopyOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVarArgCopyOp_lhs_operand"; break;
        case 1l: retval = "SgVarArgCopyOp_rhs_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVarArgCopyOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgCopyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgEndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1018
/** Converts an enum of type E_SgVarArgEndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgEndOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVarArgEndOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVarArgEndOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgEndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1015
/** Converts an enum of type E_SgVarArgOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVarArgOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVarArgOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgStartOneOperandOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1024
/** Converts an enum of type E_SgVarArgStartOneOperandOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgStartOneOperandOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVarArgStartOneOperandOp_operand_expr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVarArgStartOneOperandOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgStartOneOperandOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgStartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1012
/** Converts an enum of type E_SgVarArgStartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgStartOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVarArgStartOp_lhs_operand"; break;
        case 1l: retval = "SgVarArgStartOp_rhs_operand"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVarArgStartOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgStartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:436
/** Converts an enum of type E_SgVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVariableDeclaration(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVariableDeclaration_baseTypeDefiningDeclaration"; break;
        case 1l: retval = "SgVariableDeclaration_variables"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVariableDeclaration)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVariableDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:439
/** Converts an enum of type E_SgVariableDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVariableDefinition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgVariableDefinition_vardefn"; break;
        case 1l: retval = "SgVariableDefinition_bitfield"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgVariableDefinition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVariableDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWaitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:592
/** Converts an enum of type E_SgWaitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWaitStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgWaitStatement_io_stmt_list"; break;
        case 1l: retval = "SgWaitStatement_unit"; break;
        case 2l: retval = "SgWaitStatement_iostat"; break;
        case 3l: retval = "SgWaitStatement_err"; break;
        case 4l: retval = "SgWaitStatement_iomsg"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgWaitStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWaitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWhereStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:598
/** Converts an enum of type E_SgWhereStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWhereStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgWhereStatement_condition"; break;
        case 1l: retval = "SgWhereStatement_body"; break;
        case 2l: retval = "SgWhereStatement_elsewhere"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgWhereStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWhereStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWhileStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:388
/** Converts an enum of type E_SgWhileStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWhileStmt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgWhileStmt_condition"; break;
        case 1l: retval = "SgWhileStmt_body"; break;
        case 2l: retval = "SgWhileStmt_else_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgWhileStmt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWhileStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWithStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:688
/** Converts an enum of type E_SgWithStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWithStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgWithStatement_expression"; break;
        case 1l: retval = "SgWithStatement_body"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgWithStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWithStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWriteStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:568
/** Converts an enum of type E_SgWriteStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWriteStatement(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgWriteStatement_io_stmt_list"; break;
        case 1l: retval = "SgWriteStatement_unit"; break;
        case 2l: retval = "SgWriteStatement_iostat"; break;
        case 3l: retval = "SgWriteStatement_err"; break;
        case 4l: retval = "SgWriteStatement_iomsg"; break;
        case 5l: retval = "SgWriteStatement_format"; break;
        case 6l: retval = "SgWriteStatement_rec"; break;
        case 7l: retval = "SgWriteStatement_namelist"; break;
        case 8l: retval = "SgWriteStatement_advance"; break;
        case 9l: retval = "SgWriteStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgWriteStatement)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWriteStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgXorAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:883
/** Converts an enum of type E_SgXorAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgXorAssignOp(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgXorAssignOp_lhs_operand_i"; break;
        case 1l: retval = "SgXorAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgXorAssignOp)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgXorAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgYieldExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1087
/** Converts an enum of type E_SgYieldExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgYieldExpression(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SgYieldExpression_value"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(E_SgYieldExpression)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgYieldExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// EditDistance::TreeEditDistance::EditType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/EditDistance/TreeEditDistance.h:60
/** Converts an enum of type EditDistance::TreeEditDistance::EditType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyEditDistanceTreeEditDistanceEditType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INSERT"; break;
        case 1l: retval = "DELETE"; break;
        case 2l: retval = "SUBSTITUTE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(EditDistance::TreeEditDistance::EditType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "EditDistance::TreeEditDistance::EditType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// FailSafe::fail_safe_enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/failSafe/failSafePragma.h:32
/** Converts an enum of type FailSafe::fail_safe_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFailSafe_fail_safe_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_region"; break;
        case 2l: retval = "e_status_predicate"; break;
        case 3l: retval = "e_data_predicate"; break;
        case 4l: retval = "e_tolerance"; break;
        case 5l: retval = "e_double_redundancy"; break;
        case 6l: retval = "e_triple_redundancy"; break;
        case 7l: retval = "e_save"; break;
        case 8l: retval = "e_assert"; break;
        case 9l: retval = "e_specifier"; break;
        case 10l: retval = "e_region_reference"; break;
        case 11l: retval = "e_error"; break;
        case 12l: retval = "e_violation"; break;
        case 13l: retval = "e_recover"; break;
        case 14l: retval = "e_pre"; break;
        case 15l: retval = "e_post"; break;
        case 16l: retval = "e_type_ET1"; break;
        case 17l: retval = "e_type_ET2"; break;
        case 18l: retval = "e_violation_NaN"; break;
        case 19l: retval = "e_violation_SECDED"; break;
        case 20l: retval = "e_violation_SEGFAULT"; break;
        case 21l: retval = "e_violation_ANY"; break;
        case 22l: retval = "e_not_failsafe"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(FailSafe::fail_safe_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "FailSafe::fail_safe_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// FailedAssertionBehaviorAdjuster::Behavior is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/commandlineProcessing/commandline_processing.C:56
/** Converts an enum of type FailedAssertionBehaviorAdjuster::Behavior to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFailedAssertionBehaviorAdjusterBehavior(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ABORT_ON_FAILURE"; break;
        case 1l: retval = "EXIT_ON_FAILURE"; break;
        case 2l: retval = "THROW_ON_FAILURE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(FailedAssertionBehaviorAdjuster::Behavior)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "FailedAssertionBehaviorAdjuster::Behavior::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Format_Opt is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/unparser/formatSupport/unparse_format.h:52
/** Converts an enum of type Format_Opt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFormat_Opt(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FORMAT_BEFORE_DIRECTIVE"; break;
        case 1l: retval = "FORMAT_AFTER_DIRECTIVE"; break;
        case 2l: retval = "FORMAT_BEFORE_STMT"; break;
        case 3l: retval = "FORMAT_AFTER_STMT"; break;
        case 4l: retval = "FORMAT_BEFORE_BASIC_BLOCK1"; break;
        case 5l: retval = "FORMAT_AFTER_BASIC_BLOCK1"; break;
        case 6l: retval = "FORMAT_BEFORE_BASIC_BLOCK2"; break;
        case 7l: retval = "FORMAT_AFTER_BASIC_BLOCK2"; break;
        case 8l: retval = "FORMAT_BEFORE_NESTED_STATEMENT"; break;
        case 9l: retval = "FORMAT_AFTER_NESTED_STATEMENT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Format_Opt)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Format_Opt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// FunctionCallInfo::InsertionMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programTransformation/extractFunctionArgumentsNormalization/functionEvaluationOrderTraversal.h:41
/** Converts an enum of type FunctionCallInfo::InsertionMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFunctionCallInfoInsertionMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INSERT_BEFORE"; break;
        case 1l: retval = "APPEND_SCOPE"; break;
        case 2l: retval = "INVALID"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(FunctionCallInfo::InsertionMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "FunctionCallInfo::InsertionMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// GenRepresentation::TypeOfPrint is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/dataStructureTraversal/GenRepresentation.h:24
/** Converts an enum of type GenRepresentation::TypeOfPrint to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyGenRepresentationTypeOfPrint(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElement"; break;
        case 1l: retval = "Container"; break;
        case 2l: retval = "Contained"; break;
        case 3l: retval = "END_OF_LIST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(GenRepresentation::TypeOfPrint)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "GenRepresentation::TypeOfPrint::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astRewriteMechanism/rewrite.h:177
/** Converts an enum of type HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknownIntermediatePositionInScope"; break;
        case 1l: retval = "GlobalScopePreamble"; break;
        case 2l: retval = "GlobalScopeTopOfScope"; break;
        case 3l: retval = "GlobalScopeTopOfIncludeRegion"; break;
        case 4l: retval = "GlobalScopeBottomOfIncludeRegion"; break;
        case 5l: retval = "GlobalScopeBeforeCurrentPosition"; break;
        case 6l: retval = "GlobalScopeReplaceCurrentPosition"; break;
        case 7l: retval = "FunctionScopePreamble"; break;
        case 8l: retval = "FunctionScopeTopOfScope"; break;
        case 9l: retval = "FunctionScopeBeforeCurrentPosition"; break;
        case 10l: retval = "FunctionScopeReplaceCurrentPosition"; break;
        case 11l: retval = "FunctionScopeAfterCurrentPosition"; break;
        case 12l: retval = "FunctionScopeBottomOfScope"; break;
        case 13l: retval = "GlobalScopeAfterCurrentPosition"; break;
        case 14l: retval = "GlobalScopeBottomOfScope"; break;
        case 15l: retval = "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// HighLevelCollectionTypedefs::PlacementPosition_Enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astRewriteMechanism/rewrite.h:163
/** Converts an enum of type HighLevelCollectionTypedefs::PlacementPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknownPositionInScope"; break;
        case 1l: retval = "PreamblePositionInScope"; break;
        case 2l: retval = "TopOfScope"; break;
        case 3l: retval = "TopOfIncludeRegion"; break;
        case 4l: retval = "BottomOfIncludeRegion"; break;
        case 5l: retval = "BeforeCurrentPosition"; break;
        case 6l: retval = "ReplaceCurrentPosition"; break;
        case 7l: retval = "AfterCurrentPosition"; break;
        case 8l: retval = "BottomOfScope"; break;
        case 9l: retval = "LAST_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(HighLevelCollectionTypedefs::PlacementPosition_Enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// HighLevelCollectionTypedefs::ScopeIdentifier_Enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astRewriteMechanism/rewrite.h:142
/** Converts an enum of type HighLevelCollectionTypedefs::ScopeIdentifier_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknownScope"; break;
        case 1l: retval = "SurroundingScope"; break;
        case 2l: retval = "ParentScope"; break;
        case 3l: retval = "NestedLoopScope"; break;
        case 4l: retval = "NestedConditionalScope"; break;
        case 5l: retval = "FunctionScope"; break;
        case 6l: retval = "FileScope"; break;
        case 7l: retval = "GlobalScope"; break;
        case 8l: retval = "Preamble"; break;
        case 9l: retval = "LAST_SCOPE_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// IRProcType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h:164
/** Converts an enum of type IRProcType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyIRProcType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ProcType_PGM"; break;
        case 1l: retval = "ProcType_SUB"; break;
        case 2l: retval = "ProcType_FUNC"; break;
        case 3l: retval = "ProcType_BDATA"; break;
        case 4l: retval = "ProcType_ILLEGAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(IRProcType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "IRProcType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// IRStmtType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h:174
/** Converts an enum of type IRStmtType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyIRStmtType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SIMPLE"; break;
        case 1l: retval = "COMPOUND"; break;
        case 2l: retval = "LOOP"; break;
        case 3l: retval = "END_TESTED_LOOP"; break;
        case 4l: retval = "STRUCT_TWOWAY_CONDITIONAL"; break;
        case 5l: retval = "STRUCT_MULTIWAY_CONDITIONAL"; break;
        case 6l: retval = "USTRUCT_TWOWAY_CONDITIONAL_T"; break;
        case 7l: retval = "USTRUCT_TWOWAY_CONDITIONAL_F"; break;
        case 8l: retval = "USTRUCT_MULTIWAY_CONDITIONAL"; break;
        case 9l: retval = "RETURN"; break;
        case 10l: retval = "BREAK"; break;
        case 11l: retval = "LOOP_CONTINUE"; break;
        case 12l: retval = "ALTERNATE_PROC_ENTRY"; break;
        case 13l: retval = "UNCONDITIONAL_JUMP"; break;
        case 14l: retval = "UNCONDITIONAL_JUMP_I"; break;
        case 15l: retval = "NONE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(IRStmtType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "IRStmtType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// KLT::Descriptor::tile_kind_e is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/KLT/include/KLT/Core/descriptor.hpp:18
/** Converts an enum of type KLT::Descriptor::tile_kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyKLT_Descriptor_tile_kind_e(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -1l: retval = "e_not_tile"; break;
        case 0l: retval = "e_static_tile"; break;
        case 1l: retval = "e_dynamic_tile"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(KLT::Descriptor::tile_kind_e)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "KLT::Descriptor::tile_kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// KLT::LoopTree::kind_e is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/KLT/include/KLT/Core/looptree.hpp:30
/** Converts an enum of type KLT::LoopTree::kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyKLT_LoopTree_kind_e(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_block"; break;
        case 1l: retval = "e_cond"; break;
        case 2l: retval = "e_loop"; break;
        case 3l: retval = "e_tile"; break;
        case 4l: retval = "e_stmt"; break;
        case 5l: retval = "e_ignored"; break;
        case 6l: retval = "e_unknown"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(KLT::LoopTree::kind_e)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "KLT::LoopTree::kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kDataFormat is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:231
/** Converts an enum of type M68kDataFormat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kDataFormat(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_fmt_i32"; break;
        case 1l: retval = "m68k_fmt_f32"; break;
        case 2l: retval = "m68k_fmt_f96"; break;
        case 3l: retval = "m68k_fmt_p96"; break;
        case 4l: retval = "m68k_fmt_i16"; break;
        case 5l: retval = "m68k_fmt_f64"; break;
        case 6l: retval = "m68k_fmt_i8"; break;
        case 255l: retval = "m68k_fmt_unknown"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kDataFormat)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kDataFormat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kEffectiveAddressMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:177
/** Converts an enum of type M68kEffectiveAddressMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kEffectiveAddressMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_eam_unknown"; break;
        case 1l: retval = "m68k_eam_drd"; break;
        case 2l: retval = "m68k_eam_ard"; break;
        case 3l: retval = "m68k_eam_rd"; break;
        case 4l: retval = "m68k_eam_ari"; break;
        case 8l: retval = "m68k_eam_inc"; break;
        case 16l: retval = "m68k_eam_dec"; break;
        case 32l: retval = "m68k_eam_dsp"; break;
        case 60l: retval = "m68k_eam_ri"; break;
        case 64l: retval = "m68k_eam_idx8"; break;
        case 128l: retval = "m68k_eam_idxbd"; break;
        case 192l: retval = "m68k_eam_idx"; break;
        case 256l: retval = "m68k_eam_mpost"; break;
        case 512l: retval = "m68k_eam_mpre"; break;
        case 768l: retval = "m68k_eam_mi"; break;
        case 1024l: retval = "m68k_eam_pcdsp"; break;
        case 2048l: retval = "m68k_eam_pcidx8"; break;
        case 4096l: retval = "m68k_eam_pcidxbd"; break;
        case 6144l: retval = "m68k_eam_pcidx"; break;
        case 8192l: retval = "m68k_eam_pcmpost"; break;
        case 16384l: retval = "m68k_eam_pcmpre"; break;
        case 24576l: retval = "m68k_eam_pcmi"; break;
        case 29568l: retval = "m68k_eam_234"; break;
        case 31744l: retval = "m68k_eam_pc"; break;
        case 32768l: retval = "m68k_eam_absw"; break;
        case 65536l: retval = "m68k_eam_absl"; break;
        case 98304l: retval = "m68k_eam_abs"; break;
        case 123903l: retval = "m68k_eam_alter"; break;
        case 131044l: retval = "m68k_eam_control"; break;
        case 131072l: retval = "m68k_eam_imm"; break;
        case 262140l: retval = "m68k_eam_memory"; break;
        case 262141l: retval = "m68k_eam_data"; break;
        case 262143l: retval = "m68k_eam_all"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kEffectiveAddressMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kEffectiveAddressMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kEmacRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:81
/** Converts an enum of type M68kEmacRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kEmacRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_emac_macsr"; break;
        case 1l: retval = "m68k_emac_acc0"; break;
        case 2l: retval = "m68k_emac_acc1"; break;
        case 3l: retval = "m68k_emac_acc2"; break;
        case 4l: retval = "m68k_emac_acc3"; break;
        case 5l: retval = "m68k_emac_mask"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kEmacRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kEmacRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kFamily is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:12
/** Converts an enum of type M68kFamily to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kFamily(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "m68k_68000_only"; break;
        case 2l: retval = "m68k_68ec000"; break;
        case 4l: retval = "m68k_68hc000"; break;
        case 7l: retval = "m68k_68000"; break;
        case 8l: retval = "m68k_68008"; break;
        case 16l: retval = "m68k_68010"; break;
        case 32l: retval = "m68k_68012"; break;
        case 255l: retval = "m68k_generation_1"; break;
        case 256l: retval = "m68k_68020_only"; break;
        case 512l: retval = "m68k_68ec020"; break;
        case 768l: retval = "m68k_68020"; break;
        case 1024l: retval = "m68k_68030_only"; break;
        case 4096l: retval = "m68k_68ec030"; break;
        case 8192l: retval = "m68k_68030"; break;
        case 65280l: retval = "m68k_generation_2"; break;
        case 65536l: retval = "m68k_68040_only"; break;
        case 131072l: retval = "m68k_68ec040"; break;
        case 262144l: retval = "m68k_68lc040"; break;
        case 458752l: retval = "m68k_68040"; break;
        case 16711680l: retval = "m68k_generation_3"; break;
        case 16777216l: retval = "m68k_freescale_cpu32"; break;
        case 33554432l: retval = "m68k_freescale_isaa"; break;
        case 67108864l: retval = "m68k_freescale_isab"; break;
        case 134217728l: retval = "m68k_freescale_isac"; break;
        case 268435456l: retval = "m68k_freescale_fpu"; break;
        case 536870912l: retval = "m68k_freescale_mac"; break;
        case 1073741824l: retval = "m68k_freescale_emac"; break;
        case 2147483648l: retval = "m68k_freescale_emacb"; break;
        case 4278190080l: retval = "m68k_freescale"; break;
        case 4294967295l: retval = "m68k_family"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kFamily)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kFamily::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kInstructionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:242
/** Converts an enum of type M68kInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kInstructionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_unknown_instruction"; break;
        case 1l: retval = "m68k_abcd"; break;
        case 2l: retval = "m68k_add"; break;
        case 3l: retval = "m68k_adda"; break;
        case 4l: retval = "m68k_addi"; break;
        case 5l: retval = "m68k_addq"; break;
        case 6l: retval = "m68k_addx"; break;
        case 7l: retval = "m68k_and"; break;
        case 8l: retval = "m68k_andi"; break;
        case 9l: retval = "m68k_asl"; break;
        case 10l: retval = "m68k_asr"; break;
        case 11l: retval = "m68k_bcc"; break;
        case 12l: retval = "m68k_bcs"; break;
        case 13l: retval = "m68k_beq"; break;
        case 14l: retval = "m68k_bge"; break;
        case 15l: retval = "m68k_bgt"; break;
        case 16l: retval = "m68k_bhi"; break;
        case 17l: retval = "m68k_ble"; break;
        case 18l: retval = "m68k_bls"; break;
        case 19l: retval = "m68k_blt"; break;
        case 20l: retval = "m68k_bmi"; break;
        case 21l: retval = "m68k_bne"; break;
        case 22l: retval = "m68k_bpl"; break;
        case 23l: retval = "m68k_bvc"; break;
        case 24l: retval = "m68k_bvs"; break;
        case 25l: retval = "m68k_bchg"; break;
        case 26l: retval = "m68k_bclr"; break;
        case 27l: retval = "m68k_bfchg"; break;
        case 28l: retval = "m68k_bfclr"; break;
        case 29l: retval = "m68k_bfexts"; break;
        case 30l: retval = "m68k_bfextu"; break;
        case 31l: retval = "m68k_bfins"; break;
        case 32l: retval = "m68k_bfset"; break;
        case 33l: retval = "m68k_bftst"; break;
        case 34l: retval = "m68k_bkpt"; break;
        case 35l: retval = "m68k_bra"; break;
        case 36l: retval = "m68k_bset"; break;
        case 37l: retval = "m68k_bsr"; break;
        case 38l: retval = "m68k_btst"; break;
        case 39l: retval = "m68k_callm"; break;
        case 40l: retval = "m68k_cas"; break;
        case 41l: retval = "m68k_cas2"; break;
        case 42l: retval = "m68k_chk"; break;
        case 43l: retval = "m68k_chk2"; break;
        case 44l: retval = "m68k_clr"; break;
        case 45l: retval = "m68k_cmp"; break;
        case 46l: retval = "m68k_cmp2"; break;
        case 47l: retval = "m68k_cmpa"; break;
        case 48l: retval = "m68k_cmpi"; break;
        case 49l: retval = "m68k_cmpm"; break;
        case 50l: retval = "m68k_cpusha"; break;
        case 51l: retval = "m68k_cpushl"; break;
        case 52l: retval = "m68k_cpushp"; break;
        case 53l: retval = "m68k_dbt"; break;
        case 54l: retval = "m68k_dbf"; break;
        case 55l: retval = "m68k_dbhi"; break;
        case 56l: retval = "m68k_dbls"; break;
        case 57l: retval = "m68k_dbcc"; break;
        case 58l: retval = "m68k_dbcs"; break;
        case 59l: retval = "m68k_dbne"; break;
        case 60l: retval = "m68k_dbeq"; break;
        case 61l: retval = "m68k_dbvc"; break;
        case 62l: retval = "m68k_dbvs"; break;
        case 63l: retval = "m68k_dbpl"; break;
        case 64l: retval = "m68k_dbmi"; break;
        case 65l: retval = "m68k_dbge"; break;
        case 66l: retval = "m68k_dblt"; break;
        case 67l: retval = "m68k_dbgt"; break;
        case 68l: retval = "m68k_dble"; break;
        case 69l: retval = "m68k_divs"; break;
        case 70l: retval = "m68k_divsl"; break;
        case 71l: retval = "m68k_divu"; break;
        case 72l: retval = "m68k_divul"; break;
        case 73l: retval = "m68k_eor"; break;
        case 74l: retval = "m68k_eori"; break;
        case 75l: retval = "m68k_exg"; break;
        case 76l: retval = "m68k_ext"; break;
        case 77l: retval = "m68k_extb"; break;
        case 78l: retval = "m68k_fabs"; break;
        case 79l: retval = "m68k_fadd"; break;
        case 80l: retval = "m68k_fbeq"; break;
        case 81l: retval = "m68k_fbne"; break;
        case 82l: retval = "m68k_fbgt"; break;
        case 83l: retval = "m68k_fbngt"; break;
        case 84l: retval = "m68k_fbge"; break;
        case 85l: retval = "m68k_fbnge"; break;
        case 86l: retval = "m68k_fblt"; break;
        case 87l: retval = "m68k_fbnlt"; break;
        case 88l: retval = "m68k_fble"; break;
        case 89l: retval = "m68k_fbnle"; break;
        case 90l: retval = "m68k_fbgl"; break;
        case 91l: retval = "m68k_fbngl"; break;
        case 92l: retval = "m68k_fbgle"; break;
        case 93l: retval = "m68k_fbngle"; break;
        case 94l: retval = "m68k_fbogt"; break;
        case 95l: retval = "m68k_fbule"; break;
        case 96l: retval = "m68k_fboge"; break;
        case 97l: retval = "m68k_fbult"; break;
        case 98l: retval = "m68k_fbolt"; break;
        case 99l: retval = "m68k_fbuge"; break;
        case 100l: retval = "m68k_fbole"; break;
        case 101l: retval = "m68k_fbugt"; break;
        case 102l: retval = "m68k_fbogl"; break;
        case 103l: retval = "m68k_fbueq"; break;
        case 104l: retval = "m68k_fbor"; break;
        case 105l: retval = "m68k_fbun"; break;
        case 106l: retval = "m68k_fbf"; break;
        case 107l: retval = "m68k_fbt"; break;
        case 108l: retval = "m68k_fbsf"; break;
        case 109l: retval = "m68k_fbst"; break;
        case 110l: retval = "m68k_fbseq"; break;
        case 111l: retval = "m68k_fbsne"; break;
        case 112l: retval = "m68k_fcmp"; break;
        case 113l: retval = "m68k_fdabs"; break;
        case 114l: retval = "m68k_fdadd"; break;
        case 115l: retval = "m68k_fddiv"; break;
        case 116l: retval = "m68k_fdiv"; break;
        case 117l: retval = "m68k_fdmove"; break;
        case 118l: retval = "m68k_fdmul"; break;
        case 119l: retval = "m68k_fdneg"; break;
        case 120l: retval = "m68k_fdsqrt"; break;
        case 121l: retval = "m68k_fdsub"; break;
        case 122l: retval = "m68k_fint"; break;
        case 123l: retval = "m68k_fintrz"; break;
        case 124l: retval = "m68k_fmove"; break;
        case 125l: retval = "m68k_fmovem"; break;
        case 126l: retval = "m68k_fmul"; break;
        case 127l: retval = "m68k_fneg"; break;
        case 128l: retval = "m68k_fnop"; break;
        case 129l: retval = "m68k_fsabs"; break;
        case 130l: retval = "m68k_fsadd"; break;
        case 131l: retval = "m68k_fsdiv"; break;
        case 132l: retval = "m68k_fsmove"; break;
        case 133l: retval = "m68k_fsmul"; break;
        case 134l: retval = "m68k_fsneg"; break;
        case 135l: retval = "m68k_fsqrt"; break;
        case 136l: retval = "m68k_fssqrt"; break;
        case 137l: retval = "m68k_fssub"; break;
        case 138l: retval = "m68k_fsub"; break;
        case 139l: retval = "m68k_ftst"; break;
        case 140l: retval = "m68k_illegal"; break;
        case 141l: retval = "m68k_jmp"; break;
        case 142l: retval = "m68k_jsr"; break;
        case 143l: retval = "m68k_lea"; break;
        case 144l: retval = "m68k_link"; break;
        case 145l: retval = "m68k_lsl"; break;
        case 146l: retval = "m68k_lsr"; break;
        case 147l: retval = "m68k_mac"; break;
        case 148l: retval = "m68k_mov3q"; break;
        case 149l: retval = "m68k_movclr"; break;
        case 150l: retval = "m68k_move"; break;
        case 151l: retval = "m68k_move_acc"; break;
        case 152l: retval = "m68k_move_accext"; break;
        case 153l: retval = "m68k_move_ccr"; break;
        case 154l: retval = "m68k_move_macsr"; break;
        case 155l: retval = "m68k_move_mask"; break;
        case 156l: retval = "m68k_move_sr"; break;
        case 157l: retval = "m68k_move16"; break;
        case 158l: retval = "m68k_movea"; break;
        case 159l: retval = "m68k_movec"; break;
        case 160l: retval = "m68k_movem"; break;
        case 161l: retval = "m68k_movep"; break;
        case 162l: retval = "m68k_moveq"; break;
        case 163l: retval = "m68k_msac"; break;
        case 164l: retval = "m68k_muls"; break;
        case 165l: retval = "m68k_mulu"; break;
        case 166l: retval = "m68k_mvs"; break;
        case 167l: retval = "m68k_mvz"; break;
        case 168l: retval = "m68k_nbcd"; break;
        case 169l: retval = "m68k_neg"; break;
        case 170l: retval = "m68k_negx"; break;
        case 171l: retval = "m68k_nop"; break;
        case 172l: retval = "m68k_not"; break;
        case 173l: retval = "m68k_or"; break;
        case 174l: retval = "m68k_ori"; break;
        case 175l: retval = "m68k_pack"; break;
        case 176l: retval = "m68k_pea"; break;
        case 177l: retval = "m68k_rol"; break;
        case 178l: retval = "m68k_ror"; break;
        case 179l: retval = "m68k_roxl"; break;
        case 180l: retval = "m68k_roxr"; break;
        case 181l: retval = "m68k_rtd"; break;
        case 182l: retval = "m68k_rtm"; break;
        case 183l: retval = "m68k_rtr"; break;
        case 184l: retval = "m68k_rts"; break;
        case 185l: retval = "m68k_sbcd"; break;
        case 186l: retval = "m68k_st"; break;
        case 187l: retval = "m68k_sf"; break;
        case 188l: retval = "m68k_shi"; break;
        case 189l: retval = "m68k_sls"; break;
        case 190l: retval = "m68k_scc"; break;
        case 191l: retval = "m68k_scs"; break;
        case 192l: retval = "m68k_sne"; break;
        case 193l: retval = "m68k_seq"; break;
        case 194l: retval = "m68k_svc"; break;
        case 195l: retval = "m68k_svs"; break;
        case 196l: retval = "m68k_spl"; break;
        case 197l: retval = "m68k_smi"; break;
        case 198l: retval = "m68k_sge"; break;
        case 199l: retval = "m68k_slt"; break;
        case 200l: retval = "m68k_sgt"; break;
        case 201l: retval = "m68k_sle"; break;
        case 202l: retval = "m68k_sub"; break;
        case 203l: retval = "m68k_suba"; break;
        case 204l: retval = "m68k_subi"; break;
        case 205l: retval = "m68k_subq"; break;
        case 206l: retval = "m68k_subx"; break;
        case 207l: retval = "m68k_swap"; break;
        case 208l: retval = "m68k_tas"; break;
        case 209l: retval = "m68k_trap"; break;
        case 210l: retval = "m68k_trapt"; break;
        case 211l: retval = "m68k_trapf"; break;
        case 212l: retval = "m68k_traphi"; break;
        case 213l: retval = "m68k_trapls"; break;
        case 214l: retval = "m68k_trapcc"; break;
        case 215l: retval = "m68k_trapcs"; break;
        case 216l: retval = "m68k_trapne"; break;
        case 217l: retval = "m68k_trapeq"; break;
        case 218l: retval = "m68k_trapvc"; break;
        case 219l: retval = "m68k_trapvs"; break;
        case 220l: retval = "m68k_trappl"; break;
        case 221l: retval = "m68k_trapmi"; break;
        case 222l: retval = "m68k_trapge"; break;
        case 223l: retval = "m68k_traplt"; break;
        case 224l: retval = "m68k_trapgt"; break;
        case 225l: retval = "m68k_traple"; break;
        case 226l: retval = "m68k_trapv"; break;
        case 227l: retval = "m68k_tst"; break;
        case 228l: retval = "m68k_unlk"; break;
        case 229l: retval = "m68k_unpk"; break;
        case 230l: retval = "m68k_last_instruction"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kInstructionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kMacRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:66
/** Converts an enum of type M68kMacRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kMacRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_mac_macsr"; break;
        case 1l: retval = "m68k_mac_acc0"; break;
        case 2l: retval = "m68k_mac_acc1"; break;
        case 3l: retval = "m68k_mac_acc2"; break;
        case 4l: retval = "m68k_mac_acc3"; break;
        case 5l: retval = "m68k_mac_ext01"; break;
        case 6l: retval = "m68k_mac_ext23"; break;
        case 7l: retval = "m68k_mac_ext0"; break;
        case 8l: retval = "m68k_mac_ext1"; break;
        case 9l: retval = "m68k_mac_ext2"; break;
        case 10l: retval = "m68k_mac_ext3"; break;
        case 11l: retval = "m68k_mac_mask"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kMacRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kMacRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kRegisterClass is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:49
/** Converts an enum of type M68kRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kRegisterClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_regclass_data"; break;
        case 1l: retval = "m68k_regclass_addr"; break;
        case 2l: retval = "m68k_regclass_fpr"; break;
        case 3l: retval = "m68k_regclass_spr"; break;
        case 4l: retval = "m68k_regclass_mac"; break;
        case 5l: retval = "m68k_regclass_sup"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kRegisterClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kSpecialPurposeRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:58
/** Converts an enum of type M68kSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kSpecialPurposeRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_spr_pc"; break;
        case 1l: retval = "m68k_spr_sr"; break;
        case 2l: retval = "m68k_spr_fpcr"; break;
        case 3l: retval = "m68k_spr_fpsr"; break;
        case 4l: retval = "m68k_spr_fpiar"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kSpecialPurposeRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kSupervisorRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsM68k.h:90
/** Converts an enum of type M68kSupervisorRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kSupervisorRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "m68k_sup_vbr"; break;
        case 1l: retval = "m68k_sup_ssp"; break;
        case 2l: retval = "m68k_sup_sfc"; break;
        case 3l: retval = "m68k_sup_dfc"; break;
        case 4l: retval = "m68k_sup_cacr"; break;
        case 5l: retval = "m68k_sup_asid"; break;
        case 6l: retval = "m68k_sup_acr0"; break;
        case 7l: retval = "m68k_sup_acr1"; break;
        case 8l: retval = "m68k_sup_acr2"; break;
        case 9l: retval = "m68k_sup_acr3"; break;
        case 10l: retval = "m68k_sup_mmubar"; break;
        case 11l: retval = "m68k_sup_rombar0"; break;
        case 12l: retval = "m68k_sup_rombar1"; break;
        case 13l: retval = "m68k_sup_rambar0"; break;
        case 14l: retval = "m68k_sup_rambar1"; break;
        case 15l: retval = "m68k_sup_mbar"; break;
        case 16l: retval = "m68k_sup_mpcr"; break;
        case 17l: retval = "m68k_sup_edrambar"; break;
        case 18l: retval = "m68k_sup_secmbar"; break;
        case 19l: retval = "m68k_sup_0_pcr1"; break;
        case 20l: retval = "m68k_sup_0_pcr2"; break;
        case 21l: retval = "m68k_sup_0_pcr3"; break;
        case 22l: retval = "m68k_sup_1_pcr1"; break;
        case 23l: retval = "m68k_sup_1_pcr2"; break;
        case 24l: retval = "m68k_sup_1_pcr3"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(M68kSupervisorRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kSupervisorRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MDCG::Model::element_t::kind_e is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/MDCG/include/MDCG/Model/base.hpp:46
/** Converts an enum of type MDCG::Model::element_t::kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMDCG_Model_element_t_kind_e(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MDCG::Model::element_t::kind_e)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MDCG::Model::element_t::kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MDCG::Model::model_elements_e is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/MDCG/include/MDCG/Model/base.hpp:24
/** Converts an enum of type MDCG::Model::model_elements_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMDCG_Model_model_elements_e(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_model_blank"; break;
        case 1l: retval = "e_model_variable"; break;
        case 2l: retval = "e_model_function"; break;
        case 3l: retval = "e_model_field"; break;
        case 4l: retval = "e_model_method"; break;
        case 5l: retval = "e_model_type"; break;
        case 6l: retval = "e_model_class"; break;
        case 7l: retval = "e_model_namespace"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MDCG::Model::model_elements_e)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MDCG::Model::model_elements_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MatchStatus::CheckNodeMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astMatching/MatchOperation.h:43
/** Converts an enum of type MatchStatus::CheckNodeMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMatchStatusCheckNodeMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NODECHECKMODE_TYPEID"; break;
        case 1l: retval = "NODECHECKMODE_VARIANT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MatchStatus::CheckNodeMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MatchStatus::CheckNodeMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MatchStatus::PatternMatchMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astMatching/MatchOperation.h:42
/** Converts an enum of type MatchStatus::PatternMatchMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMatchStatusPatternMatchMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "MATCHMODE_SHALLOW"; break;
        case 1l: retval = "MATCHMODE_DEEP"; break;
        case 2l: retval = "MATCHMODE_SINGLE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MatchStatus::PatternMatchMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MatchStatus::PatternMatchMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astRewriteMechanism/rewrite.h:80
/** Converts an enum of type MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknownIntermediatePositionInScope"; break;
        case 1l: retval = "GlobalScopePreamble"; break;
        case 2l: retval = "CurrentLocationTopOfScope"; break;
        case 3l: retval = "CurrentLocationBefore"; break;
        case 4l: retval = "CurrentLocationReplace"; break;
        case 5l: retval = "CurrentLocationAfter"; break;
        case 6l: retval = "CurrentLocationBottomOfScope"; break;
        case 7l: retval = "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MidLevelCollectionTypedefs::PlacementPosition_Enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astRewriteMechanism/rewrite.h:67
/** Converts an enum of type MidLevelCollectionTypedefs::PlacementPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknownPositionInScope"; break;
        case 1l: retval = "PreamblePositionInScope"; break;
        case 2l: retval = "TopOfCurrentScope"; break;
        case 3l: retval = "BeforeCurrentPosition"; break;
        case 4l: retval = "ReplaceCurrentPosition"; break;
        case 5l: retval = "AfterCurrentPosition"; break;
        case 6l: retval = "BottomOfCurrentScope"; break;
        case 7l: retval = "LAST_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MidLevelCollectionTypedefs::PlacementPosition_Enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MidLevelCollectionTypedefs::ScopeIdentifier_Enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astRewriteMechanism/rewrite.h:53
/** Converts an enum of type MidLevelCollectionTypedefs::ScopeIdentifier_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknownScope"; break;
        case 1l: retval = "StatementScope"; break;
        case 2l: retval = "SurroundingScope"; break;
        case 3l: retval = "Preamble"; break;
        case 4l: retval = "LAST_SCOPE_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsFcsrMinors is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsMips.h:18
/** Converts an enum of type MipsFcsrMinors to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsFcsrMinors(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "mips_fcsr_all"; break;
        case 1l: retval = "mips_fcsr_fccr"; break;
        case 2l: retval = "mips_fcsr_fexr"; break;
        case 3l: retval = "mips_fcsr_fenr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MipsFcsrMinors)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsFcsrMinors::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsInstructionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsMips.h:35
/** Converts an enum of type MipsInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsInstructionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "mips_unknown_instruction"; break;
        case 1l: retval = "mips_abs_s"; break;
        case 2l: retval = "mips_abs_d"; break;
        case 3l: retval = "mips_abs_ps"; break;
        case 4l: retval = "mips_add"; break;
        case 5l: retval = "mips_add_s"; break;
        case 6l: retval = "mips_add_d"; break;
        case 7l: retval = "mips_add_ps"; break;
        case 8l: retval = "mips_addi"; break;
        case 9l: retval = "mips_addiu"; break;
        case 10l: retval = "mips_addu"; break;
        case 11l: retval = "mips_alnv_ps"; break;
        case 12l: retval = "mips_and"; break;
        case 13l: retval = "mips_andi"; break;
        case 14l: retval = "mips_bc1f"; break;
        case 15l: retval = "mips_bc1fl"; break;
        case 16l: retval = "mips_bc1t"; break;
        case 17l: retval = "mips_bc1tl"; break;
        case 18l: retval = "mips_bc2f"; break;
        case 19l: retval = "mips_bc2fl"; break;
        case 20l: retval = "mips_bc2t"; break;
        case 21l: retval = "mips_bc2tl"; break;
        case 22l: retval = "mips_beq"; break;
        case 23l: retval = "mips_beql"; break;
        case 24l: retval = "mips_bgez"; break;
        case 25l: retval = "mips_bgezal"; break;
        case 26l: retval = "mips_bgezall"; break;
        case 27l: retval = "mips_bgezl"; break;
        case 28l: retval = "mips_bgtz"; break;
        case 29l: retval = "mips_bgtzl"; break;
        case 30l: retval = "mips_blez"; break;
        case 31l: retval = "mips_blezl"; break;
        case 32l: retval = "mips_bltz"; break;
        case 33l: retval = "mips_bltzal"; break;
        case 34l: retval = "mips_bltzall"; break;
        case 35l: retval = "mips_bltzl"; break;
        case 36l: retval = "mips_bne"; break;
        case 37l: retval = "mips_bnel"; break;
        case 38l: retval = "mips_break"; break;
        case 39l: retval = "mips_c_f_s"; break;
        case 40l: retval = "mips_c_un_s"; break;
        case 41l: retval = "mips_c_eq_s"; break;
        case 42l: retval = "mips_c_ueq_s"; break;
        case 43l: retval = "mips_c_olt_s"; break;
        case 44l: retval = "mips_c_ult_s"; break;
        case 45l: retval = "mips_c_ole_s"; break;
        case 46l: retval = "mips_c_ule_s"; break;
        case 47l: retval = "mips_c_sf_s"; break;
        case 48l: retval = "mips_c_ngle_s"; break;
        case 49l: retval = "mips_c_seq_s"; break;
        case 50l: retval = "mips_c_ngl_s"; break;
        case 51l: retval = "mips_c_lt_s"; break;
        case 52l: retval = "mips_c_nge_s"; break;
        case 53l: retval = "mips_c_le_s"; break;
        case 54l: retval = "mips_c_ngt_s"; break;
        case 55l: retval = "mips_c_f_d"; break;
        case 56l: retval = "mips_c_un_d"; break;
        case 57l: retval = "mips_c_eq_d"; break;
        case 58l: retval = "mips_c_ueq_d"; break;
        case 59l: retval = "mips_c_olt_d"; break;
        case 60l: retval = "mips_c_ult_d"; break;
        case 61l: retval = "mips_c_ole_d"; break;
        case 62l: retval = "mips_c_ule_d"; break;
        case 63l: retval = "mips_c_sf_d"; break;
        case 64l: retval = "mips_c_ngle_d"; break;
        case 65l: retval = "mips_c_seq_d"; break;
        case 66l: retval = "mips_c_ngl_d"; break;
        case 67l: retval = "mips_c_lt_d"; break;
        case 68l: retval = "mips_c_nge_d"; break;
        case 69l: retval = "mips_c_le_d"; break;
        case 70l: retval = "mips_c_ngt_d"; break;
        case 71l: retval = "mips_c_f_ps"; break;
        case 72l: retval = "mips_c_un_ps"; break;
        case 73l: retval = "mips_c_eq_ps"; break;
        case 74l: retval = "mips_c_ueq_ps"; break;
        case 75l: retval = "mips_c_olt_ps"; break;
        case 76l: retval = "mips_c_ult_ps"; break;
        case 77l: retval = "mips_c_ole_ps"; break;
        case 78l: retval = "mips_c_ule_ps"; break;
        case 79l: retval = "mips_c_sf_ps"; break;
        case 80l: retval = "mips_c_ngle_ps"; break;
        case 81l: retval = "mips_c_seq_ps"; break;
        case 82l: retval = "mips_c_ngl_ps"; break;
        case 83l: retval = "mips_c_lt_ps"; break;
        case 84l: retval = "mips_c_nge_ps"; break;
        case 85l: retval = "mips_c_le_ps"; break;
        case 86l: retval = "mips_c_ngt_ps"; break;
        case 87l: retval = "mips_cache"; break;
        case 88l: retval = "mips_cachee"; break;
        case 89l: retval = "mips_ceil_l_s"; break;
        case 90l: retval = "mips_ceil_l_d"; break;
        case 91l: retval = "mips_ceil_w_s"; break;
        case 92l: retval = "mips_ceil_w_d"; break;
        case 93l: retval = "mips_cfc1"; break;
        case 94l: retval = "mips_cfc2"; break;
        case 95l: retval = "mips_clo"; break;
        case 96l: retval = "mips_clz"; break;
        case 97l: retval = "mips_cop2"; break;
        case 98l: retval = "mips_ctc1"; break;
        case 99l: retval = "mips_ctc2"; break;
        case 100l: retval = "mips_cvt_d_s"; break;
        case 101l: retval = "mips_cvt_d_w"; break;
        case 102l: retval = "mips_cvt_d_l"; break;
        case 103l: retval = "mips_cvt_l_s"; break;
        case 104l: retval = "mips_cvt_l_d"; break;
        case 105l: retval = "mips_cvt_ps_s"; break;
        case 106l: retval = "mips_cvt_s_d"; break;
        case 107l: retval = "mips_cvt_s_w"; break;
        case 108l: retval = "mips_cvt_s_l"; break;
        case 109l: retval = "mips_cvt_s_pl"; break;
        case 110l: retval = "mips_cvt_s_pu"; break;
        case 111l: retval = "mips_cvt_w_s"; break;
        case 112l: retval = "mips_cvt_w_d"; break;
        case 113l: retval = "mips_di"; break;
        case 114l: retval = "mips_div"; break;
        case 115l: retval = "mips_div_s"; break;
        case 116l: retval = "mips_div_d"; break;
        case 117l: retval = "mips_divu"; break;
        case 118l: retval = "mips_ehb"; break;
        case 119l: retval = "mips_ei"; break;
        case 120l: retval = "mips_eret"; break;
        case 121l: retval = "mips_ext"; break;
        case 122l: retval = "mips_floor_l_s"; break;
        case 123l: retval = "mips_floor_l_d"; break;
        case 124l: retval = "mips_floor_w_s"; break;
        case 125l: retval = "mips_floor_w_d"; break;
        case 126l: retval = "mips_ins"; break;
        case 127l: retval = "mips_j"; break;
        case 128l: retval = "mips_jal"; break;
        case 129l: retval = "mips_jalr"; break;
        case 130l: retval = "mips_jalr_hb"; break;
        case 131l: retval = "mips_jalx"; break;
        case 132l: retval = "mips_jr"; break;
        case 133l: retval = "mips_jr_hb"; break;
        case 134l: retval = "mips_lb"; break;
        case 135l: retval = "mips_lbe"; break;
        case 136l: retval = "mips_lbu"; break;
        case 137l: retval = "mips_lbue"; break;
        case 138l: retval = "mips_ldc1"; break;
        case 139l: retval = "mips_ldc2"; break;
        case 140l: retval = "mips_ldxc1"; break;
        case 141l: retval = "mips_lh"; break;
        case 142l: retval = "mips_lhe"; break;
        case 143l: retval = "mips_lhu"; break;
        case 144l: retval = "mips_lhue"; break;
        case 145l: retval = "mips_ll"; break;
        case 146l: retval = "mips_lle"; break;
        case 147l: retval = "mips_lui"; break;
        case 148l: retval = "mips_luxc1"; break;
        case 149l: retval = "mips_lw"; break;
        case 150l: retval = "mips_lwc1"; break;
        case 151l: retval = "mips_lwc2"; break;
        case 152l: retval = "mips_lwe"; break;
        case 153l: retval = "mips_lwl"; break;
        case 154l: retval = "mips_lwle"; break;
        case 155l: retval = "mips_lwr"; break;
        case 156l: retval = "mips_lwre"; break;
        case 157l: retval = "mips_lwxc1"; break;
        case 158l: retval = "mips_madd"; break;
        case 159l: retval = "mips_madd_s"; break;
        case 160l: retval = "mips_madd_d"; break;
        case 161l: retval = "mips_madd_ps"; break;
        case 162l: retval = "mips_maddu"; break;
        case 163l: retval = "mips_mfc0"; break;
        case 164l: retval = "mips_mfc1"; break;
        case 165l: retval = "mips_mfc2"; break;
        case 166l: retval = "mips_mfhc1"; break;
        case 167l: retval = "mips_mfhc2"; break;
        case 168l: retval = "mips_mfhi"; break;
        case 169l: retval = "mips_mflo"; break;
        case 170l: retval = "mips_mov_s"; break;
        case 171l: retval = "mips_mov_d"; break;
        case 172l: retval = "mips_mov_ps"; break;
        case 173l: retval = "mips_movf"; break;
        case 174l: retval = "mips_movf_s"; break;
        case 175l: retval = "mips_movf_d"; break;
        case 176l: retval = "mips_movf_ps"; break;
        case 177l: retval = "mips_movn"; break;
        case 178l: retval = "mips_movn_s"; break;
        case 179l: retval = "mips_movn_d"; break;
        case 180l: retval = "mips_movn_ps"; break;
        case 181l: retval = "mips_movt"; break;
        case 182l: retval = "mips_movt_s"; break;
        case 183l: retval = "mips_movt_d"; break;
        case 184l: retval = "mips_movt_ps"; break;
        case 185l: retval = "mips_movz"; break;
        case 186l: retval = "mips_movz_s"; break;
        case 187l: retval = "mips_movz_d"; break;
        case 188l: retval = "mips_movz_ps"; break;
        case 189l: retval = "mips_msub"; break;
        case 190l: retval = "mips_msub_s"; break;
        case 191l: retval = "mips_msub_d"; break;
        case 192l: retval = "mips_msub_ps"; break;
        case 193l: retval = "mips_msubu"; break;
        case 194l: retval = "mips_mtc0"; break;
        case 195l: retval = "mips_mtc1"; break;
        case 196l: retval = "mips_mtc2"; break;
        case 197l: retval = "mips_mthc1"; break;
        case 198l: retval = "mips_mthc2"; break;
        case 199l: retval = "mips_mthi"; break;
        case 200l: retval = "mips_mtlo"; break;
        case 201l: retval = "mips_mul"; break;
        case 202l: retval = "mips_mul_s"; break;
        case 203l: retval = "mips_mul_d"; break;
        case 204l: retval = "mips_mul_ps"; break;
        case 205l: retval = "mips_mult"; break;
        case 206l: retval = "mips_multu"; break;
        case 207l: retval = "mips_neg_s"; break;
        case 208l: retval = "mips_neg_d"; break;
        case 209l: retval = "mips_neg_ps"; break;
        case 210l: retval = "mips_nmadd_s"; break;
        case 211l: retval = "mips_nmadd_d"; break;
        case 212l: retval = "mips_nmadd_ps"; break;
        case 213l: retval = "mips_nmsub_s"; break;
        case 214l: retval = "mips_nmsub_d"; break;
        case 215l: retval = "mips_nmsub_ps"; break;
        case 216l: retval = "mips_nop"; break;
        case 217l: retval = "mips_nor"; break;
        case 218l: retval = "mips_or"; break;
        case 219l: retval = "mips_ori"; break;
        case 220l: retval = "mips_pause"; break;
        case 221l: retval = "mips_pll_ps"; break;
        case 222l: retval = "mips_plu_ps"; break;
        case 223l: retval = "mips_pref"; break;
        case 224l: retval = "mips_prefe"; break;
        case 225l: retval = "mips_prefx"; break;
        case 226l: retval = "mips_pul_ps"; break;
        case 227l: retval = "mips_puu_ps"; break;
        case 228l: retval = "mips_rdhwr"; break;
        case 229l: retval = "mips_rdpgpr"; break;
        case 230l: retval = "mips_recip_s"; break;
        case 231l: retval = "mips_recip_d"; break;
        case 232l: retval = "mips_rotr"; break;
        case 233l: retval = "mips_rotrv"; break;
        case 234l: retval = "mips_round_l_s"; break;
        case 235l: retval = "mips_round_l_d"; break;
        case 236l: retval = "mips_round_w_s"; break;
        case 237l: retval = "mips_round_w_d"; break;
        case 238l: retval = "mips_rsqrt_s"; break;
        case 239l: retval = "mips_rsqrt_d"; break;
        case 240l: retval = "mips_sb"; break;
        case 241l: retval = "mips_sbe"; break;
        case 242l: retval = "mips_sc"; break;
        case 243l: retval = "mips_sce"; break;
        case 244l: retval = "mips_sdc1"; break;
        case 245l: retval = "mips_sdc2"; break;
        case 246l: retval = "mips_sdxc1"; break;
        case 247l: retval = "mips_seb"; break;
        case 248l: retval = "mips_seh"; break;
        case 249l: retval = "mips_sh"; break;
        case 250l: retval = "mips_she"; break;
        case 251l: retval = "mips_sll"; break;
        case 252l: retval = "mips_sllv"; break;
        case 253l: retval = "mips_slt"; break;
        case 254l: retval = "mips_slti"; break;
        case 255l: retval = "mips_sltiu"; break;
        case 256l: retval = "mips_sltu"; break;
        case 257l: retval = "mips_sqrt_s"; break;
        case 258l: retval = "mips_sqrt_d"; break;
        case 259l: retval = "mips_sra"; break;
        case 260l: retval = "mips_srav"; break;
        case 261l: retval = "mips_srl"; break;
        case 262l: retval = "mips_srlv"; break;
        case 263l: retval = "mips_ssnop"; break;
        case 264l: retval = "mips_sub"; break;
        case 265l: retval = "mips_sub_s"; break;
        case 266l: retval = "mips_sub_d"; break;
        case 267l: retval = "mips_sub_ps"; break;
        case 268l: retval = "mips_subu"; break;
        case 269l: retval = "mips_suxc1"; break;
        case 270l: retval = "mips_sw"; break;
        case 271l: retval = "mips_swc1"; break;
        case 272l: retval = "mips_swc2"; break;
        case 273l: retval = "mips_swe"; break;
        case 274l: retval = "mips_swl"; break;
        case 275l: retval = "mips_swle"; break;
        case 276l: retval = "mips_swr"; break;
        case 277l: retval = "mips_swre"; break;
        case 278l: retval = "mips_swxc1"; break;
        case 279l: retval = "mips_sync"; break;
        case 280l: retval = "mips_synci"; break;
        case 281l: retval = "mips_syscall"; break;
        case 282l: retval = "mips_teq"; break;
        case 283l: retval = "mips_teqi"; break;
        case 284l: retval = "mips_tge"; break;
        case 285l: retval = "mips_tgei"; break;
        case 286l: retval = "mips_tgeiu"; break;
        case 287l: retval = "mips_tgeu"; break;
        case 288l: retval = "mips_tlbinv"; break;
        case 289l: retval = "mips_tlbinvf"; break;
        case 290l: retval = "mips_tlbp"; break;
        case 291l: retval = "mips_tlbr"; break;
        case 292l: retval = "mips_tlbwi"; break;
        case 293l: retval = "mips_tlbwr"; break;
        case 294l: retval = "mips_tlt"; break;
        case 295l: retval = "mips_tlti"; break;
        case 296l: retval = "mips_tltiu"; break;
        case 297l: retval = "mips_tltu"; break;
        case 298l: retval = "mips_tne"; break;
        case 299l: retval = "mips_tnei"; break;
        case 300l: retval = "mips_trunc_l_s"; break;
        case 301l: retval = "mips_trunc_l_d"; break;
        case 302l: retval = "mips_trunc_w_s"; break;
        case 303l: retval = "mips_trunc_w_d"; break;
        case 304l: retval = "mips_wait"; break;
        case 305l: retval = "mips_wrpgpr"; break;
        case 306l: retval = "mips_wsbh"; break;
        case 307l: retval = "mips_xor"; break;
        case 308l: retval = "mips_xori"; break;
        case 309l: retval = "mips_last_instruction"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MipsInstructionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsRegisterClass is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsMips.h:6
/** Converts an enum of type MipsRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsRegisterClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "mips_regclass_gpr"; break;
        case 1l: retval = "mips_regclass_spr"; break;
        case 2l: retval = "mips_regclass_fpr"; break;
        case 3l: retval = "mips_regclass_fcsr"; break;
        case 4l: retval = "mips_regclass_cp0gpr"; break;
        case 5l: retval = "mips_regclass_cp2gpr"; break;
        case 6l: retval = "mips_regclass_cp2spr"; break;
        case 7l: retval = "mips_regclass_sgpr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MipsRegisterClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsSpecialPurposeRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsMips.h:26
/** Converts an enum of type MipsSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsSpecialPurposeRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "mips_spr_hi"; break;
        case 1l: retval = "mips_spr_lo"; break;
        case 2l: retval = "mips_spr_pc"; break;
        case 3l: retval = "mips_spr_fir"; break;
        case 4l: retval = "mips_spr_fcsr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(MipsSpecialPurposeRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Mode is defined at mounts/GS-CAD/ROSE/sources/devel/src/rose-config.C:27
/** Converts an enum of type Mode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "BUILD"; break;
        case 1l: retval = "INSTALLED"; break;
        case 2l: retval = "NMODES"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Mode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Mode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NFAAssertion is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h:64
/** Converts an enum of type NFAAssertion to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNFAAssertion(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NoAssertion"; break;
        case 1l: retval = "ZeroOrOne"; break;
        case 2l: retval = "ZeroOrMore"; break;
        case 4l: retval = "OneOrMore"; break;
        case 8l: retval = "WordStart"; break;
        case 16l: retval = "WordEnd"; break;
        case 32l: retval = "Word"; break;
        case 64l: retval = "NonWord"; break;
        case 128l: retval = "Digit"; break;
        case 256l: retval = "NonDigit"; break;
        case 512l: retval = "Space"; break;
        case 1024l: retval = "NonSpace"; break;
        case 2048l: retval = "CaseSensitive"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NFAAssertion)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NFAAssertion::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NFAType is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h:43
/** Converts an enum of type NFAType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNFAType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Char"; break;
        case 1l: retval = "Match"; break;
        case 2l: retval = "CxtBeg"; break;
        case 3l: retval = "ContextBegin"; break;
        case 4l: retval = "CxtEnd"; break;
        case 5l: retval = "ContextEnd"; break;
        case 8l: retval = "CxtEsc"; break;
        case 9l: retval = "EscapeSeq"; break;
        case 16l: retval = "Escaped"; break;
        case 32l: retval = "Exclusive"; break;
        case 64l: retval = "StayOnLine"; break;
        case 128l: retval = "Reserved"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NFAType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NFAType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NameQuery::TypeOfQueryTypeOneParameter is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/nameQuery.h:75
/** Converts an enum of type NameQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNameQueryTypeOfQueryTypeOneParameter(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementType"; break;
        case 1l: retval = "VariableNames"; break;
        case 2l: retval = "VariableTypeNames"; break;
        case 3l: retval = "FunctionDeclarationNames"; break;
        case 4l: retval = "MemberFunctionDeclarationNames"; break;
        case 5l: retval = "ClassDeclarationNames"; break;
        case 6l: retval = "ArgumentNames"; break;
        case 7l: retval = "ClassFieldNames"; break;
        case 8l: retval = "UnionFieldNames"; break;
        case 9l: retval = "StructFieldNames"; break;
        case 10l: retval = "FunctionReferenceNames"; break;
        case 11l: retval = "StructNames"; break;
        case 12l: retval = "UnionNames"; break;
        case 13l: retval = "TypedefDeclarationNames"; break;
        case 14l: retval = "TypeNames"; break;
        case 15l: retval = "END_OF_NAME_TYPE_LIST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NameQuery::TypeOfQueryTypeOneParameter)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NameQuery::TypeOfQueryTypeTwoParameters is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/nameQuery.h:95
/** Converts an enum of type NameQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNameQueryTypeOfQueryTypeTwoParameters(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1l: retval = "VariableNamesWithTypeName"; break;
        case 2l: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NameQuery::TypeOfQueryTypeTwoParameters)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NodeQuery::TypeOfQueryTypeOneParameter is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/nodeQuery.h:134
/** Converts an enum of type NodeQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNodeQueryTypeOfQueryTypeOneParameter(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementType"; break;
        case 1l: retval = "VariableDeclarations"; break;
        case 2l: retval = "VariableTypes"; break;
        case 3l: retval = "FunctionDeclarations"; break;
        case 4l: retval = "MemberFunctionDeclarations"; break;
        case 5l: retval = "ClassDeclarations"; break;
        case 6l: retval = "StructDeclarations"; break;
        case 7l: retval = "UnionDeclarations"; break;
        case 8l: retval = "Arguments"; break;
        case 9l: retval = "ClassFields"; break;
        case 10l: retval = "StructFields"; break;
        case 11l: retval = "UnionFields"; break;
        case 12l: retval = "StructDefinitions"; break;
        case 13l: retval = "TypedefDeclarations"; break;
        case 14l: retval = "AnonymousTypedefs"; break;
        case 15l: retval = "AnonymousTypedefClassDeclarations"; break;
        case 16l: retval = "END_OF_NODE_TYPE_LIST_ONE_PARAMETER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NodeQuery::TypeOfQueryTypeOneParameter)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NodeQuery::TypeOfQueryTypeTwoParameters is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/nodeQuery.h:155
/** Converts an enum of type NodeQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNodeQueryTypeOfQueryTypeTwoParameters(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1l: retval = "FunctionDeclarationFromDefinition"; break;
        case 2l: retval = "ClassDeclarationFromName"; break;
        case 3l: retval = "ClassDeclarationsFromTypeName"; break;
        case 4l: retval = "PragmaDeclarationFromName"; break;
        case 5l: retval = "VariableDeclarationFromName"; break;
        case 6l: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NodeQuery::TypeOfQueryTypeTwoParameters)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NumberQuery::TypeOfQueryTypeOneParameter is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/numberQuery.h:11
/** Converts an enum of type NumberQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNumberQueryTypeOfQueryTypeOneParameter(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementType"; break;
        case 1l: retval = "NumberOfArgsInConstructor"; break;
        case 2l: retval = "NumberOfOperands"; break;
        case 3l: retval = "NumberOfArgsInScalarIndexingOperator"; break;
        case 4l: retval = "END_OF_NODE_TYPE_LIST_ONE_PARAMETER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NumberQuery::TypeOfQueryTypeOneParameter)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NumberQuery::TypeOfQueryTypeTwoParameters is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astQuery/numberQuery.h:20
/** Converts an enum of type NumberQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNumberQueryTypeOfQueryTypeTwoParameters(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1l: retval = "NumberOfArgsInParanthesisOperator"; break;
        case 2l: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(NumberQuery::TypeOfQueryTypeTwoParameters)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// OmpSupport::omp_construct_enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/OmpAttribute.h:27
/** Converts an enum of type OmpSupport::omp_construct_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyOmpSupport_omp_construct_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_parallel"; break;
        case 2l: retval = "e_for"; break;
        case 3l: retval = "e_do"; break;
        case 4l: retval = "e_workshare"; break;
        case 5l: retval = "e_sections"; break;
        case 6l: retval = "e_section"; break;
        case 7l: retval = "e_single"; break;
        case 8l: retval = "e_master"; break;
        case 9l: retval = "e_critical"; break;
        case 10l: retval = "e_barrier"; break;
        case 11l: retval = "e_atomic"; break;
        case 12l: retval = "e_flush"; break;
        case 13l: retval = "e_target"; break;
        case 14l: retval = "e_target_declare"; break;
        case 15l: retval = "e_target_data"; break;
        case 16l: retval = "e_target_update"; break;
        case 17l: retval = "e_map"; break;
        case 18l: retval = "e_device"; break;
        case 19l: retval = "e_begin"; break;
        case 20l: retval = "e_end"; break;
        case 21l: retval = "e_threadprivate"; break;
        case 22l: retval = "e_parallel_for"; break;
        case 23l: retval = "e_parallel_do"; break;
        case 24l: retval = "e_parallel_sections"; break;
        case 25l: retval = "e_parallel_workshare"; break;
        case 26l: retval = "e_task"; break;
        case 27l: retval = "e_taskwait"; break;
        case 28l: retval = "e_ordered_directive"; break;
        case 29l: retval = "e_end_critical"; break;
        case 30l: retval = "e_end_do"; break;
        case 31l: retval = "e_end_master"; break;
        case 32l: retval = "e_end_ordered"; break;
        case 33l: retval = "e_end_parallel_do"; break;
        case 34l: retval = "e_end_parallel_sections"; break;
        case 35l: retval = "e_end_parallel_workshare"; break;
        case 36l: retval = "e_end_parallel"; break;
        case 37l: retval = "e_end_sections"; break;
        case 38l: retval = "e_end_single"; break;
        case 39l: retval = "e_end_task"; break;
        case 40l: retval = "e_end_workshare"; break;
        case 41l: retval = "e_default"; break;
        case 42l: retval = "e_shared"; break;
        case 43l: retval = "e_private"; break;
        case 44l: retval = "e_firstprivate"; break;
        case 45l: retval = "e_lastprivate"; break;
        case 46l: retval = "e_copyin"; break;
        case 47l: retval = "e_copyprivate"; break;
        case 48l: retval = "e_if"; break;
        case 49l: retval = "e_num_threads"; break;
        case 50l: retval = "e_nowait"; break;
        case 51l: retval = "e_ordered_clause"; break;
        case 52l: retval = "e_reduction"; break;
        case 53l: retval = "e_schedule"; break;
        case 54l: retval = "e_collapse"; break;
        case 55l: retval = "e_untied"; break;
        case 56l: retval = "e_default_none"; break;
        case 57l: retval = "e_default_shared"; break;
        case 58l: retval = "e_default_private"; break;
        case 59l: retval = "e_default_firstprivate"; break;
        case 60l: retval = "e_reduction_plus"; break;
        case 61l: retval = "e_reduction_mul"; break;
        case 62l: retval = "e_reduction_minus"; break;
        case 63l: retval = "e_reduction_bitand"; break;
        case 64l: retval = "e_reduction_bitor"; break;
        case 65l: retval = "e_reduction_bitxor"; break;
        case 66l: retval = "e_reduction_logand"; break;
        case 67l: retval = "e_reduction_logor"; break;
        case 68l: retval = "e_reduction_and"; break;
        case 69l: retval = "e_reduction_or"; break;
        case 70l: retval = "e_reduction_eqv"; break;
        case 71l: retval = "e_reduction_neqv"; break;
        case 72l: retval = "e_reduction_max"; break;
        case 73l: retval = "e_reduction_min"; break;
        case 74l: retval = "e_reduction_iand"; break;
        case 75l: retval = "e_reduction_ior"; break;
        case 76l: retval = "e_reduction_ieor"; break;
        case 77l: retval = "e_schedule_none"; break;
        case 78l: retval = "e_schedule_static"; break;
        case 79l: retval = "e_schedule_dynamic"; break;
        case 80l: retval = "e_schedule_guided"; break;
        case 81l: retval = "e_schedule_auto"; break;
        case 82l: retval = "e_schedule_runtime"; break;
        case 83l: retval = "e_map_alloc"; break;
        case 84l: retval = "e_map_to"; break;
        case 85l: retval = "e_map_from"; break;
        case 86l: retval = "e_map_tofrom"; break;
        case 87l: retval = "e_dist_data"; break;
        case 88l: retval = "e_duplicate"; break;
        case 89l: retval = "e_block"; break;
        case 90l: retval = "e_cyclic"; break;
        case 91l: retval = "e_simd"; break;
        case 92l: retval = "e_safelen"; break;
        case 93l: retval = "e_uniform"; break;
        case 94l: retval = "e_aligned"; break;
        case 95l: retval = "e_linear"; break;
        case 96l: retval = "e_not_omp"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(OmpSupport::omp_construct_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "OmpSupport::omp_construct_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// OmpSupport::omp_rtl_enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programTransformation/ompLowering/omp_lowering.h:35
/** Converts an enum of type OmpSupport::omp_rtl_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyOmpSupport_omp_rtl_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_gomp"; break;
        case 1l: retval = "e_omni"; break;
        case 2l: retval = "e_last_rtl"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(OmpSupport::omp_rtl_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "OmpSupport::omp_rtl_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcConditionRegisterAccessGranularity is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/powerpcInstructionEnum.h:471
/** Converts an enum of type PowerpcConditionRegisterAccessGranularity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcConditionRegisterAccessGranularity(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "powerpc_condreggranularity_whole"; break;
        case 1l: retval = "powerpc_condreggranularity_field"; break;
        case 2l: retval = "powerpc_condreggranularity_bit"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PowerpcConditionRegisterAccessGranularity)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcConditionRegisterAccessGranularity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcInstructionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/powerpcInstructionEnum.h:9
/** Converts an enum of type PowerpcInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcInstructionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "powerpc_unknown_instruction"; break;
        case 1l: retval = "powerpc_add"; break;
        case 2l: retval = "powerpc_add_record"; break;
        case 3l: retval = "powerpc_addo"; break;
        case 4l: retval = "powerpc_addo_record"; break;
        case 5l: retval = "powerpc_addc"; break;
        case 6l: retval = "powerpc_addc_record"; break;
        case 7l: retval = "powerpc_addco"; break;
        case 8l: retval = "powerpc_addco_record"; break;
        case 9l: retval = "powerpc_adde"; break;
        case 10l: retval = "powerpc_adde_record"; break;
        case 11l: retval = "powerpc_addeo"; break;
        case 12l: retval = "powerpc_addeo_record"; break;
        case 13l: retval = "powerpc_addi"; break;
        case 14l: retval = "powerpc_addic"; break;
        case 15l: retval = "powerpc_addic_record"; break;
        case 16l: retval = "powerpc_addis"; break;
        case 17l: retval = "powerpc_addme"; break;
        case 18l: retval = "powerpc_addme_record"; break;
        case 19l: retval = "powerpc_addmeo"; break;
        case 20l: retval = "powerpc_addmeo_record"; break;
        case 21l: retval = "powerpc_addze"; break;
        case 22l: retval = "powerpc_addze_record"; break;
        case 23l: retval = "powerpc_addzeo"; break;
        case 24l: retval = "powerpc_addzeo_record"; break;
        case 25l: retval = "powerpc_and"; break;
        case 26l: retval = "powerpc_and_record"; break;
        case 27l: retval = "powerpc_andc"; break;
        case 28l: retval = "powerpc_andc_record"; break;
        case 29l: retval = "powerpc_andi_record"; break;
        case 30l: retval = "powerpc_andis_record"; break;
        case 31l: retval = "powerpc_b"; break;
        case 32l: retval = "powerpc_ba"; break;
        case 33l: retval = "powerpc_bl"; break;
        case 34l: retval = "powerpc_bla"; break;
        case 35l: retval = "powerpc_bc"; break;
        case 36l: retval = "powerpc_bca"; break;
        case 37l: retval = "powerpc_bcl"; break;
        case 38l: retval = "powerpc_bcla"; break;
        case 39l: retval = "powerpc_bcctr"; break;
        case 40l: retval = "powerpc_bcctrl"; break;
        case 41l: retval = "powerpc_bclr"; break;
        case 42l: retval = "powerpc_bclrl"; break;
        case 43l: retval = "powerpc_cmp"; break;
        case 44l: retval = "powerpc_cmpi"; break;
        case 45l: retval = "powerpc_cmpl"; break;
        case 46l: retval = "powerpc_cmpli"; break;
        case 47l: retval = "powerpc_cntlzd"; break;
        case 48l: retval = "powerpc_cntlzd_record"; break;
        case 49l: retval = "powerpc_cntlzw"; break;
        case 50l: retval = "powerpc_cntlzw_record"; break;
        case 51l: retval = "powerpc_crand"; break;
        case 52l: retval = "powerpc_crandc"; break;
        case 53l: retval = "powerpc_creqv"; break;
        case 54l: retval = "powerpc_crnand"; break;
        case 55l: retval = "powerpc_crnor"; break;
        case 56l: retval = "powerpc_cror"; break;
        case 57l: retval = "powerpc_crorc"; break;
        case 58l: retval = "powerpc_crxor"; break;
        case 59l: retval = "powerpc_dcbf"; break;
        case 60l: retval = "powerpc_dcba"; break;
        case 61l: retval = "powerpc_dcbi"; break;
        case 62l: retval = "powerpc_dcbst"; break;
        case 63l: retval = "powerpc_dcbt"; break;
        case 64l: retval = "powerpc_dcbtst"; break;
        case 65l: retval = "powerpc_dcbz"; break;
        case 66l: retval = "powerpc_divd"; break;
        case 67l: retval = "powerpc_divd_record"; break;
        case 68l: retval = "powerpc_divdo"; break;
        case 69l: retval = "powerpc_divdo_record"; break;
        case 70l: retval = "powerpc_divdu"; break;
        case 71l: retval = "powerpc_divdu_record"; break;
        case 72l: retval = "powerpc_divduo"; break;
        case 73l: retval = "powerpc_divduo_record"; break;
        case 74l: retval = "powerpc_divw"; break;
        case 75l: retval = "powerpc_divw_record"; break;
        case 76l: retval = "powerpc_divwo"; break;
        case 77l: retval = "powerpc_divwo_record"; break;
        case 78l: retval = "powerpc_divwu"; break;
        case 79l: retval = "powerpc_divwu_record"; break;
        case 80l: retval = "powerpc_divwuo"; break;
        case 81l: retval = "powerpc_divwuo_record"; break;
        case 82l: retval = "powerpc_dst"; break;
        case 83l: retval = "powerpc_dstt"; break;
        case 84l: retval = "powerpc_dstst"; break;
        case 85l: retval = "powerpc_dststt"; break;
        case 86l: retval = "powerpc_dss"; break;
        case 87l: retval = "powerpc_dssall"; break;
        case 88l: retval = "powerpc_eciwx"; break;
        case 89l: retval = "powerpc_ecowx"; break;
        case 90l: retval = "powerpc_eieio"; break;
        case 91l: retval = "powerpc_eqv"; break;
        case 92l: retval = "powerpc_eqv_record"; break;
        case 93l: retval = "powerpc_extsb"; break;
        case 94l: retval = "powerpc_extsb_record"; break;
        case 95l: retval = "powerpc_extsh"; break;
        case 96l: retval = "powerpc_extsh_record"; break;
        case 97l: retval = "powerpc_extsw"; break;
        case 98l: retval = "powerpc_extsw_record"; break;
        case 99l: retval = "powerpc_fabs"; break;
        case 100l: retval = "powerpc_fabs_record"; break;
        case 101l: retval = "powerpc_fadd"; break;
        case 102l: retval = "powerpc_fadd_record"; break;
        case 103l: retval = "powerpc_fadds"; break;
        case 104l: retval = "powerpc_fadds_record"; break;
        case 105l: retval = "powerpc_fcfid"; break;
        case 106l: retval = "powerpc_fcfid_record"; break;
        case 107l: retval = "powerpc_fcmpo"; break;
        case 108l: retval = "powerpc_fcmpu"; break;
        case 109l: retval = "powerpc_fctid"; break;
        case 110l: retval = "powerpc_fctid_record"; break;
        case 111l: retval = "powerpc_fctidz"; break;
        case 112l: retval = "powerpc_fctidz_record"; break;
        case 113l: retval = "powerpc_fctiw"; break;
        case 114l: retval = "powerpc_fctiw_record"; break;
        case 115l: retval = "powerpc_fctiwz"; break;
        case 116l: retval = "powerpc_fctiwz_record"; break;
        case 117l: retval = "powerpc_fdiv"; break;
        case 118l: retval = "powerpc_fdiv_record"; break;
        case 119l: retval = "powerpc_fdivs"; break;
        case 120l: retval = "powerpc_fdivs_record"; break;
        case 121l: retval = "powerpc_fmadd"; break;
        case 122l: retval = "powerpc_fmadd_record"; break;
        case 123l: retval = "powerpc_fmadds"; break;
        case 124l: retval = "powerpc_fmadds_record"; break;
        case 125l: retval = "powerpc_fmr"; break;
        case 126l: retval = "powerpc_fmr_record"; break;
        case 127l: retval = "powerpc_fmsub"; break;
        case 128l: retval = "powerpc_fmsub_record"; break;
        case 129l: retval = "powerpc_fmsubs"; break;
        case 130l: retval = "powerpc_fmsubs_record"; break;
        case 131l: retval = "powerpc_fmul"; break;
        case 132l: retval = "powerpc_fmul_record"; break;
        case 133l: retval = "powerpc_fmuls"; break;
        case 134l: retval = "powerpc_fmuls_record"; break;
        case 135l: retval = "powerpc_fnabs"; break;
        case 136l: retval = "powerpc_fnabs_record"; break;
        case 137l: retval = "powerpc_fneg"; break;
        case 138l: retval = "powerpc_fneg_record"; break;
        case 139l: retval = "powerpc_fnmadd"; break;
        case 140l: retval = "powerpc_fnmadd_record"; break;
        case 141l: retval = "powerpc_fnmadds"; break;
        case 142l: retval = "powerpc_fnmadds_record"; break;
        case 143l: retval = "powerpc_fnmsub"; break;
        case 144l: retval = "powerpc_fnmsub_record"; break;
        case 145l: retval = "powerpc_fnmsubs"; break;
        case 146l: retval = "powerpc_fnmsubs_record"; break;
        case 147l: retval = "powerpc_fpmul"; break;
        case 148l: retval = "powerpc_fxmul"; break;
        case 149l: retval = "powerpc_fxpmul"; break;
        case 150l: retval = "powerpc_fxsmul"; break;
        case 151l: retval = "powerpc_fpadd"; break;
        case 152l: retval = "powerpc_fpsub"; break;
        case 153l: retval = "powerpc_fpre"; break;
        case 154l: retval = "powerpc_fprsqrte"; break;
        case 155l: retval = "powerpc_fpmr"; break;
        case 156l: retval = "powerpc_fpabs"; break;
        case 157l: retval = "powerpc_lfssx"; break;
        case 158l: retval = "powerpc_fpneg"; break;
        case 159l: retval = "powerpc_lfssux"; break;
        case 160l: retval = "powerpc_fprsp"; break;
        case 161l: retval = "powerpc_lfsdx"; break;
        case 162l: retval = "powerpc_fpnabs"; break;
        case 163l: retval = "powerpc_lfsdux"; break;
        case 164l: retval = "powerpc_lfxsx"; break;
        case 165l: retval = "powerpc_fsmr"; break;
        case 166l: retval = "powerpc_lfxsux"; break;
        case 167l: retval = "powerpc_lfxdx"; break;
        case 168l: retval = "powerpc_fsabs"; break;
        case 169l: retval = "powerpc_lfxdux"; break;
        case 170l: retval = "powerpc_lfpsx"; break;
        case 171l: retval = "powerpc_fsneg"; break;
        case 172l: retval = "powerpc_lfpsux"; break;
        case 173l: retval = "powerpc_lfpdx"; break;
        case 174l: retval = "powerpc_fsnabs"; break;
        case 175l: retval = "powerpc_lfpdux"; break;
        case 176l: retval = "powerpc_stfpiwx"; break;
        case 177l: retval = "powerpc_fxmr"; break;
        case 178l: retval = "powerpc_fpctiw"; break;
        case 179l: retval = "powerpc_stfssx"; break;
        case 180l: retval = "powerpc_stfssux"; break;
        case 181l: retval = "powerpc_fpctiwz"; break;
        case 182l: retval = "powerpc_stfsdx"; break;
        case 183l: retval = "powerpc_stfsdux"; break;
        case 184l: retval = "powerpc_stfxsx"; break;
        case 185l: retval = "powerpc_fsmtp"; break;
        case 186l: retval = "powerpc_stfxsux"; break;
        case 187l: retval = "powerpc_stfxdx"; break;
        case 188l: retval = "powerpc_stfxdux"; break;
        case 189l: retval = "powerpc_stfpsx"; break;
        case 190l: retval = "powerpc_fsmfp"; break;
        case 191l: retval = "powerpc_stfpsux"; break;
        case 192l: retval = "powerpc_stfpdx"; break;
        case 193l: retval = "powerpc_stfpdux"; break;
        case 194l: retval = "powerpc_fpsel"; break;
        case 195l: retval = "powerpc_fpmadd"; break;
        case 196l: retval = "powerpc_fpmsub"; break;
        case 197l: retval = "powerpc_fxmadd"; break;
        case 198l: retval = "powerpc_fxcpmadd"; break;
        case 199l: retval = "powerpc_fxcsmadd"; break;
        case 200l: retval = "powerpc_fpnmadd"; break;
        case 201l: retval = "powerpc_fxnmadd"; break;
        case 202l: retval = "powerpc_fxcpnmadd"; break;
        case 203l: retval = "powerpc_fxcsnmadd"; break;
        case 204l: retval = "powerpc_fxcpnpma"; break;
        case 205l: retval = "powerpc_fxmsub"; break;
        case 206l: retval = "powerpc_fxcsnpma"; break;
        case 207l: retval = "powerpc_fxcpmsub"; break;
        case 208l: retval = "powerpc_fxcpnsma"; break;
        case 209l: retval = "powerpc_fxcsmsub"; break;
        case 210l: retval = "powerpc_fxcsnsma"; break;
        case 211l: retval = "powerpc_fpnmsub"; break;
        case 212l: retval = "powerpc_fxcxma"; break;
        case 213l: retval = "powerpc_fxnmsub"; break;
        case 214l: retval = "powerpc_fxcxnpma"; break;
        case 215l: retval = "powerpc_fxcpnmsub"; break;
        case 216l: retval = "powerpc_fxcxnsma"; break;
        case 217l: retval = "powerpc_fxcsnmsub"; break;
        case 218l: retval = "powerpc_fxcxnms"; break;
        case 219l: retval = "powerpc_fre"; break;
        case 220l: retval = "powerpc_fre_record"; break;
        case 221l: retval = "powerpc_fres"; break;
        case 222l: retval = "powerpc_fres_record"; break;
        case 223l: retval = "powerpc_frsp"; break;
        case 224l: retval = "powerpc_frsp_record"; break;
        case 225l: retval = "powerpc_frsqrte"; break;
        case 226l: retval = "powerpc_frsqrte_record"; break;
        case 227l: retval = "powerpc_frsqrtes"; break;
        case 228l: retval = "powerpc_frsqrtes_record"; break;
        case 229l: retval = "powerpc_fsel"; break;
        case 230l: retval = "powerpc_fsel_record"; break;
        case 231l: retval = "powerpc_fsqrt"; break;
        case 232l: retval = "powerpc_fsqrt_record"; break;
        case 233l: retval = "powerpc_fsqrts"; break;
        case 234l: retval = "powerpc_fsqrts_record"; break;
        case 235l: retval = "powerpc_fsub"; break;
        case 236l: retval = "powerpc_fsub_record"; break;
        case 237l: retval = "powerpc_fsubs"; break;
        case 238l: retval = "powerpc_fsubs_record"; break;
        case 239l: retval = "powerpc_icbi"; break;
        case 240l: retval = "powerpc_isync"; break;
        case 241l: retval = "powerpc_lbz"; break;
        case 242l: retval = "powerpc_lbzu"; break;
        case 243l: retval = "powerpc_lbzux"; break;
        case 244l: retval = "powerpc_lbzx"; break;
        case 245l: retval = "powerpc_ld"; break;
        case 246l: retval = "powerpc_ldarx"; break;
        case 247l: retval = "powerpc_ldu"; break;
        case 248l: retval = "powerpc_ldux"; break;
        case 249l: retval = "powerpc_ldx"; break;
        case 250l: retval = "powerpc_lfd"; break;
        case 251l: retval = "powerpc_lfdu"; break;
        case 252l: retval = "powerpc_lfdux"; break;
        case 253l: retval = "powerpc_lfdx"; break;
        case 254l: retval = "powerpc_lfs"; break;
        case 255l: retval = "powerpc_lfsu"; break;
        case 256l: retval = "powerpc_lfsux"; break;
        case 257l: retval = "powerpc_lfsx"; break;
        case 258l: retval = "powerpc_lha"; break;
        case 259l: retval = "powerpc_lhau"; break;
        case 260l: retval = "powerpc_lhaux"; break;
        case 261l: retval = "powerpc_lhax"; break;
        case 262l: retval = "powerpc_lhbrx"; break;
        case 263l: retval = "powerpc_lhz"; break;
        case 264l: retval = "powerpc_lhzu"; break;
        case 265l: retval = "powerpc_lhzux"; break;
        case 266l: retval = "powerpc_lhzx"; break;
        case 267l: retval = "powerpc_lmw"; break;
        case 268l: retval = "powerpc_lswi"; break;
        case 269l: retval = "powerpc_lswx"; break;
        case 270l: retval = "powerpc_lwa"; break;
        case 271l: retval = "powerpc_lwarx"; break;
        case 272l: retval = "powerpc_lwaux"; break;
        case 273l: retval = "powerpc_lwax"; break;
        case 274l: retval = "powerpc_lwbrx"; break;
        case 275l: retval = "powerpc_lwz"; break;
        case 276l: retval = "powerpc_lwzu"; break;
        case 277l: retval = "powerpc_lwzux"; break;
        case 278l: retval = "powerpc_lwzx"; break;
        case 279l: retval = "powerpc_mcrf"; break;
        case 280l: retval = "powerpc_mcrfs"; break;
        case 281l: retval = "powerpc_mcrxr"; break;
        case 282l: retval = "powerpc_mfcr"; break;
        case 283l: retval = "powerpc_mffs"; break;
        case 284l: retval = "powerpc_mffs_record"; break;
        case 285l: retval = "powerpc_mfmsr"; break;
        case 286l: retval = "powerpc_mfspr"; break;
        case 287l: retval = "powerpc_mfsr"; break;
        case 288l: retval = "powerpc_mfsrin"; break;
        case 289l: retval = "powerpc_mftb"; break;
        case 290l: retval = "powerpc_mtcrf"; break;
        case 291l: retval = "powerpc_mtfsb0"; break;
        case 292l: retval = "powerpc_mtfsb0_record"; break;
        case 293l: retval = "powerpc_mtfsb1"; break;
        case 294l: retval = "powerpc_mtfsb1_record"; break;
        case 295l: retval = "powerpc_mtfsf"; break;
        case 296l: retval = "powerpc_mtfsf_record"; break;
        case 297l: retval = "powerpc_mtfsfi"; break;
        case 298l: retval = "powerpc_mtfsfi_record"; break;
        case 299l: retval = "powerpc_mtmsr"; break;
        case 300l: retval = "powerpc_mtmsrd"; break;
        case 301l: retval = "powerpc_mtspr"; break;
        case 302l: retval = "powerpc_mtsr"; break;
        case 303l: retval = "powerpc_mtsrd"; break;
        case 304l: retval = "powerpc_mtsrdin"; break;
        case 305l: retval = "powerpc_mtsrin"; break;
        case 306l: retval = "powerpc_mulhd"; break;
        case 307l: retval = "powerpc_mulhd_record"; break;
        case 308l: retval = "powerpc_mulhdu"; break;
        case 309l: retval = "powerpc_mulhdu_record"; break;
        case 310l: retval = "powerpc_mulhw"; break;
        case 311l: retval = "powerpc_mulhw_record"; break;
        case 312l: retval = "powerpc_mulhwu"; break;
        case 313l: retval = "powerpc_mulhwu_record"; break;
        case 314l: retval = "powerpc_mulld"; break;
        case 315l: retval = "powerpc_mulld_record"; break;
        case 316l: retval = "powerpc_mulldo"; break;
        case 317l: retval = "powerpc_mulldo_record"; break;
        case 318l: retval = "powerpc_mulli"; break;
        case 319l: retval = "powerpc_mullw"; break;
        case 320l: retval = "powerpc_mullw_record"; break;
        case 321l: retval = "powerpc_mullwo"; break;
        case 322l: retval = "powerpc_mullwo_record"; break;
        case 323l: retval = "powerpc_nand"; break;
        case 324l: retval = "powerpc_nand_record"; break;
        case 325l: retval = "powerpc_neg"; break;
        case 326l: retval = "powerpc_neg_record"; break;
        case 327l: retval = "powerpc_nego"; break;
        case 328l: retval = "powerpc_nego_record"; break;
        case 329l: retval = "powerpc_nor"; break;
        case 330l: retval = "powerpc_nor_record"; break;
        case 331l: retval = "powerpc_or"; break;
        case 332l: retval = "powerpc_or_record"; break;
        case 333l: retval = "powerpc_orc"; break;
        case 334l: retval = "powerpc_orc_record"; break;
        case 335l: retval = "powerpc_ori"; break;
        case 336l: retval = "powerpc_oris"; break;
        case 337l: retval = "powerpc_rfi"; break;
        case 338l: retval = "powerpc_rfid"; break;
        case 339l: retval = "powerpc_rldcl"; break;
        case 340l: retval = "powerpc_rldcl_record"; break;
        case 341l: retval = "powerpc_rldcr"; break;
        case 342l: retval = "powerpc_rldcr_record"; break;
        case 343l: retval = "powerpc_rldic"; break;
        case 344l: retval = "powerpc_rldic_record"; break;
        case 345l: retval = "powerpc_rldicl"; break;
        case 346l: retval = "powerpc_rldicl_record"; break;
        case 347l: retval = "powerpc_rldicr"; break;
        case 348l: retval = "powerpc_rldicr_record"; break;
        case 349l: retval = "powerpc_rldimi"; break;
        case 350l: retval = "powerpc_rldimi_record"; break;
        case 351l: retval = "powerpc_rlwimi"; break;
        case 352l: retval = "powerpc_rlwimi_record"; break;
        case 353l: retval = "powerpc_rlwinm"; break;
        case 354l: retval = "powerpc_rlwinm_record"; break;
        case 355l: retval = "powerpc_rlwnm"; break;
        case 356l: retval = "powerpc_rlwnm_record"; break;
        case 357l: retval = "powerpc_sc"; break;
        case 358l: retval = "powerpc_slbia"; break;
        case 359l: retval = "powerpc_slbie"; break;
        case 360l: retval = "powerpc_sld"; break;
        case 361l: retval = "powerpc_sld_record"; break;
        case 362l: retval = "powerpc_slw"; break;
        case 363l: retval = "powerpc_slw_record"; break;
        case 364l: retval = "powerpc_srad"; break;
        case 365l: retval = "powerpc_srad_record"; break;
        case 366l: retval = "powerpc_sradi"; break;
        case 367l: retval = "powerpc_sradi_record"; break;
        case 368l: retval = "powerpc_srd"; break;
        case 369l: retval = "powerpc_srd_record"; break;
        case 370l: retval = "powerpc_sraw"; break;
        case 371l: retval = "powerpc_sraw_record"; break;
        case 372l: retval = "powerpc_srawi"; break;
        case 373l: retval = "powerpc_srawi_record"; break;
        case 374l: retval = "powerpc_srw"; break;
        case 375l: retval = "powerpc_srw_record"; break;
        case 376l: retval = "powerpc_stb"; break;
        case 377l: retval = "powerpc_stbu"; break;
        case 378l: retval = "powerpc_stbux"; break;
        case 379l: retval = "powerpc_stbx"; break;
        case 380l: retval = "powerpc_std"; break;
        case 381l: retval = "powerpc_stdcx_record"; break;
        case 382l: retval = "powerpc_stdu"; break;
        case 383l: retval = "powerpc_stdux"; break;
        case 384l: retval = "powerpc_stdx"; break;
        case 385l: retval = "powerpc_stfd"; break;
        case 386l: retval = "powerpc_stfdu"; break;
        case 387l: retval = "powerpc_stfdux"; break;
        case 388l: retval = "powerpc_stfdx"; break;
        case 389l: retval = "powerpc_stfiwx"; break;
        case 390l: retval = "powerpc_stfs"; break;
        case 391l: retval = "powerpc_stfsu"; break;
        case 392l: retval = "powerpc_stfsux"; break;
        case 393l: retval = "powerpc_stfsx"; break;
        case 394l: retval = "powerpc_sth"; break;
        case 395l: retval = "powerpc_sthbrx"; break;
        case 396l: retval = "powerpc_sthu"; break;
        case 397l: retval = "powerpc_sthux"; break;
        case 398l: retval = "powerpc_sthx"; break;
        case 399l: retval = "powerpc_stmw"; break;
        case 400l: retval = "powerpc_stswi"; break;
        case 401l: retval = "powerpc_stswx"; break;
        case 402l: retval = "powerpc_stw"; break;
        case 403l: retval = "powerpc_stwbrx"; break;
        case 404l: retval = "powerpc_stwcx_record"; break;
        case 405l: retval = "powerpc_stwu"; break;
        case 406l: retval = "powerpc_stwux"; break;
        case 407l: retval = "powerpc_stwx"; break;
        case 408l: retval = "powerpc_subf"; break;
        case 409l: retval = "powerpc_subf_record"; break;
        case 410l: retval = "powerpc_subfo"; break;
        case 411l: retval = "powerpc_subfo_record"; break;
        case 412l: retval = "powerpc_subfc"; break;
        case 413l: retval = "powerpc_subfc_record"; break;
        case 414l: retval = "powerpc_subfco"; break;
        case 415l: retval = "powerpc_subfco_record"; break;
        case 416l: retval = "powerpc_subfe"; break;
        case 417l: retval = "powerpc_subfe_record"; break;
        case 418l: retval = "powerpc_subfeo"; break;
        case 419l: retval = "powerpc_subfeo_record"; break;
        case 420l: retval = "powerpc_subfic"; break;
        case 421l: retval = "powerpc_subfme"; break;
        case 422l: retval = "powerpc_subfme_record"; break;
        case 423l: retval = "powerpc_subfmeo"; break;
        case 424l: retval = "powerpc_subfmeo_record"; break;
        case 425l: retval = "powerpc_subfze"; break;
        case 426l: retval = "powerpc_subfze_record"; break;
        case 427l: retval = "powerpc_subfzeo"; break;
        case 428l: retval = "powerpc_subfzeo_record"; break;
        case 429l: retval = "powerpc_sync"; break;
        case 430l: retval = "powerpc_td"; break;
        case 431l: retval = "powerpc_tdi"; break;
        case 432l: retval = "powerpc_tlbia"; break;
        case 433l: retval = "powerpc_tlbie"; break;
        case 434l: retval = "powerpc_tlbsync"; break;
        case 435l: retval = "powerpc_tw"; break;
        case 436l: retval = "powerpc_twi"; break;
        case 437l: retval = "powerpc_xor"; break;
        case 438l: retval = "powerpc_xor_record"; break;
        case 439l: retval = "powerpc_xori"; break;
        case 440l: retval = "powerpc_xoris"; break;
        case 441l: retval = "powerpc_last_instruction"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PowerpcInstructionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcRegisterClass is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/powerpcInstructionEnum.h:455
/** Converts an enum of type PowerpcRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcRegisterClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "powerpc_regclass_unknown"; break;
        case 1l: retval = "powerpc_regclass_gpr"; break;
        case 2l: retval = "powerpc_regclass_fpr"; break;
        case 3l: retval = "powerpc_regclass_cr"; break;
        case 4l: retval = "powerpc_regclass_fpscr"; break;
        case 5l: retval = "powerpc_regclass_spr"; break;
        case 6l: retval = "powerpc_regclass_tbr"; break;
        case 7l: retval = "powerpc_regclass_msr"; break;
        case 8l: retval = "powerpc_regclass_sr"; break;
        case 9l: retval = "powerpc_regclass_iar"; break;
        case 10l: retval = "powerpc_regclass_pvr"; break;
        case 11l: retval = "powerpc_last_register_class"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PowerpcRegisterClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcSpecialPurposeRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/powerpcInstructionEnum.h:478
/** Converts an enum of type PowerpcSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcSpecialPurposeRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "powerpc_spr_xer"; break;
        case 8l: retval = "powerpc_spr_lr"; break;
        case 9l: retval = "powerpc_spr_ctr"; break;
        case 18l: retval = "powerpc_spr_dsisr"; break;
        case 19l: retval = "powerpc_spr_dar"; break;
        case 22l: retval = "powerpc_spr_dec"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PowerpcSpecialPurposeRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcTimeBaseRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/powerpcInstructionEnum.h:488
/** Converts an enum of type PowerpcTimeBaseRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcTimeBaseRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 268l: retval = "powerpc_tbr_tbl"; break;
        case 269l: retval = "powerpc_tbr_tbu"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PowerpcTimeBaseRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcTimeBaseRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PreprocessingInfo::DirectiveType is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/rose_attributes_list.h:148
/** Converts an enum of type PreprocessingInfo::DirectiveType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPreprocessingInfoDirectiveType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "CpreprocessorUnknownDeclaration"; break;
        case 1l: retval = "C_StyleComment"; break;
        case 2l: retval = "CplusplusStyleComment"; break;
        case 3l: retval = "FortranStyleComment"; break;
        case 4l: retval = "F90StyleComment"; break;
        case 5l: retval = "CpreprocessorBlankLine"; break;
        case 6l: retval = "CpreprocessorIncludeDeclaration"; break;
        case 7l: retval = "CpreprocessorIncludeNextDeclaration"; break;
        case 8l: retval = "CpreprocessorDefineDeclaration"; break;
        case 9l: retval = "CpreprocessorUndefDeclaration"; break;
        case 10l: retval = "CpreprocessorIfdefDeclaration"; break;
        case 11l: retval = "CpreprocessorIfndefDeclaration"; break;
        case 12l: retval = "CpreprocessorIfDeclaration"; break;
        case 13l: retval = "CpreprocessorDeadIfDeclaration"; break;
        case 14l: retval = "CpreprocessorElseDeclaration"; break;
        case 15l: retval = "CpreprocessorElifDeclaration"; break;
        case 16l: retval = "CpreprocessorEndifDeclaration"; break;
        case 17l: retval = "CpreprocessorLineDeclaration"; break;
        case 18l: retval = "CpreprocessorErrorDeclaration"; break;
        case 19l: retval = "CpreprocessorWarningDeclaration"; break;
        case 20l: retval = "CpreprocessorEmptyDeclaration"; break;
        case 21l: retval = "CSkippedToken"; break;
        case 22l: retval = "CMacroCall"; break;
        case 23l: retval = "CMacroCallStatement"; break;
        case 24l: retval = "LineReplacement"; break;
        case 25l: retval = "ClinkageSpecificationStart"; break;
        case 26l: retval = "ClinkageSpecificationEnd"; break;
        case 27l: retval = "CpreprocessorIdentDeclaration"; break;
        case 28l: retval = "CpreprocessorCompilerGeneratedLinemarker"; break;
        case 29l: retval = "RawText"; break;
        case 30l: retval = "LastDirectiveType"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PreprocessingInfo::DirectiveType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PreprocessingInfo::DirectiveType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PreprocessingInfo::RelativePositionType is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/rose_attributes_list.h:127
/** Converts an enum of type PreprocessingInfo::RelativePositionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPreprocessingInfoRelativePositionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "defaultValue"; break;
        case 1l: retval = "undef"; break;
        case 2l: retval = "before"; break;
        case 3l: retval = "after"; break;
        case 4l: retval = "inside"; break;
        case 6l: retval = "before_syntax"; break;
        case 7l: retval = "after_syntax"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PreprocessingInfo::RelativePositionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PreprocessingInfo::RelativePositionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PtrAliasAnalysis::COLOR is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h:31
/** Converts an enum of type PtrAliasAnalysis::COLOR to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPtrAliasAnalysisCOLOR(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "WHITE"; break;
        case 1l: retval = "GREY"; break;
        case 2l: retval = "BLACK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PtrAliasAnalysis::COLOR)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PtrAliasAnalysis::COLOR::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PtrAliasAnalysis::TRAVERSAL_TYPE is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h:33
/** Converts an enum of type PtrAliasAnalysis::TRAVERSAL_TYPE to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPtrAliasAnalysisTRAVERSAL_TYPE(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "TOPOLOGICAL"; break;
        case 1l: retval = "REVERSE_TOPOLOGICAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(PtrAliasAnalysis::TRAVERSAL_TYPE)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PtrAliasAnalysis::TRAVERSAL_TYPE::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QCodeEdit::Position is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qcodeedit.h:47
/** Converts an enum of type QCodeEdit::Position to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQCodeEditPosition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "West"; break;
        case 1l: retval = "North"; break;
        case 2l: retval = "South"; break;
        case 3l: retval = "East"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QCodeEdit::Position)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QCodeEdit::Position::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocument::LineEnding is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:85
/** Converts an enum of type QDocument::LineEnding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentLineEnding(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Conservative"; break;
        case 1l: retval = "Local"; break;
        case 2l: retval = "Unix"; break;
        case 3l: retval = "Windows"; break;
        case 4l: retval = "Mac"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocument::LineEnding)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::LineEnding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocument::TextProcessing is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:94
/** Converts an enum of type QDocument::TextProcessing to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentTextProcessing(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "RemoveTrailingWS"; break;
        case 2l: retval = "PreserveIndent"; break;
        case 4l: retval = "RestoreTrailingIndent"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocument::TextProcessing)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::TextProcessing::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocument::WhiteSpaceFlag is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:101
/** Converts an enum of type QDocument::WhiteSpaceFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentWhiteSpaceFlag(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ShowNone"; break;
        case 1l: retval = "ShowTrailing"; break;
        case 2l: retval = "ShowLeading"; break;
        case 4l: retval = "ShowTabs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocument::WhiteSpaceFlag)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::WhiteSpaceFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCommand::Command is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcommand.h:38
/** Converts an enum of type QDocumentCommand::Command to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCommandCommand(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "None"; break;
        case 1l: retval = "Insert"; break;
        case 2l: retval = "Erase"; break;
        case 3l: retval = "Replace"; break;
        case 4l: retval = "Custom"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentCommand::Command)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCommand::Command::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursor::MoveFlag is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:40
/** Converts an enum of type QDocumentCursor::MoveFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorMoveFlag(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "MoveAnchor"; break;
        case 1l: retval = "KeepAnchor"; break;
        case 2l: retval = "ThroughWrap"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentCursor::MoveFlag)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::MoveFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursor::MoveOperation is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:49
/** Converts an enum of type QDocumentCursor::MoveOperation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorMoveOperation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NoMove"; break;
        case 1l: retval = "Up"; break;
        case 2l: retval = "Down"; break;
        case 3l: retval = "Left"; break;
        case 4l: retval = "Right"; break;
        case 5l: retval = "Start"; break;
        case 6l: retval = "StartOfLine"; break;
        case 7l: retval = "StartOfWord"; break;
        case 8l: retval = "PreviousBlock"; break;
        case 9l: retval = "PreviousWord"; break;
        case 10l: retval = "WordLeft"; break;
        case 11l: retval = "WordRight"; break;
        case 12l: retval = "End"; break;
        case 13l: retval = "EndOfLine"; break;
        case 14l: retval = "EndOfWord"; break;
        case 15l: retval = "NextWord"; break;
        case 16l: retval = "NextBlock"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentCursor::MoveOperation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::MoveOperation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursor::SelectionType is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:76
/** Converts an enum of type QDocumentCursor::SelectionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorSelectionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "WordUnderCursor"; break;
        case 1l: retval = "LineUnderCursor"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentCursor::SelectionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::SelectionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursorHandle::Flags is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor_p.h:53
/** Converts an enum of type QDocumentCursorHandle::Flags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorHandleFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "Silent"; break;
        case 2l: retval = "ColumnMemory"; break;
        case 4l: retval = "MoveWithinWrapped"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentCursorHandle::Flags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursorHandle::Flags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentLine::State is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h:70
/** Converts an enum of type QDocumentLine::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentLineState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "None"; break;
        case 1l: retval = "Hidden"; break;
        case 2l: retval = "CollapsedBlockStart"; break;
        case 4l: retval = "CollapsedBlockEnd"; break;
        case 16l: retval = "LayoutDirty"; break;
        case 32l: retval = "FormatsApplied"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentLine::State)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentLine::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentSearch::Option is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentsearch.h:41
/** Converts an enum of type QDocumentSearch::Option to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentSearchOption(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "WholeWords"; break;
        case 2l: retval = "CaseSensitive"; break;
        case 4l: retval = "RegExp"; break;
        case 8l: retval = "Replace"; break;
        case 16l: retval = "Prompt"; break;
        case 32l: retval = "Silent"; break;
        case 64l: retval = "HighlightAll"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QDocumentSearch::Option)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentSearch::Option::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QEditor::CodecUpdatePolicy is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:65
/** Converts an enum of type QEditor::CodecUpdatePolicy to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorCodecUpdatePolicy(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NoUpdate"; break;
        case 1l: retval = "UpdateOld"; break;
        case 2l: retval = "UpdateDefault"; break;
        case 4l: retval = "UpdateCustom"; break;
        case 7l: retval = "UpdateAll"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QEditor::CodecUpdatePolicy)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::CodecUpdatePolicy::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QEditor::EditFlag is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:75
/** Converts an enum of type QEditor::EditFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorEditFlag(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "None"; break;
        case 1l: retval = "Overwrite"; break;
        case 2l: retval = "CursorOn"; break;
        case 4l: retval = "ReadOnly"; break;
        case 8l: retval = "MousePressed"; break;
        case 16l: retval = "MaybeDrag"; break;
        case 32l: retval = "Selection"; break;
        case 64l: retval = "Persistent"; break;
        case 128l: retval = "Multiline"; break;
        case 256l: retval = "FoldedCursor"; break;
        case 4095l: retval = "Internal"; break;
        case 4096l: retval = "LineWrap"; break;
        case 65536l: retval = "CtrlNavigation"; break;
        case 131072l: retval = "CursorJumpPastWrap"; break;
        case 1048576l: retval = "ReplaceTabs"; break;
        case 2097152l: retval = "RemoveTrailing"; break;
        case 4194304l: retval = "PreserveTrailingIndent"; break;
        case 16777216l: retval = "AutoCloseChars"; break;
        case 33554432l: retval = "AutoIndent"; break;
        case 4294963200l: retval = "Accessible"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QEditor::EditFlag)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::EditFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QEditor::SaveState is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:494
/** Converts an enum of type QEditor::SaveState to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorSaveState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Undefined"; break;
        case 1l: retval = "Saving"; break;
        case 2l: retval = "Saved"; break;
        case 3l: retval = "Conflict"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QEditor::SaveState)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::SaveState::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QLanguageDefinition::CollapseFlag is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qlanguagedefinition.h:45
/** Converts an enum of type QLanguageDefinition::CollapseFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQLanguageDefinitionCollapseFlag(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "None"; break;
        case 4095l: retval = "OpenMask"; break;
        case 16773120l: retval = "CloseMask"; break;
        case 268435456l: retval = "Collapsible"; break;
        case 536870912l: retval = "Collapsed"; break;
        case 1073741824l: retval = "Closure"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QLanguageDefinition::CollapseFlag)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QLanguageDefinition::CollapseFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QNFAAction::QNFAAction_ is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h:42
/** Converts an enum of type QNFAAction::QNFAAction_ to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQNFAActionQNFAAction_(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NoAction"; break;
        case 4095l: retval = "FormatMask"; break;
        case 16773120l: retval = "ParenMask"; break;
        case 16777216l: retval = "Highlight"; break;
        case 33554432l: retval = "Indent"; break;
        case 67108864l: retval = "ParenOpen"; break;
        case 134217728l: retval = "ParenClose"; break;
        case 268435456l: retval = "MatchParen"; break;
        case 536870912l: retval = "Fold"; break;
        case 1073741824l: retval = "Ambiguous"; break;
        case 2147483648l: retval = "Content"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QNFAAction::QNFAAction_)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QNFAAction::QNFAAction_::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QNFADefinition::PMatch::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h:130
/** Converts an enum of type QNFADefinition::PMatch::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQNFADefinitionPMatchType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Invalid"; break;
        case 1l: retval = "Match"; break;
        case 2l: retval = "Mismatch"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QNFADefinition::PMatch::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QNFADefinition::PMatch::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QPanelLayout::Position is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h:39
/** Converts an enum of type QPanelLayout::Position to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQPanelLayoutPosition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "West"; break;
        case 1l: retval = "North"; break;
        case 2l: retval = "South"; break;
        case 3l: retval = "East"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QPanelLayout::Position)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QPanelLayout::Position::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QPanelLayout::SizeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h:87
/** Converts an enum of type QPanelLayout::SizeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQPanelLayoutSizeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "MinimumSize"; break;
        case 1l: retval = "SizeHint"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QPanelLayout::SizeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QPanelLayout::SizeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QParenthesis::Role is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h:39
/** Converts an enum of type QParenthesis::Role to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQParenthesisRole(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "Open"; break;
        case 2l: retval = "Close"; break;
        case 4l: retval = "Indent"; break;
        case 8l: retval = "Fold"; break;
        case 16l: retval = "Match"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QParenthesis::Role)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QParenthesis::Role::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QReliableFileWatch::State is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qreliablefilewatch.h:53
/** Converts an enum of type QReliableFileWatch::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQReliableFileWatchState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Clean"; break;
        case 1l: retval = "Recent"; break;
        case 2l: retval = "Duplicate"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QReliableFileWatch::State)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QReliableFileWatch::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QtColorLine::ColorComponent is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QtGradientEditor/qtcolorline.h:63
/** Converts an enum of type QtColorLine::ColorComponent to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQtColorLineColorComponent(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Red"; break;
        case 1l: retval = "Green"; break;
        case 2l: retval = "Blue"; break;
        case 3l: retval = "Hue"; break;
        case 4l: retval = "Saturation"; break;
        case 5l: retval = "Value"; break;
        case 6l: retval = "Alpha"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QtColorLine::ColorComponent)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QtColorLine::ColorComponent::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QtGradientWidgetPrivate::Handle is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/QtGradientEditor/qtgradientwidget.cpp:92
/** Converts an enum of type QtGradientWidgetPrivate::Handle to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQtGradientWidgetPrivateHandle(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NoHandle"; break;
        case 1l: retval = "StartLinearHandle"; break;
        case 2l: retval = "EndLinearHandle"; break;
        case 3l: retval = "CentralRadialHandle"; break;
        case 4l: retval = "FocalRadialHandle"; break;
        case 5l: retval = "RadiusRadialHandle"; break;
        case 6l: retval = "CentralConicalHandle"; break;
        case 7l: retval = "AngleConicalHandle"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(QtGradientWidgetPrivate::Handle)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QtGradientWidgetPrivate::Handle::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RIFG::EdgeDirection is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h:63
/** Converts an enum of type RIFG::EdgeDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRIFG_EdgeDirection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ED_INCOMING"; break;
        case 1l: retval = "ED_OUTGOING"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RIFG::EdgeDirection)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RIFG::EdgeDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RIFG::ForwardBackward is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h:64
/** Converts an enum of type RIFG::ForwardBackward to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRIFG_ForwardBackward(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FORWARD"; break;
        case 1l: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RIFG::ForwardBackward)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RIFG::ForwardBackward::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RITarjEdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h:67
/** Converts an enum of type RITarjEdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRITarjEdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RI_TARJ_NORMAL"; break;
        case 1l: retval = "RI_TARJ_LOOP_ENTRY"; break;
        case 2l: retval = "RI_TARJ_IRRED_ENTRY"; break;
        case 3l: retval = "RI_TARJ_ITERATE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RITarjEdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RITarjEdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RITarjType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h:65
/** Converts an enum of type RITarjType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRITarjType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RI_TARJ_NOTHING"; break;
        case 1l: retval = "RI_TARJ_ACYCLIC"; break;
        case 2l: retval = "RI_TARJ_INTERVAL"; break;
        case 3l: retval = "RI_TARJ_IRREDUCIBLE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RITarjType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RITarjType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSEAttributesList::languageTypeEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/rose_attributes_list.h:512
/** Converts an enum of type ROSEAttributesList::languageTypeEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSEAttributesList_languageTypeEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_language"; break;
        case 1l: retval = "e_C_language"; break;
        case 2l: retval = "e_Cxx_language"; break;
        case 3l: retval = "e_Fortran77_language"; break;
        case 4l: retval = "e_Fortran9x_language"; break;
        case 5l: retval = "e_lastLanguage"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSEAttributesList::languageTypeEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSEAttributesList::languageTypeEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Callbacks::Direction is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseSupport/callbacks.h:12
/** Converts an enum of type ROSE_Callbacks::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_CallbacksDirection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FORWARD"; break;
        case 1l: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Callbacks::Direction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Callbacks::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_Additional_Info is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:168
/** Converts an enum of type ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Additional_Info(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10001l: retval = "ROSE_FORT_COMMENTS"; break;
        case 10002l: retval = "ROSE_STRING_LITERALS"; break;
        case 10003l: retval = "ROSE_IDENTIFIER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_Additional_Info)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_Identifiers is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:11
/** Converts an enum of type ROSE_Fortran_Identifiers to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Identifiers(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 2l: retval = "ROSE_ABSTRACT"; break;
        case 3l: retval = "ROSE_ACCESS"; break;
        case 4l: retval = "ROSE_ACTION"; break;
        case 5l: retval = "ROSE_ALLOCATE"; break;
        case 6l: retval = "ROSE_ALLOCATABLE"; break;
        case 7l: retval = "ROSE_ASSIGN"; break;
        case 8l: retval = "ROSE_ASSOCIATE"; break;
        case 9l: retval = "ROSE_ASYNCHRONOUS"; break;
        case 10l: retval = "ROSE_BACKSPACE"; break;
        case 11l: retval = "ROSE_BIND"; break;
        case 12l: retval = "ROSE_BLANK"; break;
        case 13l: retval = "ROSE_BLOCK_DATA"; break;
        case 14l: retval = "ROSE_CALL"; break;
        case 15l: retval = "ROSE_CHARACTER"; break;
        case 16l: retval = "ROSE_CLASS"; break;
        case 17l: retval = "ROSE_CLOSE"; break;
        case 18l: retval = "ROSE_CONTINUE"; break;
        case 19l: retval = "ROSE_CYCLE"; break;
        case 20l: retval = "ROSE_CASE"; break;
        case 21l: retval = "ROSE_COMMON"; break;
        case 22l: retval = "ROSE_COMPLEX"; break;
        case 23l: retval = "ROSE_CONTAINS"; break;
        case 24l: retval = "ROSE_DEALLOCATE"; break;
        case 25l: retval = "ROSE_DATA"; break;
        case 26l: retval = "ROSE_DEFERRED"; break;
        case 27l: retval = "ROSE_DELIM"; break;
        case 28l: retval = "ROSE_DIMENSION"; break;
        case 29l: retval = "ROSE_DO"; break;
        case 30l: retval = "ROSE_DT"; break;
        case 31l: retval = "ROSE_DOUBLEPRECISION"; break;
        case 32l: retval = "ROSE_ENCODING"; break;
        case 33l: retval = "ROSE_END_CASE"; break;
        case 34l: retval = "ROSE_ENDDO"; break;
        case 35l: retval = "ROSE_END_FILE"; break;
        case 36l: retval = "ROSE_END_ENUM"; break;
        case 37l: retval = "ROSE_END_INTERFACE"; break;
        case 38l: retval = "ROSE_END_TYPE"; break;
        case 39l: retval = "ROSE_ERR"; break;
        case 40l: retval = "ROSE_ERRMSG"; break;
        case 41l: retval = "ROSE_EXIT"; break;
        case 42l: retval = "ROSE_ELSE"; break;
        case 43l: retval = "ROSE_ELSEWHERE"; break;
        case 44l: retval = "ROSE_ELSEIF"; break;
        case 45l: retval = "ROSE_ENDIF"; break;
        case 46l: retval = "ROSE_ENTRY"; break;
        case 47l: retval = "ROSE_END"; break;
        case 49l: retval = "ROSE_ENUMERATOR"; break;
        case 50l: retval = "ROSE_EQUIVALENCE"; break;
        case 51l: retval = "ROSE_EXTERNAL"; break;
        case 52l: retval = "ROSE_EXTENDS"; break;
        case 53l: retval = "ROSE_FILE"; break;
        case 54l: retval = "ROSE_FINAL"; break;
        case 55l: retval = "ROSE_FMT"; break;
        case 56l: retval = "ROSE_FORALL"; break;
        case 57l: retval = "ROSE_FORM"; break;
        case 58l: retval = "ROSE_FORMATTED"; break;
        case 59l: retval = "ROSE_FORMAT"; break;
        case 60l: retval = "ROSE_FLUSH"; break;
        case 61l: retval = "ROSE_FUNCTION"; break;
        case 62l: retval = "ROSE_GENERIC"; break;
        case 63l: retval = "ROSE_GOTO"; break;
        case 64l: retval = "ROSE_ID"; break;
        case 65l: retval = "ROSE_IF"; break;
        case 66l: retval = "ROSE_INQUIRE"; break;
        case 67l: retval = "ROSE_INTEGER"; break;
        case 68l: retval = "ROSE_IOMSG"; break;
        case 69l: retval = "ROSE_IOSTAT"; break;
        case 70l: retval = "ROSE_IMPLICIT"; break;
        case 71l: retval = "ROSE_IMPLICIT_NONE"; break;
        case 72l: retval = "ROSE_IMPORT"; break;
        case 73l: retval = "ROSE_INTERFACE"; break;
        case 74l: retval = "ROSE_INTENT"; break;
        case 75l: retval = "ROSE_INTRINSIC"; break;
        case 76l: retval = "ROSE_LEN"; break;
        case 77l: retval = "ROSE_LOGICAL"; break;
        case 78l: retval = "ROSE_KIND"; break;
        case 79l: retval = "ROSE_MODULE_PROC"; break;
        case 80l: retval = "ROSE_MODULE"; break;
        case 81l: retval = "ROSE_NON_INTRINSIC"; break;
        case 82l: retval = "ROSE_NON_OVERRIDABLE"; break;
        case 83l: retval = "ROSE_NULL"; break;
        case 84l: retval = "ROSE_NULLIFY"; break;
        case 85l: retval = "ROSE_NAMELIST"; break;
        case 86l: retval = "ROSE_NML"; break;
        case 87l: retval = "ROSE_NONE"; break;
        case 88l: retval = "ROSE_NOPASS"; break;
        case 89l: retval = "ROSE_ONLY"; break;
        case 90l: retval = "ROSE_OPEN"; break;
        case 91l: retval = "ROSE_PARAMETER"; break;
        case 92l: retval = "ROSE_PASS"; break;
        case 93l: retval = "ROSE_PAUSE"; break;
        case 94l: retval = "ROSE_POINTER"; break;
        case 96l: retval = "ROSE_PRINT"; break;
        case 97l: retval = "ROSE_PRIVATE"; break;
        case 98l: retval = "ROSE_PROCEDURE"; break;
        case 99l: retval = "ROSE_PROGRAM"; break;
        case 100l: retval = "ROSE_PROTECTED"; break;
        case 101l: retval = "ROSE_READ"; break;
        case 102l: retval = "ROSE_REAL"; break;
        case 103l: retval = "ROSE_RETURN"; break;
        case 104l: retval = "ROSE_REWIND"; break;
        case 105l: retval = "ROSE_ROUND"; break;
        case 106l: retval = "ROSE_SELECTCASE"; break;
        case 107l: retval = "ROSE_SELECTTYPE"; break;
        case 108l: retval = "ROSE_SEQUENCE"; break;
        case 109l: retval = "ROSE_SAVE"; break;
        case 110l: retval = "ROSE_SIGN"; break;
        case 111l: retval = "ROSE_SIZE"; break;
        case 112l: retval = "ROSE_SOURCE"; break;
        case 113l: retval = "ROSE_STAT"; break;
        case 114l: retval = "ROSE_STOP"; break;
        case 115l: retval = "ROSE_SUBROUTINE"; break;
        case 116l: retval = "ROSE_TARGET"; break;
        case 117l: retval = "ROSE_THEN"; break;
        case 118l: retval = "ROSE_DERIVED_DECL"; break;
        case 119l: retval = "ROSE_TYPEIS"; break;
        case 120l: retval = "ROSE_UNFORMATTED"; break;
        case 121l: retval = "ROSE_UNIT"; break;
        case 122l: retval = "ROSE_USE"; break;
        case 123l: retval = "ROSE_VALUE"; break;
        case 124l: retval = "ROSE_VOLATILE"; break;
        case 125l: retval = "ROSE_WAIT"; break;
        case 126l: retval = "ROSE_WHERE"; break;
        case 127l: retval = "ROSE_WRITE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_Identifiers)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Identifiers::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_Operators is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:141
/** Converts an enum of type ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Operators(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1001l: retval = "ROSE_INTRINSIC_PLUS"; break;
        case 1002l: retval = "ROSE_INTRINSIC_MINUS"; break;
        case 1003l: retval = "ROSE_INTRINSIC_POWER"; break;
        case 1004l: retval = "ROSE_INTRINSIC_CONCAT"; break;
        case 1005l: retval = "ROSE_INTRINSIC_TIMES"; break;
        case 1006l: retval = "ROSE_INTRINSIC_DIVIDE"; break;
        case 1007l: retval = "ROSE_INTRINSIC_AND"; break;
        case 1008l: retval = "ROSE_INTRINSIC_OR"; break;
        case 1009l: retval = "ROSE_INTRINSIC_EQV"; break;
        case 1010l: retval = "ROSE_INTRINSIC_NEQV"; break;
        case 1011l: retval = "ROSE_INTRINSIC_EQ"; break;
        case 1012l: retval = "ROSE_INTRINSIC_NE"; break;
        case 1013l: retval = "ROSE_INTRINSIC_GE"; break;
        case 1014l: retval = "ROSE_INTRINSIC_LE"; break;
        case 1015l: retval = "ROSE_INTRINSIC_LT"; break;
        case 1016l: retval = "ROSE_INTRINSIC_GT"; break;
        case 1017l: retval = "ROSE_INTRINSIC_NOT"; break;
        case 1018l: retval = "ROSE_INTRINSIC_OLDEQ"; break;
        case 1019l: retval = "ROSE_INTRINSIC_OLDNE"; break;
        case 1020l: retval = "ROSE_INTRINSIC_OLDGE"; break;
        case 1021l: retval = "ROSE_INTRINSIC_OLDLE"; break;
        case 1022l: retval = "ROSE_INTRINSIC_OLDLT"; break;
        case 1023l: retval = "ROSE_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_Operators)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_C_CXX_keywords is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:148
/** Converts an enum of type ROSE_Fortran_defs::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_C_CXX_keywords(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500l: retval = "C_CXX_ASM"; break;
        case 501l: retval = "C_CXX_AUTO"; break;
        case 502l: retval = "C_CXX_BOOL"; break;
        case 503l: retval = "C_CXX_BREAK"; break;
        case 504l: retval = "C_CXX_CASE"; break;
        case 505l: retval = "C_CXX_CATCH"; break;
        case 506l: retval = "C_CXX_CHAR"; break;
        case 507l: retval = "C_CXX_CLASS"; break;
        case 508l: retval = "C_CXX_CONST"; break;
        case 509l: retval = "C_CXX_CONSTCAST"; break;
        case 510l: retval = "C_CXX_CONTINUE"; break;
        case 511l: retval = "C_CXX_DEFAULT"; break;
        case 512l: retval = "C_CXX_DEFINED"; break;
        case 513l: retval = "C_CXX_DELETE"; break;
        case 514l: retval = "C_CXX_DO"; break;
        case 515l: retval = "C_CXX_DOUBLE"; break;
        case 516l: retval = "C_CXX_DYNAMICCAST"; break;
        case 517l: retval = "C_CXX_ELSE"; break;
        case 518l: retval = "C_CXX_ENUM"; break;
        case 519l: retval = "C_CXX_EXPLICIT"; break;
        case 520l: retval = "C_CXX_EXPORT"; break;
        case 521l: retval = "C_CXX_EXTERN"; break;
        case 522l: retval = "C_CXX_FALSE"; break;
        case 523l: retval = "C_CXX_FLOAT"; break;
        case 524l: retval = "C_CXX_FOR"; break;
        case 525l: retval = "C_CXX_FRIEND"; break;
        case 526l: retval = "C_CXX_GOTO"; break;
        case 527l: retval = "C_CXX_IF"; break;
        case 528l: retval = "C_CXX_INLINE"; break;
        case 529l: retval = "C_CXX_INT"; break;
        case 530l: retval = "C_CXX_LONG"; break;
        case 531l: retval = "C_CXX_MUTABLE"; break;
        case 532l: retval = "C_CXX_NAMESPACE"; break;
        case 533l: retval = "C_CXX_NEW"; break;
        case 534l: retval = "C_CXX_OPERATOR"; break;
        case 535l: retval = "C_CXX_PRIVATE"; break;
        case 536l: retval = "C_CXX_PROTECTED"; break;
        case 537l: retval = "C_CXX_PUBLIC"; break;
        case 538l: retval = "C_CXX_REGISTER"; break;
        case 539l: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540l: retval = "C_CXX_RETURN"; break;
        case 541l: retval = "C_CXX_SHORT"; break;
        case 542l: retval = "C_CXX_SIGNED"; break;
        case 543l: retval = "C_CXX_SIZEOF"; break;
        case 544l: retval = "C_CXX_STATIC"; break;
        case 545l: retval = "C_CXX_STATICCAST"; break;
        case 546l: retval = "C_CXX_STRUCT"; break;
        case 547l: retval = "C_CXX_SWITCH"; break;
        case 548l: retval = "C_CXX_TEMPLATE"; break;
        case 549l: retval = "C_CXX_THIS"; break;
        case 550l: retval = "C_CXX_THROW"; break;
        case 551l: retval = "C_CXX_TRY"; break;
        case 552l: retval = "C_CXX_TRUE"; break;
        case 553l: retval = "C_CXX_TYPEDEF"; break;
        case 554l: retval = "C_CXX_TYPEID"; break;
        case 555l: retval = "C_CXX_TYPENAME"; break;
        case 556l: retval = "C_CXX_UNION"; break;
        case 557l: retval = "C_CXX_UNSIGNED"; break;
        case 558l: retval = "C_CXX_USING"; break;
        case 559l: retval = "C_CXX_VIRTUAL"; break;
        case 560l: retval = "C_CXX_VOID"; break;
        case 561l: retval = "C_CXX_VOLATILE"; break;
        case 562l: retval = "C_CXX_WCHART"; break;
        case 563l: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_C_CXX_operators is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:243
/** Converts an enum of type ROSE_Fortran_defs::ROSE_C_CXX_operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_C_CXX_operators(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 50000l: retval = "C_CXX_AND"; break;
        case 50001l: retval = "C_CXX_ANDAND"; break;
        case 50002l: retval = "C_CXX_ASSIGN"; break;
        case 50003l: retval = "C_CXX_ANDASSIGN"; break;
        case 50004l: retval = "C_CXX_OR"; break;
        case 50005l: retval = "C_CXX_ORASSIGN"; break;
        case 50006l: retval = "C_CXX_XOR"; break;
        case 50007l: retval = "C_CXX_XORASSIGN"; break;
        case 50008l: retval = "C_CXX_COMMA"; break;
        case 50009l: retval = "C_CXX_COLON"; break;
        case 50010l: retval = "C_CXX_DIVIDE"; break;
        case 50011l: retval = "C_CXX_DIVIDEASSIGN"; break;
        case 50012l: retval = "C_CXX_DOT"; break;
        case 50013l: retval = "C_CXX_DOTSTAR"; break;
        case 50014l: retval = "C_CXX_ELLIPSIS"; break;
        case 50015l: retval = "C_CXX_EQUAL"; break;
        case 50016l: retval = "C_CXX_GREATER"; break;
        case 50017l: retval = "C_CXX_GREATEREQUAL"; break;
        case 50018l: retval = "C_CXX_LEFTBRACE"; break;
        case 50019l: retval = "C_CXX_LESS"; break;
        case 50020l: retval = "C_CXX_LESSEQUAL"; break;
        case 50021l: retval = "C_CXX_LEFTPAREN"; break;
        case 50022l: retval = "C_CXX_LEFTBRACKET"; break;
        case 50023l: retval = "C_CXX_MINUS"; break;
        case 50024l: retval = "C_CXX_MINUSASSIGN"; break;
        case 50025l: retval = "C_CXX_MINUSMINUS"; break;
        case 50026l: retval = "C_CXX_PERCENT"; break;
        case 50027l: retval = "C_CXX_PERCENTASSIGN"; break;
        case 50028l: retval = "C_CXX_NOT"; break;
        case 50029l: retval = "C_CXX_NOTEQUAL"; break;
        case 50030l: retval = "C_CXX_OROR"; break;
        case 50031l: retval = "C_CXX_PLUS"; break;
        case 50032l: retval = "C_CXX_PLUSASSIGN"; break;
        case 50033l: retval = "C_CXX_PLUSPLUS"; break;
        case 50034l: retval = "C_CXX_ARROW"; break;
        case 50035l: retval = "C_CXX_ARROWSTAR"; break;
        case 50036l: retval = "C_CXX_QUESTION_MARK"; break;
        case 50037l: retval = "C_CXX_RIGHTBRACE"; break;
        case 50038l: retval = "C_CXX_RIGHTPAREN"; break;
        case 50039l: retval = "C_CXX_RIGHTBRACKET"; break;
        case 50040l: retval = "C_CXX_COLON_COLON"; break;
        case 50041l: retval = "C_CXX_SEMICOLON"; break;
        case 50042l: retval = "C_CXX_SHIFTLEFT"; break;
        case 50043l: retval = "C_CXX_SHIFTLEFTASSIGN"; break;
        case 50044l: retval = "C_CXX_SHIFTRIGHT"; break;
        case 50045l: retval = "C_CXX_SHIFTRIGHTASSIGN"; break;
        case 50046l: retval = "C_CXX_STAR"; break;
        case 50047l: retval = "C_CXX_COMPL"; break;
        case 50048l: retval = "C_CXX_STARASSIGN"; break;
        case 50049l: retval = "C_CXX_POUND_POUND"; break;
        case 50050l: retval = "C_CXX_POUND"; break;
        case 50051l: retval = "C_CXX_AND_ALT"; break;
        case 50052l: retval = "C_CXX_ANDASSIGN_ALT"; break;
        case 50053l: retval = "C_CXX_OR_ALT"; break;
        case 50054l: retval = "C_CXX_ORASSIGN_ALT"; break;
        case 50055l: retval = "C_CXX_XOR_ALT"; break;
        case 50056l: retval = "C_CXX_XORASSIGN_ALT"; break;
        case 50057l: retval = "C_CXX_LEFTBRACE_ALT"; break;
        case 50058l: retval = "C_CXX_LEFTBRACKET_ALT"; break;
        case 50059l: retval = "C_CXX_NOT_ALT"; break;
        case 50060l: retval = "C_CXX_NOTEQUAL_ALT"; break;
        case 50061l: retval = "C_CXX_RIGHTBRACE_ALT"; break;
        case 50062l: retval = "C_CXX_RIGHTBRACKET_ALT"; break;
        case 50063l: retval = "C_CXX_COMPL_ALT"; break;
        case 50064l: retval = "C_CXX_POUND_POUND_ALT"; break;
        case 50065l: retval = "C_CXX_POUND_ALT"; break;
        case 50066l: retval = "C_CXX_OR_TRIGRAPH"; break;
        case 50067l: retval = "C_CXX_XOR_TRIGRAPH"; break;
        case 50068l: retval = "C_CXX_LEFTBRACE_TRIGRAPH"; break;
        case 50069l: retval = "C_CXX_LEFTBRACKET_TRIGRAPH"; break;
        case 50070l: retval = "C_CXX_RIGHTBRACE_TRIGRAPH"; break;
        case 50071l: retval = "C_CXX_RIGHTBRACKET_TRIGRAPH"; break;
        case 50072l: retval = "C_CXX_COMPL_TRIGRAPH"; break;
        case 50073l: retval = "C_CXX_POUND_POUND_TRIGRAPH"; break;
        case 50074l: retval = "C_CXX_POUND_TRIGRAPH"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_defs::ROSE_C_CXX_operators)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_Additional_Info is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:322
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000l: retval = "FORTRAN_COMMENTS"; break;
        case 100001l: retval = "FORTRAN_STRING_LITERALS"; break;
        case 100002l: retval = "FORTRAN_IDENTIFIER"; break;
        case 100003l: retval = "FORTRAN_UNIDENTIFIED_TOKEN"; break;
        case 100004l: retval = "FORTRAN_ERROR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_Operators is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:216
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_Operators(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10000l: retval = "FORTRAN_INTRINSIC_PLUS"; break;
        case 10001l: retval = "FORTRAN_INTRINSIC_MINUS"; break;
        case 10002l: retval = "FORTRAN_INTRINSIC_POWER"; break;
        case 10003l: retval = "FORTRAN_INTRINSIC_CONCAT"; break;
        case 10004l: retval = "FORTRAN_INTRINSIC_TIMES"; break;
        case 10005l: retval = "FORTRAN_INTRINSIC_DIVIDE"; break;
        case 10006l: retval = "FORTRAN_INTRINSIC_AND"; break;
        case 10007l: retval = "FORTRAN_INTRINSIC_OR"; break;
        case 10008l: retval = "FORTRAN_INTRINSIC_EQV"; break;
        case 10009l: retval = "FORTRAN_INTRINSIC_NEQV"; break;
        case 10010l: retval = "FORTRAN_INTRINSIC_EQ"; break;
        case 10011l: retval = "FORTRAN_INTRINSIC_NE"; break;
        case 10012l: retval = "FORTRAN_INTRINSIC_GE"; break;
        case 10013l: retval = "FORTRAN_INTRINSIC_LE"; break;
        case 10014l: retval = "FORTRAN_INTRINSIC_LT"; break;
        case 10015l: retval = "FORTRAN_INTRINSIC_GT"; break;
        case 10016l: retval = "FORTRAN_INTRINSIC_NOT"; break;
        case 10017l: retval = "FORTRAN_INTRINSIC_OLDEQ"; break;
        case 10018l: retval = "FORTRAN_INTRINSIC_OLDNE"; break;
        case 10019l: retval = "FORTRAN_INTRINSIC_OLDGE"; break;
        case 10020l: retval = "FORTRAN_INTRINSIC_OLDLE"; break;
        case 10021l: retval = "FORTRAN_INTRINSIC_OLDLT"; break;
        case 10022l: retval = "FORTRAN_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_defs::ROSE_Fortran_Operators)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_keywords is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:15
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_keywords(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FORTRAN_ABSTRACT"; break;
        case 1l: retval = "FORTRAN_ACCESS"; break;
        case 2l: retval = "FORTRAN_ACTION"; break;
        case 3l: retval = "FORTRAN_ALLOCATE"; break;
        case 4l: retval = "FORTRAN_ALLOCATABLE"; break;
        case 5l: retval = "FORTRAN_ASSIGN"; break;
        case 6l: retval = "FORTRAN_ASSOCIATE"; break;
        case 7l: retval = "FORTRAN_ASYNCHRONOUS"; break;
        case 8l: retval = "FORTRAN_BACKSPACE"; break;
        case 9l: retval = "FORTRAN_BIND"; break;
        case 10l: retval = "FORTRAN_BLANK"; break;
        case 11l: retval = "FORTRAN_BLOCK_DATA"; break;
        case 12l: retval = "FORTRAN_CALL"; break;
        case 13l: retval = "FORTRAN_CHARACTER"; break;
        case 14l: retval = "FORTRAN_CLASS"; break;
        case 15l: retval = "FORTRAN_CLOSE"; break;
        case 16l: retval = "FORTRAN_CONTINUE"; break;
        case 17l: retval = "FORTRAN_CYCLE"; break;
        case 18l: retval = "FORTRAN_CASE"; break;
        case 19l: retval = "FORTRAN_COMMON"; break;
        case 20l: retval = "FORTRAN_COMPLEX"; break;
        case 21l: retval = "FORTRAN_CONTAINS"; break;
        case 22l: retval = "FORTRAN_DEALLOCATE"; break;
        case 23l: retval = "FORTRAN_DATA"; break;
        case 24l: retval = "FORTRAN_DEFERRED"; break;
        case 25l: retval = "FORTRAN_DELIM"; break;
        case 26l: retval = "FORTRAN_DIMENSION"; break;
        case 27l: retval = "FORTRAN_DO"; break;
        case 28l: retval = "FORTRAN_DT"; break;
        case 29l: retval = "FORTRAN_DOUBLEPRECISION"; break;
        case 30l: retval = "FORTRAN_ENCODING"; break;
        case 31l: retval = "FORTRAN_END_CASE"; break;
        case 32l: retval = "FORTRAN_ENDDO"; break;
        case 33l: retval = "FORTRAN_END_FILE"; break;
        case 34l: retval = "FORTRAN_END_ENUM"; break;
        case 35l: retval = "FORTRAN_END_INTERFACE"; break;
        case 36l: retval = "FORTRAN_END_TYPE"; break;
        case 37l: retval = "FORTRAN_ERR"; break;
        case 38l: retval = "FORTRAN_ERRMSG"; break;
        case 39l: retval = "FORTRAN_EXIT"; break;
        case 40l: retval = "FORTRAN_ELSE"; break;
        case 41l: retval = "FORTRAN_ELSEWHERE"; break;
        case 42l: retval = "FORTRAN_ELSEIF"; break;
        case 43l: retval = "FORTRAN_ENDIF"; break;
        case 44l: retval = "FORTRAN_ENTRY"; break;
        case 45l: retval = "FORTRAN_END"; break;
        case 46l: retval = "FORTRAN_ENUM"; break;
        case 47l: retval = "FORTRAN_ENUMERATOR"; break;
        case 48l: retval = "FORTRAN_EQUIVALENCE"; break;
        case 49l: retval = "FORTRAN_EXTERNAL"; break;
        case 50l: retval = "FORTRAN_EXTENDS"; break;
        case 51l: retval = "FORTRAN_FILE"; break;
        case 52l: retval = "FORTRAN_FINAL"; break;
        case 53l: retval = "FORTRAN_FMT"; break;
        case 54l: retval = "FORTRAN_FORALL"; break;
        case 55l: retval = "FORTRAN_FORM"; break;
        case 56l: retval = "FORTRAN_FORMATTED"; break;
        case 57l: retval = "FORTRAN_FORMAT"; break;
        case 58l: retval = "FORTRAN_FLUSH"; break;
        case 59l: retval = "FORTRAN_FUNCTION"; break;
        case 60l: retval = "FORTRAN_GENERIC"; break;
        case 61l: retval = "FORTRAN_GOTO"; break;
        case 62l: retval = "FORTRAN_ID"; break;
        case 63l: retval = "FORTRAN_IF"; break;
        case 64l: retval = "FORTRAN_INQUIRE"; break;
        case 65l: retval = "FORTRAN_INTEGER"; break;
        case 66l: retval = "FORTRAN_IOMSG"; break;
        case 67l: retval = "FORTRAN_IOSTAT"; break;
        case 68l: retval = "FORTRAN_IMPLICIT"; break;
        case 69l: retval = "FORTRAN_IMPLICIT_NONE"; break;
        case 70l: retval = "FORTRAN_IMPORT"; break;
        case 71l: retval = "FORTRAN_INTERFACE"; break;
        case 72l: retval = "FORTRAN_INTENT"; break;
        case 73l: retval = "FORTRAN_INTRINSIC"; break;
        case 74l: retval = "FORTRAN_LEN"; break;
        case 75l: retval = "FORTRAN_LOGICAL"; break;
        case 76l: retval = "FORTRAN_KIND"; break;
        case 77l: retval = "FORTRAN_MODULE_PROC"; break;
        case 78l: retval = "FORTRAN_MODULE"; break;
        case 79l: retval = "FORTRAN_NON_INTRINSIC"; break;
        case 80l: retval = "FORTRAN_NON_OVERRIDABLE"; break;
        case 81l: retval = "FORTRAN_NULL"; break;
        case 82l: retval = "FORTRAN_NULLIFY"; break;
        case 83l: retval = "FORTRAN_NAMELIST"; break;
        case 84l: retval = "FORTRAN_NML"; break;
        case 85l: retval = "FORTRAN_NONE"; break;
        case 86l: retval = "FORTRAN_NOPASS"; break;
        case 87l: retval = "FORTRAN_ONLY"; break;
        case 88l: retval = "FORTRAN_OPEN"; break;
        case 89l: retval = "FORTRAN_OPTIONAL"; break;
        case 90l: retval = "FORTRAN_PARAMETER"; break;
        case 91l: retval = "FORTRAN_PASS"; break;
        case 92l: retval = "FORTRAN_PAUSE"; break;
        case 93l: retval = "FORTRAN_POINTER"; break;
        case 94l: retval = "FORTRAN_PRINT"; break;
        case 95l: retval = "FORTRAN_PRIVATE"; break;
        case 96l: retval = "FORTRAN_PROCEDURE"; break;
        case 97l: retval = "FORTRAN_PROGRAM"; break;
        case 98l: retval = "FORTRAN_PROTECTED"; break;
        case 99l: retval = "FORTRAN_READ"; break;
        case 100l: retval = "FORTRAN_REAL"; break;
        case 101l: retval = "FORTRAN_RETURN"; break;
        case 102l: retval = "FORTRAN_REWIND"; break;
        case 103l: retval = "FORTRAN_ROUND"; break;
        case 104l: retval = "FORTRAN_SELECTCASE"; break;
        case 105l: retval = "FORTRAN_SELECTTYPE"; break;
        case 106l: retval = "FORTRAN_SEQUENCE"; break;
        case 107l: retval = "FORTRAN_SAVE"; break;
        case 108l: retval = "FORTRAN_SIGN"; break;
        case 109l: retval = "FORTRAN_SIZE"; break;
        case 110l: retval = "FORTRAN_SOURCE"; break;
        case 111l: retval = "FORTRAN_STAT"; break;
        case 112l: retval = "FORTRAN_STOP"; break;
        case 113l: retval = "FORTRAN_SUBROUTINE"; break;
        case 114l: retval = "FORTRAN_TARGET"; break;
        case 115l: retval = "FORTRAN_THEN"; break;
        case 116l: retval = "FORTRAN_DERIVED_DECL"; break;
        case 117l: retval = "FORTRAN_TYPEIS"; break;
        case 118l: retval = "FORTRAN_UNFORMATTED"; break;
        case 119l: retval = "FORTRAN_UNIT"; break;
        case 120l: retval = "FORTRAN_USE"; break;
        case 121l: retval = "FORTRAN_VALUE"; break;
        case 122l: retval = "FORTRAN_VOLATILE"; break;
        case 123l: retval = "FORTRAN_WAIT"; break;
        case 124l: retval = "FORTRAN_WHERE"; break;
        case 125l: retval = "FORTRAN_WRITE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_Fortran_defs::ROSE_Fortran_keywords)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::ROSE_C_CXX_Additional_Info is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/general_token_defs.h:172
/** Converts an enum of type ROSE_token_ids::ROSE_C_CXX_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_idsROSE_C_CXX_Additional_Info(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000l: retval = "C_CXX_COMMENTS"; break;
        case 100001l: retval = "C_CXX_STRING_LITERALS"; break;
        case 100002l: retval = "C_CXX_IDENTIFIER"; break;
        case 100003l: retval = "C_CXX_PREPROCESSING_INFO"; break;
        case 100004l: retval = "C_CXX_UNIDENTIFIED_TOKEN"; break;
        case 100005l: retval = "C_CXX_SYNTAX"; break;
        case 100006l: retval = "C_CXX_WHITESPACE"; break;
        case 100007l: retval = "C_CXX_PRAGMA"; break;
        case 100008l: retval = "C_CXX_ERROR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::ROSE_C_CXX_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::ROSE_C_CXX_alternate_tok is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/general_token_defs.h:160
/** Converts an enum of type ROSE_token_ids::ROSE_C_CXX_alternate_tok to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_idsROSE_C_CXX_alternate_tok(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "C_CXX_LEFT_CURLY_ALT"; break;
        case 1l: retval = "C_CXX_RIGHT_CURLY_ALT"; break;
        case 2l: retval = "C_CXX_LEFT_SQUARE_ALT"; break;
        case 3l: retval = "C_CXX_RIGHT_SQUARE_ALT"; break;
        case 4l: retval = "C_CXX_HASH_ALT"; break;
        case 5l: retval = "C_CXX_HASH_HASH_ALT"; break;
        case 6l: retval = "C_CXX_and_ALT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::ROSE_C_CXX_alternate_tok::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::ROSE_C_CXX_keywords is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/general_token_defs.h:89
/** Converts an enum of type ROSE_token_ids::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_idsROSE_C_CXX_keywords(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500l: retval = "C_CXX_ASM"; break;
        case 501l: retval = "C_CXX_AUTO"; break;
        case 502l: retval = "C_CXX_BOOL"; break;
        case 503l: retval = "C_CXX_BREAK"; break;
        case 504l: retval = "C_CXX_CASE"; break;
        case 505l: retval = "C_CXX_CATCH"; break;
        case 506l: retval = "C_CXX_CHAR"; break;
        case 507l: retval = "C_CXX_CLASS"; break;
        case 508l: retval = "C_CXX_CONST"; break;
        case 509l: retval = "C_CXX_CONSTCAST"; break;
        case 510l: retval = "C_CXX_CONTINUE"; break;
        case 511l: retval = "C_CXX_DEFAULT"; break;
        case 512l: retval = "C_CXX_DEFINED"; break;
        case 513l: retval = "C_CXX_DELETE"; break;
        case 514l: retval = "C_CXX_DO"; break;
        case 515l: retval = "C_CXX_DOUBLE"; break;
        case 516l: retval = "C_CXX_DYNAMICCAST"; break;
        case 517l: retval = "C_CXX_ELSE"; break;
        case 518l: retval = "C_CXX_ENUM"; break;
        case 519l: retval = "C_CXX_EXPLICIT"; break;
        case 520l: retval = "C_CXX_EXPORT"; break;
        case 521l: retval = "C_CXX_EXTERN"; break;
        case 522l: retval = "C_CXX_FALSE"; break;
        case 523l: retval = "C_CXX_FLOAT"; break;
        case 524l: retval = "C_CXX_FOR"; break;
        case 525l: retval = "C_CXX_FRIEND"; break;
        case 526l: retval = "C_CXX_GOTO"; break;
        case 527l: retval = "C_CXX_IF"; break;
        case 528l: retval = "C_CXX_INLINE"; break;
        case 529l: retval = "C_CXX_INT"; break;
        case 530l: retval = "C_CXX_LONG"; break;
        case 531l: retval = "C_CXX_MUTABLE"; break;
        case 532l: retval = "C_CXX_NAMESPACE"; break;
        case 533l: retval = "C_CXX_NEW"; break;
        case 534l: retval = "C_CXX_OPERATOR"; break;
        case 535l: retval = "C_CXX_PRIVATE"; break;
        case 536l: retval = "C_CXX_PROTECTED"; break;
        case 537l: retval = "C_CXX_PUBLIC"; break;
        case 538l: retval = "C_CXX_REGISTER"; break;
        case 539l: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540l: retval = "C_CXX_RETURN"; break;
        case 541l: retval = "C_CXX_SHORT"; break;
        case 542l: retval = "C_CXX_SIGNED"; break;
        case 543l: retval = "C_CXX_SIZEOF"; break;
        case 544l: retval = "C_CXX_STATIC"; break;
        case 545l: retval = "C_CXX_STATICCAST"; break;
        case 546l: retval = "C_CXX_STRUCT"; break;
        case 547l: retval = "C_CXX_SWITCH"; break;
        case 548l: retval = "C_CXX_TEMPLATE"; break;
        case 549l: retval = "C_CXX_THIS"; break;
        case 550l: retval = "C_CXX_THROW"; break;
        case 551l: retval = "C_CXX_TRY"; break;
        case 552l: retval = "C_CXX_TRUE"; break;
        case 553l: retval = "C_CXX_TYPEDEF"; break;
        case 554l: retval = "C_CXX_TYPEID"; break;
        case 555l: retval = "C_CXX_TYPENAME"; break;
        case 556l: retval = "C_CXX_UNION"; break;
        case 557l: retval = "C_CXX_UNSIGNED"; break;
        case 558l: retval = "C_CXX_USING"; break;
        case 559l: retval = "C_CXX_VIRTUAL"; break;
        case 560l: retval = "C_CXX_VOID"; break;
        case 561l: retval = "C_CXX_VOLATILE"; break;
        case 562l: retval = "C_CXX_WCHART"; break;
        case 563l: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_token_ids::ROSE_C_CXX_keywords)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::whitespace is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/general_token_defs.h:13
/** Converts an enum of type ROSE_token_ids::whitespace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_ids_whitespace(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "T_NOTKNOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ROSE_token_ids::whitespace)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::whitespace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ReachingDef::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/staticSingleAssignment/reachingDef.h:19
/** Converts an enum of type ReachingDef::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyReachingDefType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PHI_FUNCTION"; break;
        case 1l: retval = "ORIGINAL_DEF"; break;
        case 2l: retval = "EXPANDED_DEF"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ReachingDef::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ReachingDef::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RegisterDictionary::SortBySize::Direction is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/Registers.h:149
/** Converts an enum of type RegisterDictionary::SortBySize::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRegisterDictionarySortBySizeDirection(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ASCENDING"; break;
        case 1l: retval = "DESCENDING"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RegisterDictionary::SortBySize::Direction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RegisterDictionary::SortBySize::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_Arch::Architecture is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryDisassembly/RoseBin_support.h:51
/** Converts an enum of type RoseBin_Arch::Architecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_ArchArchitecture(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "bit32"; break;
        case 1l: retval = "bit64"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RoseBin_Arch::Architecture)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_Arch::Architecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_DataTypes::DataTypes is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryDisassembly/RoseBin_support.h:86
/** Converts an enum of type RoseBin_DataTypes::DataTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_DataTypesDataTypes(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknown"; break;
        case 1l: retval = "d_none"; break;
        case 2l: retval = "d_int"; break;
        case 3l: retval = "d_uint"; break;
        case 4l: retval = "d_struct"; break;
        case 5l: retval = "d_char_p"; break;
        case 6l: retval = "d_size_t"; break;
        case 7l: retval = "d_const_char_p"; break;
        case 8l: retval = "d_pid_t"; break;
        case 9l: retval = "d_uint_p"; break;
        case 10l: retval = "d_long"; break;
        case 11l: retval = "d_array"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RoseBin_DataTypes::DataTypes)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_DataTypes::DataTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_Def::RoseLanguage is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryDisassembly/RoseBin_support.h:32
/** Converts an enum of type RoseBin_Def::RoseLanguage to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_DefRoseLanguage(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "none"; break;
        case 1l: retval = "x86"; break;
        case 2l: retval = "arm"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RoseBin_Def::RoseLanguage)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_Def::RoseLanguage::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_OS::OSSYSTEM is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryDisassembly/RoseBin_support.h:42
/** Converts an enum of type RoseBin_OS::OSSYSTEM to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_OS_OSSYSTEM(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "linux_op"; break;
        case 1l: retval = "windows_op"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RoseBin_OS::OSSYSTEM)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_OS::OSSYSTEM::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_OS_VER::OS_VERSION is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryDisassembly/RoseBin_support.h:60
/** Converts an enum of type RoseBin_OS_VER::OS_VERSION to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_OS_VER_OS_VERSION(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "linux_22"; break;
        case 1l: retval = "linux_24"; break;
        case 2l: retval = "linux_26"; break;
        case 3l: retval = "linux_27"; break;
        case 4l: retval = "NT_SP3"; break;
        case 5l: retval = "NT_SP4"; break;
        case 6l: retval = "NT_SP5"; break;
        case 7l: retval = "NT_SP6"; break;
        case 8l: retval = "Win2000_SP0"; break;
        case 9l: retval = "Win2000_SP1"; break;
        case 10l: retval = "Win2000_SP2"; break;
        case 11l: retval = "Win2000_SP3"; break;
        case 12l: retval = "Win2000_SP4"; break;
        case 13l: retval = "WinXP_SP0"; break;
        case 14l: retval = "WinXP_SP1"; break;
        case 15l: retval = "WinXP_SP2"; break;
        case 16l: retval = "WinVista_SP0"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RoseBin_OS_VER::OS_VERSION)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_OS_VER::OS_VERSION::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_support::X86PositionInRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/BinaryDisassembly/RoseBin_support.h:175
/** Converts an enum of type RoseBin_support::X86PositionInRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_supportX86PositionInRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_regpos_unknown"; break;
        case 1l: retval = "x86_regpos_low_byte"; break;
        case 2l: retval = "x86_regpos_high_byte"; break;
        case 3l: retval = "x86_regpos_word"; break;
        case 4l: retval = "x86_regpos_dword"; break;
        case 5l: retval = "x86_regpos_qword"; break;
        case 6l: retval = "x86_regpos_all"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(RoseBin_support::X86PositionInRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_support::X86PositionInRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::PDGEdge::EdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/systemDependenceGraph/PDG.h:33
/** Converts an enum of type SDG::PDGEdge::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_PDGEdgeEdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ControlDependence"; break;
        case 1l: retval = "DataDependence"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SDG::PDGEdge::EdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::PDGEdge::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::SDGEdge::ControlDependenceType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/systemDependenceGraph/SDG.h:59
/** Converts an enum of type SDG::SDGEdge::ControlDependenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_SDGEdgeControlDependenceType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "cdTrue"; break;
        case 1l: retval = "cdFalse"; break;
        case 2l: retval = "cdCase"; break;
        case 3l: retval = "cdDefault"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SDG::SDGEdge::ControlDependenceType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::SDGEdge::ControlDependenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::SDGEdge::EdgeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/systemDependenceGraph/SDG.h:49
/** Converts an enum of type SDG::SDGEdge::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_SDGEdgeEdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ControlDependence"; break;
        case 1l: retval = "DataDependence"; break;
        case 2l: retval = "ParameterIn"; break;
        case 3l: retval = "ParameterOut"; break;
        case 4l: retval = "Call"; break;
        case 5l: retval = "Summary"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SDG::SDGEdge::EdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::SDGEdge::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::SDGNode::NodeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/systemDependenceGraph/SDG.h:22
/** Converts an enum of type SDG::SDGNode::NodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_SDGNodeNodeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "Entry"; break;
        case 1l: retval = "ASTNode"; break;
        case 2l: retval = "FunctionCall"; break;
        case 3l: retval = "ActualIn"; break;
        case 4l: retval = "ActualOut"; break;
        case 5l: retval = "FormalIn"; break;
        case 6l: retval = "FormalOut"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SDG::SDGNode::NodeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::SDGNode::NodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SPRAY::LabelProperty::IOType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/abstractLayer/Labeler.h:85
/** Converts an enum of type SPRAY::LabelProperty::IOType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySPRAY_LabelPropertyIOType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "LABELIO_NONE"; break;
        case 1l: retval = "LABELIO_STDIN"; break;
        case 2l: retval = "LABELIO_STDOUTVAR"; break;
        case 3l: retval = "LABELIO_STDOUTCONST"; break;
        case 4l: retval = "LABELIO_STDERR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SPRAY::LabelProperty::IOType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SPRAY::LabelProperty::IOType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SPRAY::LabelProperty::LabelType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/abstractLayer/Labeler.h:59
/** Converts an enum of type SPRAY::LabelProperty::LabelType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySPRAY_LabelPropertyLabelType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "LABEL_UNDEF"; break;
        case 2l: retval = "LABEL_OTHER"; break;
        case 100l: retval = "LABEL_FUNCTIONCALL"; break;
        case 101l: retval = "LABEL_FUNCTIONCALLRETURN"; break;
        case 102l: retval = "LABEL_FUNCTIONENTRY"; break;
        case 103l: retval = "LABEL_FUNCTIONEXIT"; break;
        case 104l: retval = "LABEL_BLOCKBEGIN"; break;
        case 105l: retval = "LABEL_BLOCKEND"; break;
        case 106l: retval = "LABEL_EMPTY_STMT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SPRAY::LabelProperty::LabelType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SPRAY::LabelProperty::LabelType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SageBuilder::SourcePositionClassification is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/sageInterface/sageBuilder.h:123
/** Converts an enum of type SageBuilder::SourcePositionClassification to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySageBuilderSourcePositionClassification(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_sourcePositionError"; break;
        case 1l: retval = "e_sourcePositionDefault"; break;
        case 2l: retval = "e_sourcePositionTransformation"; break;
        case 3l: retval = "e_sourcePositionCompilerGenerated"; break;
        case 4l: retval = "e_sourcePositionNullPointers"; break;
        case 5l: retval = "e_sourcePositionFrontendConstruction"; break;
        case 6l: retval = "e_sourcePosition_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SageBuilder::SourcePositionClassification)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SageBuilder::SourcePositionClassification::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Access::Access is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Access.h:17
/** Converts an enum of type Sawyer::Access::Access to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerAccessAccess(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "EXECUTABLE"; break;
        case 2l: retval = "WRITABLE"; break;
        case 4l: retval = "READABLE"; break;
        case 8l: retval = "IMMUTABLE"; break;
        case 255l: retval = "RESERVED_MASK"; break;
        case 4294967040l: retval = "USERDEF_MASK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Access::Access)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Access::Access::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::CommandLine::SortOrder is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/CommandLine.h:170
/** Converts an enum of type Sawyer::CommandLine::SortOrder to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerCommandLineSortOrder(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INSERTION_ORDER"; break;
        case 1l: retval = "DOCKEY_ORDER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::CommandLine::SortOrder)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::CommandLine::SortOrder::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::CommandLine::WhichValue is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/CommandLine.h:1789
/** Converts an enum of type Sawyer::CommandLine::WhichValue to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerCommandLineWhichValue(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SAVE_NONE"; break;
        case 1l: retval = "SAVE_ONE"; break;
        case 2l: retval = "SAVE_LAST"; break;
        case 3l: retval = "SAVE_FIRST"; break;
        case 4l: retval = "SAVE_ALL"; break;
        case 5l: retval = "SAVE_AUGMENTED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::CommandLine::WhichValue)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::CommandLine::WhichValue::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Container::Algorithm::TraversalEvent is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/GraphTraversal.h:38
/** Converts an enum of type Sawyer::Container::Algorithm::TraversalEvent to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerContainerAlgorithmTraversalEvent(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NO_EVENT"; break;
        case 1l: retval = "ENTER_VERTEX"; break;
        case 2l: retval = "ENTER_EDGE"; break;
        case 4l: retval = "DISCOVER_VERTEX"; break;
        case 8l: retval = "LEAVE_EDGE"; break;
        case 16l: retval = "LEAVE_VERTEX"; break;
        case 32l: retval = "FOLLOW_EDGE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Container::Algorithm::TraversalEvent)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Container::Algorithm::TraversalEvent::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Container::Graph::EdgePhase is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Graph.h:633
/** Converts an enum of type Sawyer::Container::Graph::EdgePhase to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerContainerGraphEdgePhase(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "IN_EDGES"; break;
        case 1l: retval = "OUT_EDGES"; break;
        case 2l: retval = "N_PHASES"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Container::Graph::EdgePhase)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Container::Graph::EdgePhase::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Markup::DivSpan is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Markup.h:104
/** Converts an enum of type Sawyer::Markup::DivSpan to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMarkupDivSpan(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "DIVIDING"; break;
        case 1l: retval = "SPANNING"; break;
        case 2l: retval = "VERBATIM"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Markup::DivSpan)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Markup::DivSpan::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Markup::TextMode is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Markup.h:424
/** Converts an enum of type Sawyer::Markup::TextMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMarkupTextMode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PROSE"; break;
        case 1l: retval = "NONPROSE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Markup::TextMode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Markup::TextMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Message::AnsiColor is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Message.h:340
/** Converts an enum of type Sawyer::Message::AnsiColor to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMessageAnsiColor(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "COLOR_BLACK"; break;
        case 1l: retval = "COLOR_RED"; break;
        case 2l: retval = "COLOR_GREEN"; break;
        case 3l: retval = "COLOR_YELLOW"; break;
        case 4l: retval = "COLOR_BLUE"; break;
        case 5l: retval = "COLOR_MAGENTA"; break;
        case 6l: retval = "COLOR_CYAN"; break;
        case 7l: retval = "COLOR_WHITE"; break;
        case 8l: retval = "COLOR_DEFAULT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Message::AnsiColor)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Message::AnsiColor::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Message::Importance is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Message.h:310
/** Converts an enum of type Sawyer::Message::Importance to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMessageImportance(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "DEBUG"; break;
        case 1l: retval = "TRACE"; break;
        case 2l: retval = "WHERE"; break;
        case 3l: retval = "MARCH"; break;
        case 4l: retval = "INFO"; break;
        case 5l: retval = "WARN"; break;
        case 6l: retval = "ERROR"; break;
        case 7l: retval = "FATAL"; break;
        case 8l: retval = "N_IMPORTANCE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Message::Importance)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Message::Importance::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Message::When is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/Sawyer/Message.h:980
/** Converts an enum of type Sawyer::Message::When to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMessageWhen(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NEVER"; break;
        case 1l: retval = "SOMETIMES"; break;
        case 2l: retval = "ALWAYS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sawyer::Message::When)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Message::When::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAccessModifier::access_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:11892
/** Converts an enum of type SgAccessModifier::access_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAccessModifier_access_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_private"; break;
        case 2l: retval = "e_protected"; break;
        case 3l: retval = "e_public"; break;
        case 4l: retval = "e_undefined"; break;
        case 5l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAccessModifier::access_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAccessModifier::access_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmBlock::Reason is defined at frontend/SageIII/Cxx_Grammar.h:308466
/** Converts an enum of type SgAsmBlock::Reason to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmBlockReason(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "BLK_NONE"; break;
        case 1l: retval = "BLK_FINDDATA"; break;
        case 2l: retval = "BLK_POSTFUNC"; break;
        case 255l: retval = "BLK_MISCMASK"; break;
        case 65536l: retval = "BLK_ENTRY_POINT"; break;
        case 131072l: retval = "BLK_PADDING"; break;
        case 524288l: retval = "BLK_FRAGMENT"; break;
        case 1048576l: retval = "BLK_CFGHEAD"; break;
        case 2097152l: retval = "BLK_USERDEF"; break;
        case 4194304l: retval = "BLK_LEFTOVERS"; break;
        case 8388608l: retval = "BLK_JUMPTABLE"; break;
        case 16777216l: retval = "BLK_GRAPH1"; break;
        case 33554432l: retval = "BLK_GRAPH2"; break;
        case 67108864l: retval = "BLK_GRAPH3"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmBlock::Reason)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmBlock::Reason::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfDynamicEntry::EntryType is defined at frontend/SageIII/Cxx_Grammar.h:366053
/** Converts an enum of type SgAsmElfDynamicEntry::EntryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfDynamicEntryEntryType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "DT_NULL"; break;
        case 1l: retval = "DT_NEEDED"; break;
        case 2l: retval = "DT_PLTRELSZ"; break;
        case 3l: retval = "DT_PLTGOT"; break;
        case 4l: retval = "DT_HASH"; break;
        case 5l: retval = "DT_STRTAB"; break;
        case 6l: retval = "DT_SYMTAB"; break;
        case 7l: retval = "DT_RELA"; break;
        case 8l: retval = "DT_RELASZ"; break;
        case 9l: retval = "DT_RELAENT"; break;
        case 10l: retval = "DT_STRSZ"; break;
        case 11l: retval = "DT_SYMENT"; break;
        case 12l: retval = "DT_INIT"; break;
        case 13l: retval = "DT_FINI"; break;
        case 14l: retval = "DT_SONAME"; break;
        case 15l: retval = "DT_RPATH"; break;
        case 16l: retval = "DT_SYMBOLIC"; break;
        case 17l: retval = "DT_REL"; break;
        case 18l: retval = "DT_RELSZ"; break;
        case 19l: retval = "DT_RELENT"; break;
        case 20l: retval = "DT_PLTREL"; break;
        case 21l: retval = "DT_DEBUG"; break;
        case 22l: retval = "DT_TEXTREL"; break;
        case 23l: retval = "DT_JMPREL"; break;
        case 24l: retval = "DT_BIND_NOW"; break;
        case 25l: retval = "DT_INIT_ARRAY"; break;
        case 26l: retval = "DT_FINI_ARRAY"; break;
        case 27l: retval = "DT_INIT_ARRAYSZ"; break;
        case 28l: retval = "DT_FINI_ARRAYSZ"; break;
        case 29l: retval = "DT_RUNPATH"; break;
        case 30l: retval = "DT_FLAGS"; break;
        case 32l: retval = "DT_PREINIT_ARRAY"; break;
        case 33l: retval = "DT_PREINIT_ARRAYSZ"; break;
        case 34l: retval = "DT_NUM"; break;
        case 1879047669l: retval = "DT_GNU_PRELINKED"; break;
        case 1879047670l: retval = "DT_GNU_CONFLICTSZ"; break;
        case 1879047671l: retval = "DT_GNU_LIBLISTSZ"; break;
        case 1879047672l: retval = "DT_CHECKSUM"; break;
        case 1879047673l: retval = "DT_PLTPADSZ"; break;
        case 1879047674l: retval = "DT_MOVEENT"; break;
        case 1879047675l: retval = "DT_MOVESZ"; break;
        case 1879047676l: retval = "DT_FEATURE_1"; break;
        case 1879047677l: retval = "DT_POSFLAG_1"; break;
        case 1879047678l: retval = "DT_SYMINSZ"; break;
        case 1879047679l: retval = "DT_SYMINENT"; break;
        case 1879047925l: retval = "DT_GNU_HASH"; break;
        case 1879047926l: retval = "DT_TLSDESC_PLT"; break;
        case 1879047927l: retval = "DT_TLSDESC_GOT"; break;
        case 1879047928l: retval = "DT_GNU_CONFLICT"; break;
        case 1879047929l: retval = "DT_GNU_LIBLIST"; break;
        case 1879047930l: retval = "DT_CONFIG"; break;
        case 1879047931l: retval = "DT_DEPAUDIT"; break;
        case 1879047932l: retval = "DT_AUDIT"; break;
        case 1879047933l: retval = "DT_PLTPAD"; break;
        case 1879047934l: retval = "DT_MOVETAB"; break;
        case 1879047935l: retval = "DT_SYMINFO"; break;
        case 1879048176l: retval = "DT_VERSYM"; break;
        case 1879048185l: retval = "DT_RELACOUNT"; break;
        case 1879048186l: retval = "DT_RELCOUNT"; break;
        case 1879048187l: retval = "DT_FLAGS_1"; break;
        case 1879048188l: retval = "DT_VERDEF"; break;
        case 1879048189l: retval = "DT_VERDEFNUM"; break;
        case 1879048190l: retval = "DT_VERNEED"; break;
        case 1879048191l: retval = "DT_VERNEEDNUM"; break;
        case 2147483645l: retval = "DT_AUXILIARY"; break;
        case 2147483647l: retval = "DT_FILTER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfDynamicEntry::EntryType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfDynamicEntry::EntryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfFileHeader::ObjectType is defined at frontend/SageIII/Cxx_Grammar.h:339743
/** Converts an enum of type SgAsmElfFileHeader::ObjectType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfFileHeaderObjectType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ET_NONE"; break;
        case 1l: retval = "ET_REL"; break;
        case 2l: retval = "ET_EXEC"; break;
        case 3l: retval = "ET_DYN"; break;
        case 4l: retval = "ET_CORE"; break;
        case 65024l: retval = "ET_LOOS"; break;
        case 65279l: retval = "ET_HIOS"; break;
        case 65280l: retval = "ET_LOPROC"; break;
        case 65535l: retval = "ET_HIPROC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfFileHeader::ObjectType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfFileHeader::ObjectType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfRelocEntry::RelocType is defined at frontend/SageIII/Cxx_Grammar.h:363964
/** Converts an enum of type SgAsmElfRelocEntry::RelocType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfRelocEntryRelocType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "R_386_NONE"; break;
        case 1l: retval = "R_386_32"; break;
        case 2l: retval = "R_386_PC32"; break;
        case 3l: retval = "R_386_GOT32"; break;
        case 4l: retval = "R_386_PLT32"; break;
        case 5l: retval = "R_386_COPY"; break;
        case 6l: retval = "R_386_GLOB_DAT"; break;
        case 7l: retval = "R_386_JMP_SLOT"; break;
        case 8l: retval = "R_386_RELATIVE"; break;
        case 9l: retval = "R_386_GOTOFF"; break;
        case 10l: retval = "R_386_GOTPC"; break;
        case 11l: retval = "R_386_32PLT"; break;
        case 14l: retval = "R_386_TLS_TPOFF"; break;
        case 15l: retval = "R_386_TLS_IE"; break;
        case 16l: retval = "R_386_TLS_GOTIE"; break;
        case 17l: retval = "R_386_TLS_LE"; break;
        case 18l: retval = "R_386_TLS_GD"; break;
        case 19l: retval = "R_386_TLS_LDM"; break;
        case 20l: retval = "R_386_16"; break;
        case 21l: retval = "R_386_PC16"; break;
        case 22l: retval = "R_386_8"; break;
        case 23l: retval = "R_386_PC8"; break;
        case 24l: retval = "R_386_TLS_GD_32"; break;
        case 25l: retval = "R_386_TLS_GD_PUSH"; break;
        case 26l: retval = "R_386_TLS_GD_CALL"; break;
        case 27l: retval = "R_386_TLS_GD_POP"; break;
        case 28l: retval = "R_386_TLS_LDM_32"; break;
        case 29l: retval = "R_386_TLS_LDM_PUSH"; break;
        case 30l: retval = "R_386_TLS_LDM_CALL"; break;
        case 31l: retval = "R_386_TLS_LDM_POP"; break;
        case 32l: retval = "R_386_TLS_LDO_32"; break;
        case 33l: retval = "R_386_TLS_IE_32"; break;
        case 34l: retval = "R_386_TLS_LE_32"; break;
        case 35l: retval = "R_386_TLS_DTPMOD32"; break;
        case 36l: retval = "R_386_TLS_DTPOFF32"; break;
        case 37l: retval = "R_386_TLS_TPOFF32"; break;
        case 100l: retval = "R_X86_64_NONE"; break;
        case 101l: retval = "R_X86_64_64"; break;
        case 102l: retval = "R_X86_64_PC32"; break;
        case 103l: retval = "R_X86_64_GOT32"; break;
        case 104l: retval = "R_X86_64_PLT32"; break;
        case 105l: retval = "R_X86_64_COPY"; break;
        case 106l: retval = "R_X86_64_GLOB_DAT"; break;
        case 107l: retval = "R_X86_64_JUMP_SLOT"; break;
        case 108l: retval = "R_X86_64_RELATIVE"; break;
        case 109l: retval = "R_X86_64_GOTPCREL"; break;
        case 110l: retval = "R_X86_64_32"; break;
        case 111l: retval = "R_X86_64_32S"; break;
        case 112l: retval = "R_X86_64_16"; break;
        case 113l: retval = "R_X86_64_PC16"; break;
        case 114l: retval = "R_X86_64_8"; break;
        case 115l: retval = "R_X86_64_PC8"; break;
        case 116l: retval = "R_X86_64_DTPMOD64"; break;
        case 117l: retval = "R_X86_64_DTPOFF64"; break;
        case 118l: retval = "R_X86_64_TPOFF64"; break;
        case 119l: retval = "R_X86_64_TLSGD"; break;
        case 120l: retval = "R_X86_64_TLSLD"; break;
        case 121l: retval = "R_X86_64_DTPOFF32"; break;
        case 122l: retval = "R_X86_64_GOTTPOFF"; break;
        case 123l: retval = "R_X86_64_TPOFF32"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfRelocEntry::RelocType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfRelocEntry::RelocType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSectionTableEntry::SectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:362208
/** Converts an enum of type SgAsmElfSectionTableEntry::SectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSectionTableEntrySectionFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SHF_NULL"; break;
        case 1l: retval = "SHF_WRITE"; break;
        case 2l: retval = "SHF_ALLOC"; break;
        case 4l: retval = "SHF_EXECINSTR"; break;
        case 16l: retval = "SHF_MERGE"; break;
        case 32l: retval = "SHF_STRINGS"; break;
        case 64l: retval = "SHF_INFO_LINK"; break;
        case 128l: retval = "SHF_LINK_ORDER"; break;
        case 256l: retval = "SHF_OS_NONCONFORMING"; break;
        case 512l: retval = "SHF_GROUP"; break;
        case 1024l: retval = "SHF_TLS"; break;
        case 267386880l: retval = "SHF_MASKOS"; break;
        case 4026531840l: retval = "SHF_MASKPROC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfSectionTableEntry::SectionFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSectionTableEntry::SectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSectionTableEntry::SectionType is defined at frontend/SageIII/Cxx_Grammar.h:362181
/** Converts an enum of type SgAsmElfSectionTableEntry::SectionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSectionTableEntrySectionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SHT_NULL"; break;
        case 1l: retval = "SHT_PROGBITS"; break;
        case 2l: retval = "SHT_SYMTAB"; break;
        case 3l: retval = "SHT_STRTAB"; break;
        case 4l: retval = "SHT_RELA"; break;
        case 5l: retval = "SHT_HASH"; break;
        case 6l: retval = "SHT_DYNAMIC"; break;
        case 7l: retval = "SHT_NOTE"; break;
        case 8l: retval = "SHT_NOBITS"; break;
        case 9l: retval = "SHT_REL"; break;
        case 10l: retval = "SHT_SHLIB"; break;
        case 11l: retval = "SHT_DYNSYM"; break;
        case 1610612736l: retval = "SHT_LOOS"; break;
        case 1879048189l: retval = "SHT_GNU_verdef"; break;
        case 1879048190l: retval = "SHT_GNU_verneed"; break;
        case 1879048191l: retval = "SHT_GNU_versym"; break;
        case 1879048192l: retval = "SHT_LOPROC"; break;
        case 2147483647l: retval = "SHT_HIPROC"; break;
        case 2147483648l: retval = "SHT_LOUSER"; break;
        case 4294967295l: retval = "SHT_HIUSER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfSectionTableEntry::SectionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSectionTableEntry::SectionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSegmentTableEntry::SegmentFlags is defined at frontend/SageIII/Cxx_Grammar.h:362874
/** Converts an enum of type SgAsmElfSegmentTableEntry::SegmentFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSegmentTableEntrySegmentFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PF_NONE"; break;
        case 1l: retval = "PF_XPERM"; break;
        case 2l: retval = "PF_WPERM"; break;
        case 4l: retval = "PF_RPERM"; break;
        case 1048568l: retval = "PF_RESERVED"; break;
        case 267386880l: retval = "PF_OS_MASK"; break;
        case 4026531840l: retval = "PF_PROC_MASK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfSegmentTableEntry::SegmentFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSegmentTableEntry::SegmentFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSegmentTableEntry::SegmentType is defined at frontend/SageIII/Cxx_Grammar.h:362846
/** Converts an enum of type SgAsmElfSegmentTableEntry::SegmentType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSegmentTableEntrySegmentType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PT_NULL"; break;
        case 1l: retval = "PT_LOAD"; break;
        case 2l: retval = "PT_DYNAMIC"; break;
        case 3l: retval = "PT_INTERP"; break;
        case 4l: retval = "PT_NOTE"; break;
        case 5l: retval = "PT_SHLIB"; break;
        case 6l: retval = "PT_PHDR"; break;
        case 7l: retval = "PT_TLS"; break;
        case 1610612736l: retval = "PT_LOOS"; break;
        case 1685382480l: retval = "PT_GNU_EH_FRAME"; break;
        case 1685382481l: retval = "PT_GNU_STACK"; break;
        case 1685382482l: retval = "PT_GNU_RELRO"; break;
        case 1694766464l: retval = "PT_PAX_FLAGS"; break;
        case 1879048186l: retval = "PT_SUNWBSS"; break;
        case 1879048187l: retval = "PT_SUNWSTACK"; break;
        case 1879048191l: retval = "PT_HIOS"; break;
        case 1879048192l: retval = "PT_LOPROC"; break;
        case 2147483647l: retval = "PT_HIPROC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfSegmentTableEntry::SegmentType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSegmentTableEntry::SegmentType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSymbol::ElfSymBinding is defined at frontend/SageIII/Cxx_Grammar.h:357270
/** Converts an enum of type SgAsmElfSymbol::ElfSymBinding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSymbolElfSymBinding(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "STB_LOCAL"; break;
        case 1l: retval = "STB_GLOBAL"; break;
        case 2l: retval = "STB_WEAK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfSymbol::ElfSymBinding)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSymbol::ElfSymBinding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSymbol::ElfSymType is defined at frontend/SageIII/Cxx_Grammar.h:357276
/** Converts an enum of type SgAsmElfSymbol::ElfSymType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSymbolElfSymType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "STT_NOTYPE"; break;
        case 1l: retval = "STT_OBJECT"; break;
        case 2l: retval = "STT_FUNC"; break;
        case 3l: retval = "STT_SECTION"; break;
        case 4l: retval = "STT_FILE"; break;
        case 5l: retval = "STT_COMMON"; break;
        case 6l: retval = "STT_TLS"; break;
        case 10l: retval = "STT_IFUNC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmElfSymbol::ElfSymType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSymbol::ElfSymType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecABI is defined at frontend/SageIII/Cxx_Grammar.h:331656
/** Converts an enum of type SgAsmExecutableFileFormat::ExecABI to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecABI(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ABI_UNSPECIFIED"; break;
        case 1l: retval = "ABI_OTHER"; break;
        case 2l: retval = "ABI_86OPEN"; break;
        case 3l: retval = "ABI_AIX"; break;
        case 4l: retval = "ABI_ARM"; break;
        case 5l: retval = "ABI_FREEBSD"; break;
        case 6l: retval = "ABI_HPUX"; break;
        case 7l: retval = "ABI_IRIX"; break;
        case 8l: retval = "ABI_HURD"; break;
        case 9l: retval = "ABI_LINUX"; break;
        case 10l: retval = "ABI_MODESTO"; break;
        case 11l: retval = "ABI_MONTEREY"; break;
        case 12l: retval = "ABI_MSDOS"; break;
        case 13l: retval = "ABI_NT"; break;
        case 14l: retval = "ABI_NETBSD"; break;
        case 15l: retval = "ABI_OS2"; break;
        case 16l: retval = "ABI_SOLARIS"; break;
        case 17l: retval = "ABI_SYSV"; break;
        case 18l: retval = "ABI_TRU64"; break;
        case 19l: retval = "ABI_WIN386"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmExecutableFileFormat::ExecABI)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecABI::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecFamily is defined at frontend/SageIII/Cxx_Grammar.h:331646
/** Converts an enum of type SgAsmExecutableFileFormat::ExecFamily to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecFamily(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FAMILY_UNSPECIFIED"; break;
        case 1l: retval = "FAMILY_DOS"; break;
        case 2l: retval = "FAMILY_ELF"; break;
        case 3l: retval = "FAMILY_LE"; break;
        case 4l: retval = "FAMILY_LX"; break;
        case 5l: retval = "FAMILY_NE"; break;
        case 6l: retval = "FAMILY_PE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmExecutableFileFormat::ExecFamily)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecFamily::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecPurpose is defined at frontend/SageIII/Cxx_Grammar.h:331859
/** Converts an enum of type SgAsmExecutableFileFormat::ExecPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecPurpose(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PURPOSE_UNSPECIFIED"; break;
        case 1l: retval = "PURPOSE_OTHER"; break;
        case 2l: retval = "PURPOSE_EXECUTABLE"; break;
        case 3l: retval = "PURPOSE_LIBRARY"; break;
        case 4l: retval = "PURPOSE_CORE_DUMP"; break;
        case 5l: retval = "PURPOSE_OS_SPECIFIC"; break;
        case 6l: retval = "PURPOSE_PROC_SPECIFIC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmExecutableFileFormat::ExecPurpose)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::InsSetArchitecture is defined at frontend/SageIII/Cxx_Grammar.h:331680
/** Converts an enum of type SgAsmExecutableFileFormat::InsSetArchitecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatInsSetArchitecture(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ISA_UNSPECIFIED"; break;
        case 256l: retval = "ISA_IA32_Family"; break;
        case 257l: retval = "ISA_IA32_286"; break;
        case 258l: retval = "ISA_IA32_386"; break;
        case 259l: retval = "ISA_IA32_486"; break;
        case 260l: retval = "ISA_IA32_Pentium"; break;
        case 261l: retval = "ISA_IA32_Cyrix6x86"; break;
        case 262l: retval = "ISA_IA32_AMDK5"; break;
        case 263l: retval = "ISA_IA32_PentiumPro"; break;
        case 264l: retval = "ISA_IA32_PentiumII"; break;
        case 265l: retval = "ISA_IA32_Athlon"; break;
        case 266l: retval = "ISA_IA32_Pentium4"; break;
        case 267l: retval = "ISA_IA32_PentiumM"; break;
        case 512l: retval = "ISA_X8664_Family"; break;
        case 513l: retval = "ISA_X8664_Athlon64"; break;
        case 514l: retval = "ISA_X8664_Prescott"; break;
        case 515l: retval = "ISA_X8664_IntelCore"; break;
        case 516l: retval = "ISA_X8664_AMDPhenom"; break;
        case 768l: retval = "ISA_SPARC_Family"; break;
        case 769l: retval = "ISA_SPARC_V7"; break;
        case 770l: retval = "ISA_SPARC_V8"; break;
        case 771l: retval = "ISA_SPARC_V8E"; break;
        case 772l: retval = "ISA_SPARC_V9"; break;
        case 773l: retval = "ISA_SPARC_V9JPS1"; break;
        case 774l: retval = "ISA_SPARC_V9UA"; break;
        case 775l: retval = "ISA_SPARC_V9JPS2"; break;
        case 1024l: retval = "ISA_M68K_Family"; break;
        case 1025l: retval = "ISA_M68K_68000"; break;
        case 1026l: retval = "ISA_M68K_68EC000"; break;
        case 1027l: retval = "ISA_M68K_68HC000"; break;
        case 1028l: retval = "ISA_M68K_68008"; break;
        case 1029l: retval = "ISA_M68K_68010"; break;
        case 1030l: retval = "ISA_M68K_68012"; break;
        case 1031l: retval = "ISA_M68K_68020"; break;
        case 1032l: retval = "ISA_M68K_68EC020"; break;
        case 1033l: retval = "ISA_M68K_68030"; break;
        case 1034l: retval = "ISA_M68K_68EC030"; break;
        case 1035l: retval = "ISA_M68K_68040"; break;
        case 1036l: retval = "ISA_M68K_68EC040"; break;
        case 1037l: retval = "ISA_M68K_68LC040"; break;
        case 1038l: retval = "ISA_M68K_68060"; break;
        case 1039l: retval = "ISA_M68K_ColdFire"; break;
        case 1040l: retval = "ISA_M68K_DragonBall"; break;
        case 1280l: retval = "ISA_M88K_Family"; break;
        case 1281l: retval = "ISA_M88K_88100"; break;
        case 1282l: retval = "ISA_M88K_88110"; break;
        case 1283l: retval = "ISA_M88K_88110MP"; break;
        case 1284l: retval = "ISA_M88K_88120"; break;
        case 1536l: retval = "ISA_MIPS_Family"; break;
        case 1537l: retval = "ISA_MIPS_MarkI"; break;
        case 1538l: retval = "ISA_MIPS_MarkII"; break;
        case 1539l: retval = "ISA_MIPS_MarkIII"; break;
        case 1540l: retval = "ISA_MIPS_R2000"; break;
        case 1541l: retval = "ISA_MIPS_R3000"; break;
        case 1542l: retval = "ISA_MIPS_R4000"; break;
        case 1543l: retval = "ISA_MIPS_R4200"; break;
        case 1544l: retval = "ISA_MIPS_R4300"; break;
        case 1545l: retval = "ISA_MIPS_R4600"; break;
        case 1546l: retval = "ISA_MIPS_R4650"; break;
        case 1547l: retval = "ISA_MIPS_R4700"; break;
        case 1548l: retval = "ISA_MIPS_R5000"; break;
        case 1549l: retval = "ISA_MIPS_RM7000"; break;
        case 1550l: retval = "ISA_MIPS_R8000"; break;
        case 1551l: retval = "ISA_MIPS_R10000"; break;
        case 1552l: retval = "ISA_MIPS_R12000"; break;
        case 1553l: retval = "ISA_MIPS_R14000"; break;
        case 1554l: retval = "ISA_MIPS_R16000"; break;
        case 1555l: retval = "ISA_MIPS_R16000A"; break;
        case 1556l: retval = "ISA_MIPS_16"; break;
        case 1557l: retval = "ISA_MIPS_FPU"; break;
        case 1558l: retval = "ISA_MIPS_16FPU"; break;
        case 1792l: retval = "ISA_I860_Family"; break;
        case 1793l: retval = "ISA_I860_860XR"; break;
        case 1794l: retval = "ISA_I860_860XP"; break;
        case 2048l: retval = "ISA_IA64_Family"; break;
        case 2049l: retval = "ISA_IA64_Itanium"; break;
        case 2050l: retval = "ISA_IA64_Itanium2"; break;
        case 2304l: retval = "ISA_ARM_Family"; break;
        case 2305l: retval = "ISA_ARM_ARM1"; break;
        case 2306l: retval = "ISA_ARM_ARM2"; break;
        case 2307l: retval = "ISA_ARM_ARM3"; break;
        case 2308l: retval = "ISA_ARM_ARM6"; break;
        case 2309l: retval = "ISA_ARM_ARM7"; break;
        case 2310l: retval = "ISA_ARM_ARM7TDMI"; break;
        case 2311l: retval = "ISA_ARM_StrongARM"; break;
        case 2312l: retval = "ISA_ARM_ARM8"; break;
        case 2313l: retval = "ISA_ARM_ARM9TDMI"; break;
        case 2314l: retval = "ISA_ARM_ARM9E"; break;
        case 2315l: retval = "ISA_ARM_ARM10E"; break;
        case 2316l: retval = "ISA_ARM_XScale"; break;
        case 2317l: retval = "ISA_ARM_ARM11"; break;
        case 2318l: retval = "ISA_ARM_Cortex"; break;
        case 61440l: retval = "ISA_OTHER_Family"; break;
        case 61441l: retval = "ISA_ATT_WE_32100"; break;
        case 61442l: retval = "ISA_IBM_System_370"; break;
        case 61443l: retval = "ISA_HPPA"; break;
        case 61444l: retval = "ISA_Fujitsu_VPP500"; break;
        case 61445l: retval = "ISA_Sun_v8plus"; break;
        case 61446l: retval = "ISA_PowerPC"; break;
        case 61447l: retval = "ISA_PowerPC_64bit"; break;
        case 61448l: retval = "ISA_IBM_S390"; break;
        case 61449l: retval = "ISA_NEC_V800_series"; break;
        case 61450l: retval = "ISA_Fujitsu_FR20"; break;
        case 61451l: retval = "ISA_TRW_RH_32"; break;
        case 61452l: retval = "ISA_Motorola_RCE"; break;
        case 61454l: retval = "ISA_Digital_Alpha_fake"; break;
        case 61455l: retval = "ISA_Hitachi_SH"; break;
        case 61456l: retval = "ISA_Siemens_Tricore"; break;
        case 61457l: retval = "ISA_Argonaut_RISC_Core"; break;
        case 61458l: retval = "ISA_Hitachi_H8_300"; break;
        case 61459l: retval = "ISA_Hitachi_H8_300H"; break;
        case 61460l: retval = "ISA_Hitachi_H8S"; break;
        case 61461l: retval = "ISA_Hitachi_H8_500"; break;
        case 61462l: retval = "ISA_Stanford_MIPS_X"; break;
        case 61463l: retval = "ISA_Motorola_M68HC12"; break;
        case 61464l: retval = "ISA_Fujitsu_MMA_Multimedia_Accelerator"; break;
        case 61465l: retval = "ISA_Siemens_PCP"; break;
        case 61466l: retval = "ISA_Sony_nCPU_embeeded_RISC"; break;
        case 61467l: retval = "ISA_Denso_NDR1_microprocessor"; break;
        case 61468l: retval = "ISA_Motorola_Start_Core_processor"; break;
        case 61469l: retval = "ISA_Toyota_ME16_processor"; break;
        case 61470l: retval = "ISA_STMicroelectronic_ST100_processor"; break;
        case 61471l: retval = "ISA_Advanced_Logic_Corp_Tinyj_emb_family"; break;
        case 61472l: retval = "ISA_AMD_x86_64_architecture"; break;
        case 61473l: retval = "ISA_Sony_DSP_Processor"; break;
        case 61474l: retval = "ISA_Siemens_FX66_microcontroller"; break;
        case 61475l: retval = "ISA_STMicroelectronics_ST9_plus_8_16_microcontroller"; break;
        case 61476l: retval = "ISA_STMicroelectronics_ST7_8bit_microcontroller"; break;
        case 61477l: retval = "ISA_Motorola_MC68HC16_microcontroller"; break;
        case 61478l: retval = "ISA_Motorola_MC68HC11_microcontroller"; break;
        case 61479l: retval = "ISA_Motorola_MC68HC08_microcontroller"; break;
        case 61480l: retval = "ISA_Motorola_MC68HC05_microcontroller"; break;
        case 61481l: retval = "ISA_Silicon_Graphics_SVx"; break;
        case 61482l: retval = "ISA_STMicroelectronics_ST19_8bit_microcontroller"; break;
        case 61483l: retval = "ISA_Digital_VAX"; break;
        case 61484l: retval = "ISA_Axis_Communications_32bit_embedded_processor"; break;
        case 61485l: retval = "ISA_Infineon_Technologies_32bit_embedded_processor"; break;
        case 61486l: retval = "ISA_Element_14_64bit_DSP_Processor"; break;
        case 61487l: retval = "ISA_LSI_Logic_16bit_DSP_Processor"; break;
        case 61488l: retval = "ISA_Donald_Knuths_educational_64bit_processor"; break;
        case 61489l: retval = "ISA_Harvard_University_machine_independent_object_files"; break;
        case 61490l: retval = "ISA_SiTera_Prism"; break;
        case 61491l: retval = "ISA_Atmel_AVR_8bit_microcontroller"; break;
        case 61492l: retval = "ISA_Fujitsu_FR30"; break;
        case 61493l: retval = "ISA_Mitsubishi_D10V"; break;
        case 61494l: retval = "ISA_Mitsubishi_D30V"; break;
        case 61495l: retval = "ISA_NEC_v850"; break;
        case 61496l: retval = "ISA_Mitsubishi_M32R"; break;
        case 61497l: retval = "ISA_Matsushita_MN10300"; break;
        case 61498l: retval = "ISA_Matsushita_MN10200"; break;
        case 61499l: retval = "ISA_picoJava"; break;
        case 61500l: retval = "ISA_OpenRISC_32bit_embedded_processor"; break;
        case 61501l: retval = "ISA_ARC_Cores_Tangent_A5"; break;
        case 61502l: retval = "ISA_Tensilica_Xtensa_Architecture"; break;
        case 61503l: retval = "ISA_Digital_Alpha"; break;
        case 61504l: retval = "ISA_Matsushita_AM33"; break;
        case 61505l: retval = "ISA_EFI_ByteCode"; break;
        case 65280l: retval = "ISA_FAMILY_MASK"; break;
        case 65535l: retval = "ISA_OTHER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmExecutableFileFormat::InsSetArchitecture)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::InsSetArchitecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmFunction::FunctionReason is defined at frontend/SageIII/Cxx_Grammar.h:307301
/** Converts an enum of type SgAsmFunction::FunctionReason to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionFunctionReason(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FUNC_NONE"; break;
        case 1l: retval = "FUNC_INTERPADFUNC"; break;
        case 255l: retval = "FUNC_MISCMASK"; break;
        case 32768l: retval = "FUNC_EXCEPTION_HANDLER"; break;
        case 65536l: retval = "FUNC_ENTRY_POINT"; break;
        case 131072l: retval = "FUNC_CALL_TARGET"; break;
        case 262144l: retval = "FUNC_CALL_INSN"; break;
        case 524288l: retval = "FUNC_EH_FRAME"; break;
        case 1048576l: retval = "FUNC_SYMBOL"; break;
        case 2097152l: retval = "FUNC_PATTERN"; break;
        case 4194304l: retval = "FUNC_GRAPH"; break;
        case 8388608l: retval = "FUNC_USERDEF"; break;
        case 16777216l: retval = "FUNC_PADDING"; break;
        case 33554432l: retval = "FUNC_DISCONT"; break;
        case 67108864l: retval = "FUNC_INSNHEAD"; break;
        case 134217728l: retval = "FUNC_IMPORT"; break;
        case 268435456l: retval = "FUNC_LEFTOVERS"; break;
        case 536870912l: retval = "FUNC_INTRABLOCK"; break;
        case 1073741824l: retval = "FUNC_THUNK"; break;
        case 2147483648l: retval = "FUNC_EXPORT"; break;
        case 4026499327l: retval = "FUNC_DEFAULT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmFunction::FunctionReason)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunction::FunctionReason::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmFunction::MayReturn is defined at frontend/SageIII/Cxx_Grammar.h:307291
/** Converts an enum of type SgAsmFunction::MayReturn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionMayReturn(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RET_UNKNOWN"; break;
        case 1l: retval = "RET_NEVER"; break;
        case 2l: retval = "RET_SOMETIMES"; break;
        case 3l: retval = "RET_ALWAYS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmFunction::MayReturn)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunction::MayReturn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmFunction::function_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:307406
/** Converts an enum of type SgAsmFunction::function_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunction_function_kind_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_standard"; break;
        case 2l: retval = "e_library"; break;
        case 3l: retval = "e_imported"; break;
        case 4l: retval = "e_thunk"; break;
        case 5l: retval = "e_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmFunction::function_kind_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunction::function_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericFile::AddressSpace is defined at frontend/SageIII/Cxx_Grammar.h:334433
/** Converts an enum of type SgAsmGenericFile::AddressSpace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericFileAddressSpace(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "ADDRSP_MEMORY"; break;
        case 2l: retval = "ADDRSP_FILE"; break;
        case 3l: retval = "ADDRSP_ALL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmGenericFile::AddressSpace)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericFile::AddressSpace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericFile::Elasticity is defined at frontend/SageIII/Cxx_Grammar.h:334438
/** Converts an enum of type SgAsmGenericFile::Elasticity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericFileElasticity(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ELASTIC_NONE"; break;
        case 1l: retval = "ELASTIC_UNREF"; break;
        case 2l: retval = "ELASTIC_HOLE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmGenericFile::Elasticity)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericFile::Elasticity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSection::SectionPurpose is defined at frontend/SageIII/Cxx_Grammar.h:335037
/** Converts an enum of type SgAsmGenericSection::SectionPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSectionSectionPurpose(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SP_UNSPECIFIED"; break;
        case 1l: retval = "SP_PROGRAM"; break;
        case 2l: retval = "SP_HEADER"; break;
        case 3l: retval = "SP_SYMTAB"; break;
        case 4l: retval = "SP_OTHER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmGenericSection::SectionPurpose)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSection::SectionPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolBinding is defined at frontend/SageIII/Cxx_Grammar.h:356159
/** Converts an enum of type SgAsmGenericSymbol::SymbolBinding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolBinding(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SYM_NO_BINDING"; break;
        case 1l: retval = "SYM_LOCAL"; break;
        case 2l: retval = "SYM_GLOBAL"; break;
        case 3l: retval = "SYM_WEAK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmGenericSymbol::SymbolBinding)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolBinding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolDefState is defined at frontend/SageIII/Cxx_Grammar.h:356140
/** Converts an enum of type SgAsmGenericSymbol::SymbolDefState to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolDefState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SYM_UNDEFINED"; break;
        case 1l: retval = "SYM_TENTATIVE"; break;
        case 2l: retval = "SYM_DEFINED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmGenericSymbol::SymbolDefState)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolDefState::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolType is defined at frontend/SageIII/Cxx_Grammar.h:356146
/** Converts an enum of type SgAsmGenericSymbol::SymbolType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SYM_NO_TYPE"; break;
        case 1l: retval = "SYM_DATA"; break;
        case 2l: retval = "SYM_FUNC"; break;
        case 3l: retval = "SYM_SECTION"; break;
        case 4l: retval = "SYM_FILE"; break;
        case 5l: retval = "SYM_ARRAY"; break;
        case 6l: retval = "SYM_TLS"; break;
        case 7l: retval = "SYM_REGISTER"; break;
        case 8l: retval = "SYM_COMMON"; break;
        case 9l: retval = "SYM_IFUNC"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmGenericSymbol::SymbolType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmLEFileHeader::LEFileHeaderFlags is defined at frontend/SageIII/Cxx_Grammar.h:337326
/** Converts an enum of type SgAsmLEFileHeader::LEFileHeaderFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmLEFileHeaderLEFileHeaderFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "HF_MODTYPE_PROG"; break;
        case 4l: retval = "HF_PROC_LIB_INIT"; break;
        case 16l: retval = "HF_IFIXUPS_APPLIED"; break;
        case 32l: retval = "HF_EFIXUPS_APPLIED"; break;
        case 256l: retval = "HF_PM_WINDOW_NO"; break;
        case 512l: retval = "HF_PM_WINDOW_OK"; break;
        case 768l: retval = "HF_PM_WINDOW_USE"; break;
        case 8192l: retval = "HF_NOT_LOADABLE"; break;
        case 32768l: retval = "HF_MODTYPE_LIB"; break;
        case 98304l: retval = "HF_MODTYPE_PLIB"; break;
        case 131072l: retval = "HF_MODTYPE_PDEV"; break;
        case 163840l: retval = "HF_MODTYPE_VDEV"; break;
        case 229376l: retval = "HF_MODTYPE_MASK"; break;
        case 1073741824l: retval = "HF_PROC_LIB_TERM"; break;
        case 3220987083l: retval = "HF_RESERVED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmLEFileHeader::LEFileHeaderFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmLEFileHeader::LEFileHeaderFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmLESectionTableEntry::LESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:381611
/** Converts an enum of type SgAsmLESectionTableEntry::LESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmLESectionTableEntryLESectionFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SF_TYPE_NORMAL"; break;
        case 1l: retval = "SF_READABLE"; break;
        case 2l: retval = "SF_WRITABLE"; break;
        case 4l: retval = "SF_EXECUTABLE"; break;
        case 8l: retval = "SF_RESOURCE"; break;
        case 16l: retval = "SF_DISCARDABLE"; break;
        case 32l: retval = "SF_SHARED"; break;
        case 64l: retval = "SF_PRELOAD_PAGES"; break;
        case 128l: retval = "SF_INVALID_PAGES"; break;
        case 256l: retval = "SF_TYPE_ZERO"; break;
        case 512l: retval = "SF_TYPE_RESIDENT"; break;
        case 768l: retval = "SF_TYPE_RESCONT"; break;
        case 1024l: retval = "SF_RES_LONG_LOCK"; break;
        case 4096l: retval = "SF_1616_ALIAS"; break;
        case 8192l: retval = "SF_BIG_BIT"; break;
        case 16384l: retval = "SF_CODE_CONFORM"; break;
        case 32768l: retval = "SF_IO_PRIV"; break;
        case 4294903808l: retval = "SF_RESERVED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmLESectionTableEntry::LESectionFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmLESectionTableEntry::LESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNEEntryPoint::NEEntryFlags is defined at frontend/SageIII/Cxx_Grammar.h:378335
/** Converts an enum of type SgAsmNEEntryPoint::NEEntryFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEEntryPointNEEntryFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "EF_ZERO"; break;
        case 1l: retval = "EF_EXPORTED"; break;
        case 2l: retval = "EF_GLOBAL"; break;
        case 252l: retval = "EF_RESERVED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNEEntryPoint::NEEntryFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEEntryPoint::NEEntryFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNEFileHeader::HeaderFlags1 is defined at frontend/SageIII/Cxx_Grammar.h:338308
/** Converts an enum of type SgAsmNEFileHeader::HeaderFlags1 to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEFileHeaderHeaderFlags1(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "HF1_NO_DATA"; break;
        case 1l: retval = "HF1_SINGLE_DATA"; break;
        case 2l: retval = "HF1_MULTIPLE_DATA"; break;
        case 2048l: retval = "HF1_LOADER_SEGMENT"; break;
        case 8192l: retval = "HF1_FATAL_ERRORS"; break;
        case 22516l: retval = "HF1_RESERVED"; break;
        case 32768l: retval = "HF1_LIBRARY"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNEFileHeader::HeaderFlags1)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEFileHeader::HeaderFlags1::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNEFileHeader::HeaderFlags2 is defined at frontend/SageIII/Cxx_Grammar.h:338319
/** Converts an enum of type SgAsmNEFileHeader::HeaderFlags2 to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEFileHeaderHeaderFlags2(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 2l: retval = "HF2_PROTECTED_MODE"; break;
        case 4l: retval = "HF2_PFONTS"; break;
        case 8l: retval = "HF2_FASTLOAD"; break;
        case 241l: retval = "HF2_RESERVED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNEFileHeader::HeaderFlags2)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEFileHeader::HeaderFlags2::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocFlags is defined at frontend/SageIII/Cxx_Grammar.h:378879
/** Converts an enum of type SgAsmNERelocEntry::NERelocFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "RF_ADDITIVE"; break;
        case 2l: retval = "RF_RESERVED"; break;
        case 4l: retval = "RF_2EXTRA"; break;
        case 8l: retval = "RF_32ADD"; break;
        case 16l: retval = "RF_16SECTION"; break;
        case 32l: retval = "RF_8ORDINAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNERelocEntry::NERelocFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocModifiers is defined at frontend/SageIII/Cxx_Grammar.h:378874
/** Converts an enum of type SgAsmNERelocEntry::NERelocModifiers to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocModifiers(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "RF_MODIFIER_SINGLE"; break;
        case 3l: retval = "RF_MODIFIER_MULTI"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNERelocEntry::NERelocModifiers)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocModifiers::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocSrcType is defined at frontend/SageIII/Cxx_Grammar.h:378855
/** Converts an enum of type SgAsmNERelocEntry::NERelocSrcType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocSrcType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RF_SRCTYPE_8OFF"; break;
        case 2l: retval = "RF_SRCTYPE_WORDSEG"; break;
        case 3l: retval = "RF_SRCTYPE_16PTR"; break;
        case 5l: retval = "RF_SRCTYPE_16OFF"; break;
        case 6l: retval = "RF_SRCTYPE_32PTR"; break;
        case 7l: retval = "RF_SRCTYPE_32OFF"; break;
        case 8l: retval = "RF_SRCTYPE_NEARCALL"; break;
        case 11l: retval = "RF_SRCTYPE_48PTR"; break;
        case 13l: retval = "RF_SRCTYPE_32OFF_b"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNERelocEntry::NERelocSrcType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocSrcType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocTgtType is defined at frontend/SageIII/Cxx_Grammar.h:378867
/** Converts an enum of type SgAsmNERelocEntry::NERelocTgtType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocTgtType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "RF_TGTTYPE_IREF"; break;
        case 1l: retval = "RF_TGTTYPE_IORD"; break;
        case 2l: retval = "RF_TGTTYPE_INAME"; break;
        case 3l: retval = "RF_TGTTYPE_OSFIXUP"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNERelocEntry::NERelocTgtType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocTgtType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNESectionTableEntry::NESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:379511
/** Converts an enum of type SgAsmNESectionTableEntry::NESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNESectionTableEntryNESectionFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "SF_CODE"; break;
        case 1l: retval = "SF_DATA"; break;
        case 2l: retval = "SF_ALLOC"; break;
        case 4l: retval = "SF_LOAD"; break;
        case 7l: retval = "SF_TYPE_MASK"; break;
        case 16l: retval = "SF_MOVABLE"; break;
        case 32l: retval = "SF_PURE"; break;
        case 64l: retval = "SF_PRELOAD"; break;
        case 128l: retval = "SF_NOT_WRITABLE"; break;
        case 256l: retval = "SF_RELOCINFO"; break;
        case 3592l: retval = "SF_RESERVED"; break;
        case 4096l: retval = "SF_DISCARDABLE"; break;
        case 61440l: retval = "SF_DISCARD"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmNESectionTableEntry::NESectionFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNESectionTableEntry::NESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmOp::asm_operand_constraint_enum is defined at frontend/SageIII/Cxx_Grammar.h:273350
/** Converts an enum of type SgAsmOp::asm_operand_constraint_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmOp_asm_operand_constraint_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_invalid"; break;
        case 1l: retval = "e_any"; break;
        case 2l: retval = "e_general"; break;
        case 3l: retval = "e_match_0"; break;
        case 4l: retval = "aoc_match_1"; break;
        case 5l: retval = "aoc_match_2"; break;
        case 6l: retval = "aoc_match_3"; break;
        case 7l: retval = "aoc_match_4"; break;
        case 8l: retval = "e_match_5"; break;
        case 9l: retval = "aoc_match_6"; break;
        case 10l: retval = "aoc_match_7"; break;
        case 11l: retval = "aoc_match_8"; break;
        case 12l: retval = "aoc_match_9"; break;
        case 13l: retval = "e_reg_integer"; break;
        case 14l: retval = "e_reg_float"; break;
        case 15l: retval = "e_mem_any"; break;
        case 16l: retval = "e_mem_offset"; break;
        case 17l: retval = "e_mem_nonoffset"; break;
        case 18l: retval = "e_mem_autoinc"; break;
        case 19l: retval = "e_mem_autodec"; break;
        case 20l: retval = "e_imm_int"; break;
        case 21l: retval = "e_imm_number"; break;
        case 22l: retval = "e_imm_symbol"; break;
        case 23l: retval = "e_imm_float"; break;
        case 24l: retval = "e_reg_a"; break;
        case 25l: retval = "e_reg_b"; break;
        case 26l: retval = "e_reg_c"; break;
        case 27l: retval = "e_reg_d"; break;
        case 28l: retval = "e_reg_si"; break;
        case 29l: retval = "e_reg_di"; break;
        case 30l: retval = "e_reg_legacy"; break;
        case 31l: retval = "e_reg_q"; break;
        case 32l: retval = "e_reg_ad"; break;
        case 33l: retval = "e_reg_float_tos"; break;
        case 34l: retval = "e_reg_float_second"; break;
        case 35l: retval = "e_reg_sse"; break;
        case 36l: retval = "e_reg_sse2"; break;
        case 37l: retval = "e_reg_mmx"; break;
        case 38l: retval = "e_imm_short_shift"; break;
        case 39l: retval = "e_imm_long_shift"; break;
        case 40l: retval = "e_imm_lea_shift"; break;
        case 41l: retval = "e_imm_signed8"; break;
        case 42l: retval = "e_imm_unsigned8"; break;
        case 43l: retval = "e_imm_and_zext"; break;
        case 44l: retval = "e_imm_80387"; break;
        case 45l: retval = "e_imm_sse"; break;
        case 46l: retval = "e_imm_sext32"; break;
        case 47l: retval = "e_imm_zext32"; break;
        case 48l: retval = "e_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmOp::asm_operand_constraint_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmOp::asm_operand_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:273331
/** Converts an enum of type SgAsmOp::asm_operand_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmOp_asm_operand_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_input"; break;
        case 2l: retval = "e_output"; break;
        case 3l: retval = "e_modify"; break;
        case 4l: retval = "e_earlyclobber"; break;
        case 8l: retval = "e_commutative"; break;
        case 16l: retval = "e_ignore_next"; break;
        case 32l: retval = "e_ignore_till_comma"; break;
        case 64l: retval = "e_poor_choice"; break;
        case 128l: retval = "e_bad_choice"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmOp::asm_operand_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::DLLFlags is defined at frontend/SageIII/Cxx_Grammar.h:336430
/** Converts an enum of type SgAsmPEFileHeader::DLLFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderDLLFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "DLL_PROC_INIT"; break;
        case 2l: retval = "DLL_PROC_TERM"; break;
        case 4l: retval = "DLL_THRD_INIT"; break;
        case 8l: retval = "DLL_THRD_TERM"; break;
        case 65520l: retval = "DLL_RESERVED_MASK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmPEFileHeader::DLLFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::DLLFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::HeaderFlags is defined at frontend/SageIII/Cxx_Grammar.h:336411
/** Converts an enum of type SgAsmPEFileHeader::HeaderFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderHeaderFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "HF_PROGRAM"; break;
        case 2l: retval = "HF_EXECUTABLE"; break;
        case 512l: retval = "HF_FIXED"; break;
        case 8192l: retval = "HF_LIBRARY"; break;
        case 56829l: retval = "HF_RESERVED_MASK"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmPEFileHeader::HeaderFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::HeaderFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::PairPurpose is defined at frontend/SageIII/Cxx_Grammar.h:336439
/** Converts an enum of type SgAsmPEFileHeader::PairPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderPairPurpose(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PAIR_EXPORTS"; break;
        case 1l: retval = "PAIR_IMPORTS"; break;
        case 2l: retval = "PAIR_RESOURCES"; break;
        case 3l: retval = "PAIR_EXCEPTIONS"; break;
        case 4l: retval = "PAIR_CERTIFICATES"; break;
        case 5l: retval = "PAIR_BASERELOCS"; break;
        case 6l: retval = "PAIR_DEBUG"; break;
        case 7l: retval = "PAIR_ARCHITECTURE"; break;
        case 8l: retval = "PAIR_GLOBALPTR"; break;
        case 9l: retval = "PAIR_TLS"; break;
        case 10l: retval = "PAIR_LOADCONFIG"; break;
        case 11l: retval = "PAIR_BOUNDIMPORT"; break;
        case 12l: retval = "PAIR_IAT"; break;
        case 13l: retval = "PAIR_DELAYIMPORT"; break;
        case 14l: retval = "PAIR_CLRRUNTIME"; break;
        case 15l: retval = "PAIR_RESERVED15"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmPEFileHeader::PairPurpose)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::PairPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::Subsystem is defined at frontend/SageIII/Cxx_Grammar.h:336420
/** Converts an enum of type SgAsmPEFileHeader::Subsystem to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderSubsystem(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "HF_SPEC_UNKNOWN"; break;
        case 1l: retval = "HF_NATIVE"; break;
        case 2l: retval = "HF_WINGUI"; break;
        case 3l: retval = "HF_WINCHAR"; break;
        case 5l: retval = "HF_OS2CHAR"; break;
        case 7l: retval = "HF_POSIX"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmPEFileHeader::Subsystem)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::Subsystem::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPESectionTableEntry::PESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:374629
/** Converts an enum of type SgAsmPESectionTableEntry::PESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPESectionTableEntryPESectionFlags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 32l: retval = "OF_CODE"; break;
        case 64l: retval = "OF_IDATA"; break;
        case 128l: retval = "OF_UDATA"; break;
        case 512l: retval = "OF_INFO"; break;
        case 2048l: retval = "OF_REMOVE"; break;
        case 4096l: retval = "OF_COMDAT"; break;
        case 16384l: retval = "OF_NO_DEFER_SPEC_EXC"; break;
        case 32768l: retval = "OF_GPREL"; break;
        case 1048576l: retval = "OF_ALIGN_1"; break;
        case 2097152l: retval = "OF_ALIGN_2"; break;
        case 3145728l: retval = "OF_ALIGN_4"; break;
        case 4194304l: retval = "OF_ALIGN_8"; break;
        case 5242880l: retval = "OF_ALIGN_16"; break;
        case 6291456l: retval = "OF_ALIGN_32"; break;
        case 7340032l: retval = "OF_ALIGN_64"; break;
        case 8388608l: retval = "OF_ALIGN_128"; break;
        case 9437184l: retval = "OF_ALIGN_256"; break;
        case 10485760l: retval = "OF_ALIGN_512"; break;
        case 11534336l: retval = "OF_ALIGN_1k"; break;
        case 12582912l: retval = "OF_ALIGN_2k"; break;
        case 13631488l: retval = "OF_ALIGN_4k"; break;
        case 14680064l: retval = "OF_ALIGN_8k"; break;
        case 15728640l: retval = "OF_ALIGN_MASK"; break;
        case 16777216l: retval = "OF_NRELOC_OVFL"; break;
        case 33554432l: retval = "OF_DISCARDABLE"; break;
        case 67108864l: retval = "OF_NO_CACHE"; break;
        case 134217728l: retval = "OF_NO_PAGING"; break;
        case 268435456l: retval = "OF_SHARED"; break;
        case 536870912l: retval = "OF_EXECUTABLE"; break;
        case 1073741824l: retval = "OF_READABLE"; break;
        case 2147483648l: retval = "OF_WRITABLE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmPESectionTableEntry::PESectionFlags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPESectionTableEntry::PESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmRiscOperation::RiscOperator is defined at frontend/SageIII/Cxx_Grammar.h:327604
/** Converts an enum of type SgAsmRiscOperation::RiscOperator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmRiscOperationRiscOperator(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "OP_NONE"; break;
        case 1l: retval = "OP_bottom"; break;
        case 2l: retval = "OP_undefined"; break;
        case 3l: retval = "OP_unspecified"; break;
        case 4l: retval = "OP_filterCallTarget"; break;
        case 5l: retval = "OP_filterReturnTarget"; break;
        case 6l: retval = "OP_filterIndirectJumpTarget"; break;
        case 7l: retval = "OP_hlt"; break;
        case 8l: retval = "OP_cpuid"; break;
        case 9l: retval = "OP_rdtsc"; break;
        case 10l: retval = "OP_and_"; break;
        case 11l: retval = "OP_or_"; break;
        case 12l: retval = "OP_xor_"; break;
        case 13l: retval = "OP_invert"; break;
        case 14l: retval = "OP_extract"; break;
        case 15l: retval = "OP_concat"; break;
        case 16l: retval = "OP_leastSignificantSetBit"; break;
        case 17l: retval = "OP_mostSignificantSetBit"; break;
        case 18l: retval = "OP_rotateLeft"; break;
        case 19l: retval = "OP_rotateRight"; break;
        case 20l: retval = "OP_shiftLeft"; break;
        case 21l: retval = "OP_shiftRight"; break;
        case 22l: retval = "OP_shiftRightArithmetic"; break;
        case 23l: retval = "OP_equalToZero"; break;
        case 24l: retval = "OP_ite"; break;
        case 25l: retval = "OP_isEqual"; break;
        case 26l: retval = "OP_isNotEqual"; break;
        case 27l: retval = "OP_isUnsignedLessThan"; break;
        case 28l: retval = "OP_isUnsignedLessThanOrEqual"; break;
        case 29l: retval = "OP_isUnsignedGreaterThan"; break;
        case 30l: retval = "OP_isUnsignedGreaterThanOrEqual"; break;
        case 31l: retval = "OP_isSignedLessThan"; break;
        case 32l: retval = "OP_isSignedLessThanOrEqual"; break;
        case 33l: retval = "OP_isSignedGreaterThan"; break;
        case 34l: retval = "OP_isSignedGreaterThanOrEqual"; break;
        case 35l: retval = "OP_unsignedExtend"; break;
        case 36l: retval = "OP_signExtend"; break;
        case 37l: retval = "OP_add"; break;
        case 38l: retval = "OP_addCarries"; break;
        case 39l: retval = "OP_subtract"; break;
        case 40l: retval = "OP_negate"; break;
        case 41l: retval = "OP_signedDivide"; break;
        case 42l: retval = "OP_signedModulo"; break;
        case 43l: retval = "OP_signedMultiply"; break;
        case 44l: retval = "OP_unsignedDivide"; break;
        case 45l: retval = "OP_unsignedModulo"; break;
        case 46l: retval = "OP_unsignedMultiply"; break;
        case 47l: retval = "OP_interrupt"; break;
        case 48l: retval = "OP_readRegister"; break;
        case 49l: retval = "OP_writeRegister"; break;
        case 50l: retval = "OP_readMemory"; break;
        case 51l: retval = "OP_writeMemory"; break;
        case 52l: retval = "OP_N_OPERATORS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAsmRiscOperation::RiscOperator)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmRiscOperation::RiscOperator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAttributeSpecificationStatement::attribute_spec_enum is defined at frontend/SageIII/Cxx_Grammar.h:134685
/** Converts an enum of type SgAttributeSpecificationStatement::attribute_spec_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAttributeSpecificationStatement_attribute_spec_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_attribute_spec"; break;
        case 1l: retval = "e_accessStatement_private"; break;
        case 2l: retval = "e_accessStatement_public"; break;
        case 3l: retval = "e_allocatableStatement"; break;
        case 4l: retval = "e_asynchronousStatement"; break;
        case 5l: retval = "e_bindStatement"; break;
        case 6l: retval = "e_dataStatement"; break;
        case 7l: retval = "e_dimensionStatement"; break;
        case 8l: retval = "e_externalStatement"; break;
        case 9l: retval = "e_intentStatement"; break;
        case 10l: retval = "e_intrinsicStatement"; break;
        case 11l: retval = "e_optionalStatement"; break;
        case 12l: retval = "e_parameterStatement"; break;
        case 13l: retval = "e_pointerStatement"; break;
        case 14l: retval = "e_protectedStatement"; break;
        case 15l: retval = "e_saveStatement"; break;
        case 16l: retval = "e_targetStatement"; break;
        case 17l: retval = "e_valueStatement"; break;
        case 18l: retval = "e_volatileStatement"; break;
        case 19l: retval = "e_last_attribute_spec"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgAttributeSpecificationStatement::attribute_spec_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgBaseClassModifier::baseclass_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:15321
/** Converts an enum of type SgBaseClassModifier::baseclass_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgBaseClassModifier_baseclass_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_virtual"; break;
        case 3l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgBaseClassModifier::baseclass_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgCastExp::cast_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:207855
/** Converts an enum of type SgCastExp::cast_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgCastExp_cast_type_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_C_style_cast"; break;
        case 3l: retval = "e_const_cast"; break;
        case 4l: retval = "e_static_cast"; break;
        case 5l: retval = "e_dynamic_cast"; break;
        case 6l: retval = "e_reinterpret_cast"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgCastExp::cast_type_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgCastExp::cast_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgClassDeclaration::class_types is defined at frontend/SageIII/Cxx_Grammar.h:144027
/** Converts an enum of type SgClassDeclaration::class_types to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgClassDeclaration_class_types(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_class"; break;
        case 1l: retval = "e_struct"; break;
        case 2l: retval = "e_union"; break;
        case 3l: retval = "e_template_parameter"; break;
        case 4l: retval = "e_java_interface"; break;
        case 5l: retval = "e_java_enum"; break;
        case 6l: retval = "e_java_parameter"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgClassDeclaration::class_types)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgClassDeclaration::class_types::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgConstVolatileModifier::cv_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:10744
/** Converts an enum of type SgConstVolatileModifier::cv_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgConstVolatileModifier_cv_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_const"; break;
        case 3l: retval = "e_volatile"; break;
        case 4l: retval = "e_java_transient"; break;
        case 5l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgConstVolatileModifier::cv_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDataStatementValue::data_statement_value_enum is defined at frontend/SageIII/Cxx_Grammar.h:45117
/** Converts an enum of type SgDataStatementValue::data_statement_value_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDataStatementValue_data_statement_value_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_explict_list"; break;
        case 3l: retval = "e_implicit_list"; break;
        case 4l: retval = "e_implied_do"; break;
        case 5l: retval = "e_last_initializer_form"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgDataStatementValue::data_statement_value_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationModifier::declaration_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:16715
/** Converts an enum of type SgDeclarationModifier::declaration_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationModifier_declaration_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_friend"; break;
        case 3l: retval = "e_typedef"; break;
        case 4l: retval = "e_export"; break;
        case 5l: retval = "e_throw"; break;
        case 6l: retval = "e_bind"; break;
        case 7l: retval = "e_final"; break;
        case 8l: retval = "e_override"; break;
        case 9l: retval = "e_java_abstract"; break;
        case 10l: retval = "e_ms_declspec_align"; break;
        case 11l: retval = "e_ms_declspec_allocate"; break;
        case 12l: retval = "e_ms_declspec_appdomain"; break;
        case 13l: retval = "e_ms_declspec_code_seg"; break;
        case 14l: retval = "e_ms_declspec_deprecated"; break;
        case 15l: retval = "e_ms_declspec_dllimport"; break;
        case 16l: retval = "e_ms_declspec_dllexport"; break;
        case 17l: retval = "e_ms_declspec_jitintrinsic"; break;
        case 18l: retval = "e_ms_declspec_naked"; break;
        case 19l: retval = "e_ms_declspec_noalias"; break;
        case 20l: retval = "e_ms_declspec_noinline"; break;
        case 21l: retval = "e_ms_declspec_noreturn"; break;
        case 22l: retval = "e_ms_declspec_nothrow"; break;
        case 23l: retval = "e_ms_declspec_novtable"; break;
        case 24l: retval = "e_ms_declspec_process"; break;
        case 25l: retval = "e_ms_declspec_property"; break;
        case 26l: retval = "e_ms_declspec_restrict"; break;
        case 27l: retval = "e_ms_declspec_safebuffers"; break;
        case 28l: retval = "e_ms_declspec_selectany"; break;
        case 29l: retval = "e_ms_declspec_thread"; break;
        case 30l: retval = "e_ms_declspec_uuid"; break;
        case 31l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgDeclarationModifier::declaration_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationModifier::gnu_declaration_visability_enum is defined at frontend/SageIII/Cxx_Grammar.h:16762
/** Converts an enum of type SgDeclarationModifier::gnu_declaration_visability_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationModifier_gnu_declaration_visability_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_visibility"; break;
        case 1l: retval = "e_error_visibility"; break;
        case 2l: retval = "e_unspecified_visibility"; break;
        case 3l: retval = "e_hidden_visibility"; break;
        case 4l: retval = "e_protected_visibility"; break;
        case 5l: retval = "e_internal_visibility"; break;
        case 6l: retval = "e_default_visibility"; break;
        case 7l: retval = "e_last_visibility_attribute"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgDeclarationModifier::gnu_declaration_visability_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationStatement::gnu_extension_visability_attribute_enum is defined at frontend/SageIII/Cxx_Grammar.h:128837
/** Converts an enum of type SgDeclarationStatement::gnu_extension_visability_attribute_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_gnu_attribute_visability_unknown"; break;
        case 1l: retval = "e_gnu_attribute_visability_unspecified"; break;
        case 2l: retval = "e_gnu_attribute_visability_hidden"; break;
        case 3l: retval = "e_gnu_attribute_visability_protected"; break;
        case 4l: retval = "e_gnu_attribute_visability_internal"; break;
        case 5l: retval = "e_last_gnu_visability_attribute"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationStatement::template_specialization_enum is defined at frontend/SageIII/Cxx_Grammar.h:128822
/** Converts an enum of type SgDeclarationStatement::template_specialization_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationStatement_template_specialization_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_no_specialization"; break;
        case 2l: retval = "e_partial_specialization"; break;
        case 3l: retval = "e_specialization"; break;
        case 4l: retval = "e_template_specialization_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgDeclarationStatement::template_specialization_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgElaboratedTypeModifier::elaborated_type_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:14262
/** Converts an enum of type SgElaboratedTypeModifier::elaborated_type_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_class"; break;
        case 3l: retval = "e_struct"; break;
        case 4l: retval = "e_union"; break;
        case 5l: retval = "e_enum"; break;
        case 6l: retval = "e_typename"; break;
        case 7l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgFile::outputFormatOption_enum is defined at frontend/SageIII/Cxx_Grammar.h:22869
/** Converts an enum of type SgFile::outputFormatOption_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFile_outputFormatOption_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_output_format"; break;
        case 1l: retval = "e_fixed_form_output_format"; break;
        case 2l: retval = "e_free_form_output_format"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgFile::outputFormatOption_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFile::outputFormatOption_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgFile::outputLanguageOption_enum is defined at frontend/SageIII/Cxx_Grammar.h:22883
/** Converts an enum of type SgFile::outputLanguageOption_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFile_outputLanguageOption_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_error_output_language"; break;
        case 1l: retval = "e_default_output_language"; break;
        case 2l: retval = "e_C_output_language"; break;
        case 3l: retval = "e_Cxx_output_language"; break;
        case 4l: retval = "e_Fortran_output_language"; break;
        case 5l: retval = "e_Java_output_language"; break;
        case 6l: retval = "e_X10_output_language"; break;
        case 7l: retval = "e_Promela_output_language"; break;
        case 8l: retval = "e_PHP_output_language"; break;
        case 9l: retval = "e_Python_output_language"; break;
        case 10l: retval = "e_last_output_language"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgFile::outputLanguageOption_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFile::outputLanguageOption_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgFunctionModifier::function_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:12419
/** Converts an enum of type SgFunctionModifier::function_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFunctionModifier_function_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_inline"; break;
        case 3l: retval = "e_virtual"; break;
        case 4l: retval = "e_pure_virtual"; break;
        case 5l: retval = "e_explicit"; break;
        case 7l: retval = "e_pure"; break;
        case 8l: retval = "e_elemental"; break;
        case 9l: retval = "e_recursive"; break;
        case 10l: retval = "e_gnu_attribute__constructor__"; break;
        case 11l: retval = "e_gnu_attribute__destructor__"; break;
        case 12l: retval = "e_gnu_attribute__pure__"; break;
        case 13l: retval = "e_gnu_attribute__weak__"; break;
        case 14l: retval = "e_gnu_attribute__unused__"; break;
        case 15l: retval = "e_gnu_attribute__used__"; break;
        case 16l: retval = "e_gnu_attribute__deprecated__"; break;
        case 17l: retval = "e_gnu_attribute__malloc__"; break;
        case 18l: retval = "e_gnu_attribute__naked__"; break;
        case 19l: retval = "e_gnu_attribute__no_instrument_function__"; break;
        case 20l: retval = "e_gnu_attribute__no_check_memory_usage__"; break;
        case 21l: retval = "e_gnu_attribute__noinline__"; break;
        case 22l: retval = "e_gnu_attribute__always_inline__"; break;
        case 23l: retval = "e_gnu_attribute__nothrow__"; break;
        case 24l: retval = "e_gnu_attribute__weakref__"; break;
        case 25l: retval = "e_cuda_device"; break;
        case 26l: retval = "e_cuda_kernel"; break;
        case 27l: retval = "e_cuda_host"; break;
        case 28l: retval = "e_opencl_kernel"; break;
        case 29l: retval = "e_opencl_vec_type_hint"; break;
        case 30l: retval = "e_opencl_work_group_size_hint"; break;
        case 31l: retval = "e_opencl_work_group_size_req"; break;
        case 32l: retval = "e_java_native"; break;
        case 33l: retval = "e_java_synchronized"; break;
        case 34l: retval = "e_java_strictfp"; break;
        case 35l: retval = "e_java_initializer"; break;
        case 36l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgFunctionModifier::function_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFunctionModifier::function_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgGraph::GraphEdgeType is defined at frontend/SageIII/Cxx_Grammar.h:35572
/** Converts an enum of type SgGraph::GraphEdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgGraphGraphEdgeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_type_error"; break;
        case 1l: retval = "none"; break;
        case 2l: retval = "cfg"; break;
        case 3l: retval = "usage"; break;
        case 4l: retval = "e_last_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgGraph::GraphEdgeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgGraph::GraphEdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgGraph::GraphProperties is defined at frontend/SageIII/Cxx_Grammar.h:35586
/** Converts an enum of type SgGraph::GraphProperties to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgGraphGraphProperties(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_property_error"; break;
        case 1l: retval = "name"; break;
        case 2l: retval = "type"; break;
        case 3l: retval = "nodest_jmp"; break;
        case 4l: retval = "itself_call"; break;
        case 5l: retval = "nodest_call"; break;
        case 6l: retval = "interrupt"; break;
        case 7l: retval = "eval"; break;
        case 8l: retval = "regs"; break;
        case 9l: retval = "done"; break;
        case 10l: retval = "dfa_standard"; break;
        case 11l: retval = "dfa_resolved_func"; break;
        case 12l: retval = "dfa_unresolved_func"; break;
        case 13l: retval = "dfa_variable"; break;
        case 14l: retval = "dfa_conditional_def"; break;
        case 15l: retval = "edgeLabel"; break;
        case 16l: retval = "visitedCounter"; break;
        case 17l: retval = "variable"; break;
        case 18l: retval = "dfa_bufferoverflow"; break;
        case 19l: retval = "e_last_property"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgGraph::GraphProperties)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgGraph::GraphProperties::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgIOStatement::io_statement_enum is defined at frontend/SageIII/Cxx_Grammar.h:174354
/** Converts an enum of type SgIOStatement::io_statement_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgIOStatement_io_statement_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_read"; break;
        case 2l: retval = "e_print"; break;
        case 3l: retval = "e_write"; break;
        case 4l: retval = "e_open"; break;
        case 5l: retval = "e_close"; break;
        case 6l: retval = "e_inquire"; break;
        case 7l: retval = "e_backspace"; break;
        case 8l: retval = "e_endfile"; break;
        case 9l: retval = "e_rewind"; break;
        case 10l: retval = "e_last_io_statment_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgIOStatement::io_statement_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgIOStatement::io_statement_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::asm_register_name_enum is defined at frontend/SageIII/Cxx_Grammar.h:80513
/** Converts an enum of type SgInitializedName::asm_register_name_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_asm_register_name_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_invalid_register"; break;
        case 1l: retval = "e_memory_register"; break;
        case 2l: retval = "e_register_a"; break;
        case 3l: retval = "e_register_b"; break;
        case 4l: retval = "e_register_c"; break;
        case 5l: retval = "e_register_d"; break;
        case 6l: retval = "e_register_si"; break;
        case 7l: retval = "e_register_di"; break;
        case 8l: retval = "e_register_bp"; break;
        case 9l: retval = "e_register_sp"; break;
        case 10l: retval = "e_register_r8"; break;
        case 11l: retval = "e_register_r9"; break;
        case 12l: retval = "e_register_r10"; break;
        case 13l: retval = "e_register_r11"; break;
        case 14l: retval = "e_register_r12"; break;
        case 15l: retval = "e_register_r13"; break;
        case 16l: retval = "e_register_r14"; break;
        case 17l: retval = "e_register_r15"; break;
        case 18l: retval = "e_register_st0"; break;
        case 19l: retval = "e_register_st1"; break;
        case 20l: retval = "e_register_st2"; break;
        case 21l: retval = "e_register_st3"; break;
        case 22l: retval = "e_register_st4"; break;
        case 23l: retval = "e_register_st5"; break;
        case 24l: retval = "e_register_st6"; break;
        case 25l: retval = "e_register_st7"; break;
        case 26l: retval = "e_register_mm0"; break;
        case 27l: retval = "e_register_mm1"; break;
        case 28l: retval = "e_register_mm2"; break;
        case 29l: retval = "e_register_mm3"; break;
        case 30l: retval = "e_register_mm4"; break;
        case 31l: retval = "e_register_mm5"; break;
        case 32l: retval = "e_register_mm6"; break;
        case 33l: retval = "e_register_mm7"; break;
        case 34l: retval = "e_register_f0"; break;
        case 35l: retval = "e_register_f1"; break;
        case 36l: retval = "e_register_f2"; break;
        case 37l: retval = "e_register_f3"; break;
        case 38l: retval = "e_register_f4"; break;
        case 39l: retval = "e_register_f5"; break;
        case 40l: retval = "e_register_f6"; break;
        case 41l: retval = "e_register_f7"; break;
        case 42l: retval = "e_register_f8"; break;
        case 43l: retval = "e_register_f9"; break;
        case 44l: retval = "e_register_f10"; break;
        case 45l: retval = "e_register_f11"; break;
        case 46l: retval = "e_register_f12"; break;
        case 47l: retval = "e_register_f13"; break;
        case 48l: retval = "e_register_f14"; break;
        case 49l: retval = "e_register_f15"; break;
        case 50l: retval = "e_register_flags"; break;
        case 51l: retval = "e_register_fpsr"; break;
        case 52l: retval = "e_register_dirflag"; break;
        case 53l: retval = "e_unrecognized_register"; break;
        case 54l: retval = "e_last_register"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgInitializedName::asm_register_name_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::asm_register_name_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::excess_specifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:80609
/** Converts an enum of type SgInitializedName::excess_specifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_excess_specifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_excess_specifier_none"; break;
        case 1l: retval = "e_excess_specifier_positionals"; break;
        case 2l: retval = "e_excess_specifier_keywords"; break;
        case 3l: retval = "e_excess_specifier_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgInitializedName::excess_specifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::excess_specifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::gnu_variable_attribute_enum is defined at frontend/SageIII/Cxx_Grammar.h:80575
/** Converts an enum of type SgInitializedName::gnu_variable_attribute_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_gnu_variable_attribute_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_gnu_attribute__weak__"; break;
        case 1l: retval = "e_gnu_attribute__unused__"; break;
        case 2l: retval = "e_gnu_attribute__used__"; break;
        case 3l: retval = "e_gnu_attribute__deprecated__"; break;
        case 4l: retval = "e_gnu_attribute__nocommon__"; break;
        case 5l: retval = "e_gnu_attribute__transparent_union__"; break;
        case 6l: retval = "e_gnu_attribute__weakref__"; break;
        case 7l: retval = "e_gnu_attribute__packed__"; break;
        case 8l: retval = "e_gnu_attribute__noreturn__"; break;
        case 9l: retval = "e_ms_declspec_parameter_appdomain"; break;
        case 10l: retval = "e_ms_declspec_parameter_deprecated"; break;
        case 11l: retval = "e_ms_declspec_parameter_dllimport"; break;
        case 12l: retval = "e_ms_declspec_parameter_dllexport"; break;
        case 13l: retval = "e_ms_declspec_parameter_novtable"; break;
        case 14l: retval = "e_ms_declspec_parameter_process"; break;
        case 15l: retval = "e_ms_declspec_parameter_property"; break;
        case 16l: retval = "e_ms_declspec_parameter_restrict"; break;
        case 18l: retval = "e_ms_declspec_parameter_selectany"; break;
        case 19l: retval = "e_ms_declspec_parameter_thread"; break;
        case 20l: retval = "e_ms_declspec_parameter_uuid"; break;
        case 21l: retval = "e_last_gnu_variable_attribute"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgInitializedName::gnu_variable_attribute_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::preinitialization_enum is defined at frontend/SageIII/Cxx_Grammar.h:80498
/** Converts an enum of type SgInitializedName::preinitialization_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_preinitialization_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_preinitialization"; break;
        case 1l: retval = "e_virtual_base_class"; break;
        case 2l: retval = "e_nonvirtual_base_class"; break;
        case 3l: retval = "e_data_member"; break;
        case 4l: retval = "e_delegation_constructor"; break;
        case 5l: retval = "e_last_preinitialization"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgInitializedName::preinitialization_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::preinitialization_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInterfaceStatement::generic_spec_enum is defined at frontend/SageIII/Cxx_Grammar.h:138815
/** Converts an enum of type SgInterfaceStatement::generic_spec_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInterfaceStatement_generic_spec_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_error_interface_type"; break;
        case 1l: retval = "e_default_interface_type"; break;
        case 2l: retval = "e_unnamed_interface_type"; break;
        case 3l: retval = "e_named_interface_type"; break;
        case 4l: retval = "e_operator_interface_type"; break;
        case 5l: retval = "e_assignment_interface_type"; break;
        case 6l: retval = "e_last_interface_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgInterfaceStatement::generic_spec_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgLabelSymbol::label_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:299817
/** Converts an enum of type SgLabelSymbol::label_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgLabelSymbol_label_type_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_label_type"; break;
        case 1l: retval = "e_non_numeric_label_type"; break;
        case 2l: retval = "e_start_label_type"; break;
        case 3l: retval = "e_else_label_type"; break;
        case 4l: retval = "e_end_label_type"; break;
        case 5l: retval = "e_alternative_return_type"; break;
        case 6l: retval = "e_last_label_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgLabelSymbol::label_type_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgLabelSymbol::label_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgLinkageModifier::linkage_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:14796
/** Converts an enum of type SgLinkageModifier::linkage_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgLinkageModifier_linkage_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_C_linkage"; break;
        case 3l: retval = "e_Cpp_linkage"; break;
        case 4l: retval = "e_fortran_linkage"; break;
        case 5l: retval = "e_fortran90_linkage"; break;
        case 6l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgLinkageModifier::linkage_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgMemberFunctionType::mfunc_specifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:67690
/** Converts an enum of type SgMemberFunctionType::mfunc_specifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgMemberFunctionType_mfunc_specifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "e_const"; break;
        case 2l: retval = "e_volatile"; break;
        case 4l: retval = "e_restrict"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgMemberFunctionType::mfunc_specifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgNodeHelper::Pattern::OutputTarget::OType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/abstractLayer/SgNodeHelper.h:343
/** Converts an enum of type SgNodeHelper::Pattern::OutputTarget::OType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgNodeHelperPatternOutputTargetOType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "VAR"; break;
        case 1l: retval = "INT"; break;
        case 2l: retval = "UNKNOWNPRINTF"; break;
        case 3l: retval = "UNKNOWNOPERATION"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgNodeHelper::Pattern::OutputTarget::OType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgNodeHelper::Pattern::OutputTarget::OType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_default_option_enum is defined at frontend/SageIII/Cxx_Grammar.h:83563
/** Converts an enum of type SgOmpClause::omp_default_option_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_default_option_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_omp_default_unknown"; break;
        case 1l: retval = "e_omp_default_none"; break;
        case 2l: retval = "e_omp_default_shared"; break;
        case 3l: retval = "e_omp_default_private"; break;
        case 4l: retval = "e_omp_default_firstprivate"; break;
        case 5l: retval = "e_omp_default_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgOmpClause::omp_default_option_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_default_option_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_map_dist_data_enum is defined at frontend/SageIII/Cxx_Grammar.h:83626
/** Converts an enum of type SgOmpClause::omp_map_dist_data_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_map_dist_data_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_omp_map_dist_data_unknown"; break;
        case 1l: retval = "e_omp_map_dist_data_duplicate"; break;
        case 2l: retval = "e_omp_map_dist_data_block"; break;
        case 3l: retval = "e_omp_map_dist_data_cyclic"; break;
        case 4l: retval = "e_omp_map_dist_data_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgOmpClause::omp_map_dist_data_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_map_dist_data_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_map_operator_enum is defined at frontend/SageIII/Cxx_Grammar.h:83615
/** Converts an enum of type SgOmpClause::omp_map_operator_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_map_operator_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_omp_map_unknown"; break;
        case 1l: retval = "e_omp_map_alloc"; break;
        case 2l: retval = "e_omp_map_to"; break;
        case 3l: retval = "e_omp_map_from"; break;
        case 4l: retval = "e_omp_map_tofrom"; break;
        case 5l: retval = "e_omp_map_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgOmpClause::omp_map_operator_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_map_operator_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_reduction_operator_enum is defined at frontend/SageIII/Cxx_Grammar.h:83586
/** Converts an enum of type SgOmpClause::omp_reduction_operator_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_reduction_operator_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_omp_reduction_unknown"; break;
        case 1l: retval = "e_omp_reduction_plus"; break;
        case 2l: retval = "e_omp_reduction_mul"; break;
        case 3l: retval = "e_omp_reduction_minus"; break;
        case 4l: retval = "e_omp_reduction_bitand"; break;
        case 5l: retval = "e_omp_reduction_bitor"; break;
        case 6l: retval = "e_omp_reduction_bitxor"; break;
        case 7l: retval = "e_omp_reduction_logand"; break;
        case 8l: retval = "e_omp_reduction_logor"; break;
        case 9l: retval = "e_omp_reduction_and"; break;
        case 10l: retval = "e_omp_reduction_or"; break;
        case 11l: retval = "e_omp_reduction_eqv"; break;
        case 12l: retval = "e_omp_reduction_neqv"; break;
        case 13l: retval = "e_omp_reduction_max"; break;
        case 14l: retval = "e_omp_reduction_min"; break;
        case 15l: retval = "e_omp_reduction_iand"; break;
        case 16l: retval = "e_omp_reduction_ior"; break;
        case 17l: retval = "e_omp_reduction_ieor"; break;
        case 18l: retval = "e_omp_reduction_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgOmpClause::omp_reduction_operator_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_reduction_operator_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_schedule_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:83575
/** Converts an enum of type SgOmpClause::omp_schedule_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_schedule_kind_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_omp_schedule_unknown"; break;
        case 1l: retval = "e_omp_schedule_static"; break;
        case 2l: retval = "e_omp_schedule_dynamic"; break;
        case 3l: retval = "e_omp_schedule_guided"; break;
        case 4l: retval = "e_omp_schedule_auto"; break;
        case 5l: retval = "e_omp_schedule_runtime"; break;
        case 6l: retval = "e_omp_schedule_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgOmpClause::omp_schedule_kind_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOpenclAccessModeModifier::access_mode_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:17479
/** Converts an enum of type SgOpenclAccessModeModifier::access_mode_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_read_only"; break;
        case 3l: retval = "e_write_only"; break;
        case 4l: retval = "e_read_write"; break;
        case 5l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgOpenclAccessModeModifier::access_mode_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgProcedureHeaderStatement::subprogram_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:153351
/** Converts an enum of type SgProcedureHeaderStatement::subprogram_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgProcedureHeaderStatement_subprogram_kind_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_kind"; break;
        case 1l: retval = "e_function_subprogram_kind"; break;
        case 2l: retval = "e_subroutine_subprogram_kind"; break;
        case 3l: retval = "e_block_data_subprogram_kind"; break;
        case 4l: retval = "e_last_subprogram_kind"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgProcedureHeaderStatement::subprogram_kind_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgProject::template_instantiation_enum is defined at frontend/SageIII/Cxx_Grammar.h:26293
/** Converts an enum of type SgProject::template_instantiation_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgProject_template_instantiation_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_none"; break;
        case 3l: retval = "e_used"; break;
        case 4l: retval = "e_all"; break;
        case 5l: retval = "e_local"; break;
        case 6l: retval = "e_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgProject::template_instantiation_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgProject::template_instantiation_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgSpecialFunctionModifier::special_function_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:13713
/** Converts an enum of type SgSpecialFunctionModifier::special_function_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgSpecialFunctionModifier_special_function_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_constructor"; break;
        case 3l: retval = "e_destructor"; break;
        case 4l: retval = "e_conversion"; break;
        case 5l: retval = "e_operator"; break;
        case 6l: retval = "e_uld_operator"; break;
        case 7l: retval = "e_lambda_entry_point"; break;
        case 8l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgSpecialFunctionModifier::special_function_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgStopOrPauseStatement::stop_or_pause_enum is defined at frontend/SageIII/Cxx_Grammar.h:173846
/** Converts an enum of type SgStopOrPauseStatement::stop_or_pause_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgStopOrPauseStatement_stop_or_pause_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_stop"; break;
        case 2l: retval = "e_pause"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgStopOrPauseStatement::stop_or_pause_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgStopOrPauseStatement::stop_or_pause_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgStorageModifier::storage_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:11287
/** Converts an enum of type SgStorageModifier::storage_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgStorageModifier_storage_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_extern"; break;
        case 3l: retval = "e_static"; break;
        case 4l: retval = "e_auto"; break;
        case 5l: retval = "e_unspecified"; break;
        case 6l: retval = "e_register"; break;
        case 7l: retval = "e_mutable"; break;
        case 8l: retval = "e_typedef"; break;
        case 9l: retval = "e_asm"; break;
        case 10l: retval = "e_local"; break;
        case 11l: retval = "e_common"; break;
        case 12l: retval = "e_associated"; break;
        case 13l: retval = "e_intrinsic"; break;
        case 14l: retval = "e_pointer_based"; break;
        case 15l: retval = "e_cuda_global"; break;
        case 16l: retval = "e_cuda_constant"; break;
        case 17l: retval = "e_cuda_shared"; break;
        case 18l: retval = "e_cuda_dynamic_shared"; break;
        case 19l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgStorageModifier::storage_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgStorageModifier::storage_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateArgument::template_argument_enum is defined at frontend/SageIII/Cxx_Grammar.h:31420
/** Converts an enum of type SgTemplateArgument::template_argument_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateArgument_template_argument_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "argument_undefined"; break;
        case 1l: retval = "type_argument"; break;
        case 2l: retval = "nontype_argument"; break;
        case 3l: retval = "template_template_argument"; break;
        case 4l: retval = "start_of_pack_expansion_argument"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgTemplateArgument::template_argument_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateArgument::template_argument_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateClassDeclaration::class_types is defined at frontend/SageIII/Cxx_Grammar.h:144719
/** Converts an enum of type SgTemplateClassDeclaration::class_types to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateClassDeclaration_class_types(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_class"; break;
        case 1l: retval = "e_struct"; break;
        case 2l: retval = "e_union"; break;
        case 3l: retval = "e_template_parameter"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgTemplateClassDeclaration::class_types)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateClassDeclaration::class_types::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateDeclaration::template_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:135743
/** Converts an enum of type SgTemplateDeclaration::template_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateDeclaration_template_type_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_template_none"; break;
        case 1l: retval = "e_template_class"; break;
        case 2l: retval = "e_template_m_class"; break;
        case 3l: retval = "e_template_function"; break;
        case 4l: retval = "e_template_m_function"; break;
        case 5l: retval = "e_template_m_data"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgTemplateDeclaration::template_type_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateDeclaration::template_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateParameter::template_parameter_enum is defined at frontend/SageIII/Cxx_Grammar.h:30862
/** Converts an enum of type SgTemplateParameter::template_parameter_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateParameter_template_parameter_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "parameter_undefined"; break;
        case 1l: retval = "type_parameter"; break;
        case 2l: retval = "nontype_parameter"; break;
        case 3l: retval = "template_parameter"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgTemplateParameter::template_parameter_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateParameter::template_parameter_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgThrowOp::e_throw_kind is defined at frontend/SageIII/Cxx_Grammar.h:208422
/** Converts an enum of type SgThrowOp::e_throw_kind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgThrowOp_e_throw_kind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "unknown_throw"; break;
        case 1l: retval = "throw_expression"; break;
        case 2l: retval = "rethrow"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgThrowOp::e_throw_kind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgThrowOp::e_throw_kind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_C_CXX_Operators is defined at frontend/SageIII/Cxx_Grammar.h:78960
/** Converts an enum of type SgToken::ROSE_C_CXX_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_C_CXX_Operators(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 50000l: retval = "C_CXX_AND"; break;
        case 50001l: retval = "C_CXX_ANDAND"; break;
        case 50002l: retval = "C_CXX_ASSIGN"; break;
        case 50003l: retval = "C_CXX_ANDASSIGN"; break;
        case 50004l: retval = "C_CXX_OR"; break;
        case 50005l: retval = "C_CXX_ORASSIGN"; break;
        case 50006l: retval = "C_CXX_XOR"; break;
        case 50007l: retval = "C_CXX_XORASSIGN"; break;
        case 50008l: retval = "C_CXX_COMMA"; break;
        case 50009l: retval = "C_CXX_COLON"; break;
        case 50010l: retval = "C_CXX_DIVIDE"; break;
        case 50011l: retval = "C_CXX_DIVIDEASSIGN"; break;
        case 50012l: retval = "C_CXX_DOT"; break;
        case 50013l: retval = "C_CXX_DOTSTAR"; break;
        case 50014l: retval = "C_CXX_ELLIPSIS"; break;
        case 50015l: retval = "C_CXX_EQUAL"; break;
        case 50016l: retval = "C_CXX_GREATER"; break;
        case 50017l: retval = "C_CXX_GREATEREQUAL"; break;
        case 50018l: retval = "C_CXX_LEFTBRACE"; break;
        case 50019l: retval = "C_CXX_LESS"; break;
        case 50020l: retval = "C_CXX_LESSEQUAL"; break;
        case 50021l: retval = "C_CXX_LEFTPAREN"; break;
        case 50022l: retval = "C_CXX_LEFTBRACKET"; break;
        case 50023l: retval = "C_CXX_MINUS"; break;
        case 50024l: retval = "C_CXX_MINUSASSIGN"; break;
        case 50025l: retval = "C_CXX_MINUSMINUS"; break;
        case 50026l: retval = "C_CXX_PERCENT"; break;
        case 50027l: retval = "C_CXX_PERCENTASSIGN"; break;
        case 50028l: retval = "C_CXX_NOT"; break;
        case 50029l: retval = "C_CXX_NOTEQUAL"; break;
        case 50030l: retval = "C_CXX_OROR"; break;
        case 50031l: retval = "C_CXX_PLUS"; break;
        case 50032l: retval = "C_CXX_PLUSASSIGN"; break;
        case 50033l: retval = "C_CXX_PLUSPLUS"; break;
        case 50034l: retval = "C_CXX_ARROW"; break;
        case 50035l: retval = "C_CXX_ARROWSTAR"; break;
        case 50036l: retval = "C_CXX_QUESTION_MARK"; break;
        case 50037l: retval = "C_CXX_RIGHTBRACE"; break;
        case 50038l: retval = "C_CXX_RIGHTPAREN"; break;
        case 50039l: retval = "C_CXX_RIGHTBRACKET"; break;
        case 50040l: retval = "C_CXX_COLON_COLON"; break;
        case 50041l: retval = "C_CXX_SEMICOLON"; break;
        case 50042l: retval = "C_CXX_SHIFTLEFT"; break;
        case 50043l: retval = "C_CXX_SHIFTLEFTASSIGN"; break;
        case 50044l: retval = "C_CXX_SHIFTRIGHT"; break;
        case 50045l: retval = "C_CXX_SHIFTRIGHTASSIGN"; break;
        case 50046l: retval = "C_CXX_STAR"; break;
        case 50047l: retval = "C_CXX_COMPL"; break;
        case 50048l: retval = "C_CXX_STARASSIGN"; break;
        case 50049l: retval = "C_CXX_POUND_POUND"; break;
        case 50050l: retval = "C_CXX_POUND"; break;
        case 50051l: retval = "C_CXX_AND_ALT"; break;
        case 50052l: retval = "C_CXX_ANDASSIGN_ALT"; break;
        case 50053l: retval = "C_CXX_OR_ALT"; break;
        case 50054l: retval = "C_CXX_ORASSIGN_ALT"; break;
        case 50055l: retval = "C_CXX_XOR_ALT"; break;
        case 50056l: retval = "C_CXX_XORASSIGN_ALT"; break;
        case 50057l: retval = "C_CXX_LEFTBRACE_ALT"; break;
        case 50058l: retval = "C_CXX_LEFTBRACKET_ALT"; break;
        case 50059l: retval = "C_CXX_NOT_ALT"; break;
        case 50060l: retval = "C_CXX_NOTEQUAL_ALT"; break;
        case 50061l: retval = "C_CXX_RIGHTBRACE_ALT"; break;
        case 50062l: retval = "C_CXX_RIGHTBRACKET_ALT"; break;
        case 50063l: retval = "C_CXX_COMPL_ALT"; break;
        case 50064l: retval = "C_CXX_POUND_POUND_ALT"; break;
        case 50065l: retval = "C_CXX_POUND_ALT"; break;
        case 50066l: retval = "C_CXX_OR_TRIGRAPH"; break;
        case 50067l: retval = "C_CXX_XOR_TRIGRAPH"; break;
        case 50068l: retval = "C_CXX_LEFTBRACE_TRIGRAPH"; break;
        case 50069l: retval = "C_CXX_LEFTBRACKET_TRIGRAPH"; break;
        case 50070l: retval = "C_CXX_RIGHTBRACE_TRIGRAPH"; break;
        case 50071l: retval = "C_CXX_RIGHTBRACKET_TRIGRAPH"; break;
        case 50072l: retval = "C_CXX_COMPL_TRIGRAPH"; break;
        case 50073l: retval = "C_CXX_POUND_POUND_TRIGRAPH"; break;
        case 50074l: retval = "C_CXX_POUND_TRIGRAPH"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgToken::ROSE_C_CXX_Operators)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_C_CXX_keywords is defined at frontend/SageIII/Cxx_Grammar.h:78864
/** Converts an enum of type SgToken::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_C_CXX_keywords(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500l: retval = "C_CXX_ASM"; break;
        case 501l: retval = "C_CXX_AUTO"; break;
        case 502l: retval = "C_CXX_BOOL"; break;
        case 503l: retval = "C_CXX_BREAK"; break;
        case 504l: retval = "C_CXX_CASE"; break;
        case 505l: retval = "C_CXX_CATCH"; break;
        case 506l: retval = "C_CXX_CHAR"; break;
        case 507l: retval = "C_CXX_CLASS"; break;
        case 508l: retval = "C_CXX_CONST"; break;
        case 509l: retval = "C_CXX_CONSTCAST"; break;
        case 510l: retval = "C_CXX_CONTINUE"; break;
        case 511l: retval = "C_CXX_DEFAULT"; break;
        case 512l: retval = "C_CXX_DEFINED"; break;
        case 513l: retval = "C_CXX_DELETE"; break;
        case 514l: retval = "C_CXX_DO"; break;
        case 515l: retval = "C_CXX_DOUBLE"; break;
        case 516l: retval = "C_CXX_DYNAMICCAST"; break;
        case 517l: retval = "C_CXX_ELSE"; break;
        case 518l: retval = "C_CXX_ENUM"; break;
        case 519l: retval = "C_CXX_EXPLICIT"; break;
        case 520l: retval = "C_CXX_EXPORT"; break;
        case 521l: retval = "C_CXX_EXTERN"; break;
        case 522l: retval = "C_CXX_FALSE"; break;
        case 523l: retval = "C_CXX_FLOAT"; break;
        case 524l: retval = "C_CXX_FOR"; break;
        case 525l: retval = "C_CXX_FRIEND"; break;
        case 526l: retval = "C_CXX_GOTO"; break;
        case 527l: retval = "C_CXX_IF"; break;
        case 528l: retval = "C_CXX_INLINE"; break;
        case 529l: retval = "C_CXX_INT"; break;
        case 530l: retval = "C_CXX_LONG"; break;
        case 531l: retval = "C_CXX_MUTABLE"; break;
        case 532l: retval = "C_CXX_NAMESPACE"; break;
        case 533l: retval = "C_CXX_NEW"; break;
        case 534l: retval = "C_CXX_OPERATOR"; break;
        case 535l: retval = "C_CXX_PRIVATE"; break;
        case 536l: retval = "C_CXX_PROTECTED"; break;
        case 537l: retval = "C_CXX_PUBLIC"; break;
        case 538l: retval = "C_CXX_REGISTER"; break;
        case 539l: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540l: retval = "C_CXX_RETURN"; break;
        case 541l: retval = "C_CXX_SHORT"; break;
        case 542l: retval = "C_CXX_SIGNED"; break;
        case 543l: retval = "C_CXX_SIZEOF"; break;
        case 544l: retval = "C_CXX_STATIC"; break;
        case 545l: retval = "C_CXX_STATICCAST"; break;
        case 546l: retval = "C_CXX_STRUCT"; break;
        case 547l: retval = "C_CXX_SWITCH"; break;
        case 548l: retval = "C_CXX_TEMPLATE"; break;
        case 549l: retval = "C_CXX_THIS"; break;
        case 550l: retval = "C_CXX_THROW"; break;
        case 551l: retval = "C_CXX_TRY"; break;
        case 552l: retval = "C_CXX_TRUE"; break;
        case 553l: retval = "C_CXX_TYPEDEF"; break;
        case 554l: retval = "C_CXX_TYPEID"; break;
        case 555l: retval = "C_CXX_TYPENAME"; break;
        case 556l: retval = "C_CXX_UNION"; break;
        case 557l: retval = "C_CXX_UNSIGNED"; break;
        case 558l: retval = "C_CXX_USING"; break;
        case 559l: retval = "C_CXX_VIRTUAL"; break;
        case 560l: retval = "C_CXX_VOID"; break;
        case 561l: retval = "C_CXX_VOLATILE"; break;
        case 562l: retval = "C_CXX_WCHART"; break;
        case 563l: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgToken::ROSE_C_CXX_keywords)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_Fortran_Additional_Info is defined at frontend/SageIII/Cxx_Grammar.h:79040
/** Converts an enum of type SgToken::ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Additional_Info(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000l: retval = "FORTRAN_COMMENTS"; break;
        case 100001l: retval = "FORTRAN_STRING_LITERALS"; break;
        case 100002l: retval = "FORTRAN_IDENTIFIER"; break;
        case 100003l: retval = "FORTRAN_UNIDENTIFIED_TOKEN"; break;
        case 100004l: retval = "FORTRAN_ERROR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgToken::ROSE_Fortran_Additional_Info)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_Fortran_Keywords is defined at frontend/SageIII/Cxx_Grammar.h:78725
/** Converts an enum of type SgToken::ROSE_Fortran_Keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Keywords(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FORTRAN_ABSTRACT"; break;
        case 1l: retval = "FORTRAN_ACCESS"; break;
        case 2l: retval = "FORTRAN_ACTION"; break;
        case 3l: retval = "FORTRAN_ALLOCATE"; break;
        case 4l: retval = "FORTRAN_ALLOCATABLE"; break;
        case 5l: retval = "FORTRAN_ASSIGN"; break;
        case 6l: retval = "FORTRAN_ASSOCIATE"; break;
        case 7l: retval = "FORTRAN_ASYNCHRONOUS"; break;
        case 8l: retval = "FORTRAN_BACKSPACE"; break;
        case 9l: retval = "FORTRAN_BIND"; break;
        case 10l: retval = "FORTRAN_BLANK"; break;
        case 11l: retval = "FORTRAN_BLOCK_DATA"; break;
        case 12l: retval = "FORTRAN_CALL"; break;
        case 13l: retval = "FORTRAN_CHARACTER"; break;
        case 14l: retval = "FORTRAN_CLASS"; break;
        case 15l: retval = "FORTRAN_CLOSE"; break;
        case 16l: retval = "FORTRAN_CONTINUE"; break;
        case 17l: retval = "FORTRAN_CYCLE"; break;
        case 18l: retval = "FORTRAN_CASE"; break;
        case 19l: retval = "FORTRAN_COMMON"; break;
        case 20l: retval = "FORTRAN_COMPLEX"; break;
        case 21l: retval = "FORTRAN_CONTAINS"; break;
        case 22l: retval = "FORTRAN_DEALLOCATE"; break;
        case 23l: retval = "FORTRAN_DATA"; break;
        case 24l: retval = "FORTRAN_DEFERRED"; break;
        case 25l: retval = "FORTRAN_DELIM"; break;
        case 26l: retval = "FORTRAN_DIMENSION"; break;
        case 27l: retval = "FORTRAN_DO"; break;
        case 28l: retval = "FORTRAN_DT"; break;
        case 29l: retval = "FORTRAN_DOUBLEPRECISION"; break;
        case 30l: retval = "FORTRAN_ENCODING"; break;
        case 31l: retval = "FORTRAN_END_CASE"; break;
        case 32l: retval = "FORTRAN_ENDDO"; break;
        case 33l: retval = "FORTRAN_END_FILE"; break;
        case 34l: retval = "FORTRAN_END_ENUM"; break;
        case 35l: retval = "FORTRAN_END_INTERFACE"; break;
        case 36l: retval = "FORTRAN_END_TYPE"; break;
        case 37l: retval = "FORTRAN_ERR"; break;
        case 38l: retval = "FORTRAN_ERRMSG"; break;
        case 39l: retval = "FORTRAN_EXIT"; break;
        case 40l: retval = "FORTRAN_ELSE"; break;
        case 41l: retval = "FORTRAN_ELSEWHERE"; break;
        case 42l: retval = "FORTRAN_ELSEIF"; break;
        case 43l: retval = "FORTRAN_ENDIF"; break;
        case 44l: retval = "FORTRAN_ENTRY"; break;
        case 45l: retval = "FORTRAN_END"; break;
        case 46l: retval = "FORTRAN_ENUM"; break;
        case 47l: retval = "FORTRAN_ENUMERATOR"; break;
        case 48l: retval = "FORTRAN_EQUIVALENCE"; break;
        case 49l: retval = "FORTRAN_EXTERNAL"; break;
        case 50l: retval = "FORTRAN_EXTENDS"; break;
        case 51l: retval = "FORTRAN_FILE"; break;
        case 52l: retval = "FORTRAN_FINAL"; break;
        case 53l: retval = "FORTRAN_FMT"; break;
        case 54l: retval = "FORTRAN_FORALL"; break;
        case 55l: retval = "FORTRAN_FORM"; break;
        case 56l: retval = "FORTRAN_FORMATTED"; break;
        case 57l: retval = "FORTRAN_FORMAT"; break;
        case 58l: retval = "FORTRAN_FLUSH"; break;
        case 59l: retval = "FORTRAN_FUNCTION"; break;
        case 60l: retval = "FORTRAN_GENERIC"; break;
        case 61l: retval = "FORTRAN_GOTO"; break;
        case 62l: retval = "FORTRAN_ID"; break;
        case 63l: retval = "FORTRAN_IF"; break;
        case 64l: retval = "FORTRAN_INQUIRE"; break;
        case 65l: retval = "FORTRAN_INTEGER"; break;
        case 66l: retval = "FORTRAN_IOMSG"; break;
        case 67l: retval = "FORTRAN_IOSTAT"; break;
        case 68l: retval = "FORTRAN_IMPLICIT"; break;
        case 69l: retval = "FORTRAN_IMPLICIT_NONE"; break;
        case 70l: retval = "FORTRAN_IMPORT"; break;
        case 71l: retval = "FORTRAN_INTERFACE"; break;
        case 72l: retval = "FORTRAN_INTENT"; break;
        case 73l: retval = "FORTRAN_INTRINSIC"; break;
        case 74l: retval = "FORTRAN_LEN"; break;
        case 75l: retval = "FORTRAN_LOGICAL"; break;
        case 76l: retval = "FORTRAN_KIND"; break;
        case 77l: retval = "FORTRAN_MODULE_PROC"; break;
        case 78l: retval = "FORTRAN_MODULE"; break;
        case 79l: retval = "FORTRAN_NON_INTRINSIC"; break;
        case 80l: retval = "FORTRAN_NON_OVERRIDABLE"; break;
        case 81l: retval = "FORTRAN_NULL"; break;
        case 82l: retval = "FORTRAN_NULLIFY"; break;
        case 83l: retval = "FORTRAN_NAMELIST"; break;
        case 84l: retval = "FORTRAN_NML"; break;
        case 85l: retval = "FORTRAN_NONE"; break;
        case 86l: retval = "FORTRAN_NOPASS"; break;
        case 87l: retval = "FORTRAN_ONLY"; break;
        case 88l: retval = "FORTRAN_OPEN"; break;
        case 89l: retval = "FORTRAN_OPTIONAL"; break;
        case 90l: retval = "FORTRAN_PARAMETER"; break;
        case 91l: retval = "FORTRAN_PASS"; break;
        case 92l: retval = "FORTRAN_PAUSE"; break;
        case 93l: retval = "FORTRAN_POINTER"; break;
        case 94l: retval = "FORTRAN_PRINT"; break;
        case 95l: retval = "FORTRAN_PRIVATE"; break;
        case 96l: retval = "FORTRAN_PROCEDURE"; break;
        case 97l: retval = "FORTRAN_PROGRAM"; break;
        case 98l: retval = "FORTRAN_PROTECTED"; break;
        case 99l: retval = "FORTRAN_READ"; break;
        case 100l: retval = "FORTRAN_REAL"; break;
        case 101l: retval = "FORTRAN_RETURN"; break;
        case 102l: retval = "FORTRAN_REWIND"; break;
        case 103l: retval = "FORTRAN_ROUND"; break;
        case 104l: retval = "FORTRAN_SELECTCASE"; break;
        case 105l: retval = "FORTRAN_SELECTTYPE"; break;
        case 106l: retval = "FORTRAN_SEQUENCE"; break;
        case 107l: retval = "FORTRAN_SAVE"; break;
        case 108l: retval = "FORTRAN_SIGN"; break;
        case 109l: retval = "FORTRAN_SIZE"; break;
        case 110l: retval = "FORTRAN_SOURCE"; break;
        case 111l: retval = "FORTRAN_STAT"; break;
        case 112l: retval = "FORTRAN_STOP"; break;
        case 113l: retval = "FORTRAN_SUBROUTINE"; break;
        case 114l: retval = "FORTRAN_TARGET"; break;
        case 115l: retval = "FORTRAN_THEN"; break;
        case 116l: retval = "FORTRAN_DERIVED_DECL"; break;
        case 117l: retval = "FORTRAN_TYPEIS"; break;
        case 118l: retval = "FORTRAN_UNFORMATTED"; break;
        case 119l: retval = "FORTRAN_UNIT"; break;
        case 120l: retval = "FORTRAN_USE"; break;
        case 121l: retval = "FORTRAN_VALUE"; break;
        case 122l: retval = "FORTRAN_VOLATILE"; break;
        case 123l: retval = "FORTRAN_WAIT"; break;
        case 124l: retval = "FORTRAN_WHERE"; break;
        case 125l: retval = "FORTRAN_WRITE"; break;
        case 126l: retval = "FORTRAN_END_PROGRAM"; break;
        case 127l: retval = "FORTRAN_END_FUNCTION"; break;
        case 128l: retval = "FORTRAN_END_SUBROUTINE"; break;
        case 129l: retval = "FORTRAN_END_MODULE"; break;
        case 130l: retval = "FORTRAN_DOUBLE_COMPLEX"; break;
        case 131l: retval = "FORTRAN_TYPE"; break;
        case 132l: retval = "FORTRAN_UNKNOWN"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgToken::ROSE_Fortran_Keywords)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_Fortran_Operators is defined at frontend/SageIII/Cxx_Grammar.h:78933
/** Converts an enum of type SgToken::ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Operators(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10000l: retval = "FORTRAN_INTRINSIC_PLUS"; break;
        case 10001l: retval = "FORTRAN_INTRINSIC_MINUS"; break;
        case 10002l: retval = "FORTRAN_INTRINSIC_POWER"; break;
        case 10003l: retval = "FORTRAN_INTRINSIC_CONCAT"; break;
        case 10004l: retval = "FORTRAN_INTRINSIC_TIMES"; break;
        case 10005l: retval = "FORTRAN_INTRINSIC_DIVIDE"; break;
        case 10006l: retval = "FORTRAN_INTRINSIC_AND"; break;
        case 10007l: retval = "FORTRAN_INTRINSIC_OR"; break;
        case 10008l: retval = "FORTRAN_INTRINSIC_EQV"; break;
        case 10009l: retval = "FORTRAN_INTRINSIC_NEQV"; break;
        case 10010l: retval = "FORTRAN_INTRINSIC_EQ"; break;
        case 10011l: retval = "FORTRAN_INTRINSIC_NE"; break;
        case 10012l: retval = "FORTRAN_INTRINSIC_GE"; break;
        case 10013l: retval = "FORTRAN_INTRINSIC_LE"; break;
        case 10014l: retval = "FORTRAN_INTRINSIC_LT"; break;
        case 10015l: retval = "FORTRAN_INTRINSIC_GT"; break;
        case 10016l: retval = "FORTRAN_INTRINSIC_NOT"; break;
        case 10017l: retval = "FORTRAN_INTRINSIC_OLDEQ"; break;
        case 10018l: retval = "FORTRAN_INTRINSIC_OLDNE"; break;
        case 10019l: retval = "FORTRAN_INTRINSIC_OLDGE"; break;
        case 10020l: retval = "FORTRAN_INTRINSIC_OLDLE"; break;
        case 10021l: retval = "FORTRAN_INTRINSIC_OLDLT"; break;
        case 10022l: retval = "FORTRAN_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgToken::ROSE_Fortran_Operators)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgType::fortran_attribute_specifiers_enum is defined at frontend/SageIII/Cxx_Grammar.h:46732
/** Converts an enum of type SgType::fortran_attribute_specifiers_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgType_fortran_attribute_specifiers_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown_attribute_specifier"; break;
        case 1l: retval = "e_public_access"; break;
        case 2l: retval = "e_private_access"; break;
        case 3l: retval = "e_allocatable"; break;
        case 4l: retval = "e_asynchronous"; break;
        case 5l: retval = "e_bind"; break;
        case 6l: retval = "e_data"; break;
        case 7l: retval = "e_dimension"; break;
        case 8l: retval = "e_intent"; break;
        case 9l: retval = "e_optional"; break;
        case 10l: retval = "e_parameter"; break;
        case 11l: retval = "e_pointer"; break;
        case 12l: retval = "e_protected"; break;
        case 13l: retval = "e_save"; break;
        case 14l: retval = "e_target"; break;
        case 15l: retval = "e_value"; break;
        case 16l: retval = "e_volatile"; break;
        case 17l: retval = "e_last_attribute_specifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgType::fortran_attribute_specifiers_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTypeModifier::gnu_extension_machine_mode_enum is defined at frontend/SageIII/Cxx_Grammar.h:15934
/** Converts an enum of type SgTypeModifier::gnu_extension_machine_mode_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTypeModifier_gnu_extension_machine_mode_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_gnu_extension_machine_mode_unknown"; break;
        case 1l: retval = "e_gnu_extension_machine_mode_unspecified"; break;
        case 2l: retval = "e_gnu_extension_machine_mode_BImode"; break;
        case 3l: retval = "e_gnu_extension_machine_mode_QImode"; break;
        case 4l: retval = "e_gnu_extension_machine_mode_HImode"; break;
        case 5l: retval = "e_gnu_extension_machine_mode_PSImode"; break;
        case 6l: retval = "e_gnu_extension_machine_mode_SImode"; break;
        case 7l: retval = "e_gnu_extension_machine_mode_PDImode"; break;
        case 8l: retval = "e_gnu_extension_machine_mode_DImode"; break;
        case 9l: retval = "e_gnu_extension_machine_mode_TImode"; break;
        case 10l: retval = "e_gnu_extension_machine_mode_OImode"; break;
        case 11l: retval = "e_gnu_extension_machine_mode_QFmode"; break;
        case 12l: retval = "e_gnu_extension_machine_mode_HFmode"; break;
        case 13l: retval = "e_gnu_extension_machine_mode_TQFmode"; break;
        case 14l: retval = "e_gnu_extension_machine_mode_SFmode"; break;
        case 15l: retval = "e_gnu_extension_machine_mode_DFmode"; break;
        case 16l: retval = "e_gnu_extension_machine_mode_XFmode"; break;
        case 17l: retval = "e_gnu_extension_machine_mode_SDmode"; break;
        case 18l: retval = "e_gnu_extension_machine_mode_DDmode"; break;
        case 19l: retval = "e_gnu_extension_machine_mode_TDmode"; break;
        case 20l: retval = "e_gnu_extension_machine_mode_TFmode"; break;
        case 21l: retval = "e_gnu_extension_machine_mode_QQmode"; break;
        case 22l: retval = "e_gnu_extension_machine_mode_HQmode"; break;
        case 23l: retval = "e_gnu_extension_machine_mode_SQmode"; break;
        case 24l: retval = "e_gnu_extension_machine_mode_DQmode"; break;
        case 25l: retval = "e_gnu_extension_machine_mode_TQmode"; break;
        case 26l: retval = "e_gnu_extension_machine_mode_UQQmode"; break;
        case 27l: retval = "e_gnu_extension_machine_mode_UHQmode"; break;
        case 28l: retval = "e_gnu_extension_machine_mode_USQmode"; break;
        case 29l: retval = "e_gnu_extension_machine_mode_UDQmode"; break;
        case 30l: retval = "e_gnu_extension_machine_mode_UTQmode"; break;
        case 31l: retval = "e_gnu_extension_machine_mode_HAmode"; break;
        case 32l: retval = "e_gnu_extension_machine_mode_SAmode"; break;
        case 33l: retval = "e_gnu_extension_machine_mode_DAmode"; break;
        case 34l: retval = "e_gnu_extension_machine_mode_TAmode"; break;
        case 35l: retval = "e_gnu_extension_machine_mode_UHAmode"; break;
        case 36l: retval = "e_gnu_extension_machine_mode_USAmode"; break;
        case 37l: retval = "e_gnu_extension_machine_mode_UDAmode"; break;
        case 38l: retval = "e_gnu_extension_machine_mode_UTAmode"; break;
        case 39l: retval = "e_gnu_extension_machine_mode_CCmode"; break;
        case 40l: retval = "e_gnu_extension_machine_mode_BLKmode"; break;
        case 41l: retval = "e_gnu_extension_machine_mode_VOIDmode"; break;
        case 42l: retval = "e_gnu_extension_machine_mode_QCmode"; break;
        case 43l: retval = "e_gnu_extension_machine_mode_HCmode"; break;
        case 44l: retval = "e_gnu_extension_machine_mode_SCmode"; break;
        case 45l: retval = "e_gnu_extension_machine_mode_DCmode"; break;
        case 46l: retval = "e_gnu_extension_machine_mode_XCmode"; break;
        case 47l: retval = "e_gnu_extension_machine_mode_TCmode"; break;
        case 48l: retval = "e_gnu_extension_machine_mode_CQImode"; break;
        case 49l: retval = "e_gnu_extension_machine_mode_CHImode"; break;
        case 50l: retval = "e_gnu_extension_machine_mode_CSImode"; break;
        case 51l: retval = "e_gnu_extension_machine_mode_CDImode"; break;
        case 52l: retval = "e_gnu_extension_machine_mode_CTImode"; break;
        case 53l: retval = "e_gnu_extension_machine_mode_COImode"; break;
        case 54l: retval = "e_last_machine_mode"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgTypeModifier::gnu_extension_machine_mode_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTypeModifier::type_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:15850
/** Converts an enum of type SgTypeModifier::type_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTypeModifier_type_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_restrict"; break;
        case 3l: retval = "e_allocatable"; break;
        case 4l: retval = "e_asynchronous"; break;
        case 5l: retval = "e_bind"; break;
        case 6l: retval = "e_data"; break;
        case 7l: retval = "e_dimension"; break;
        case 8l: retval = "e_intent_in"; break;
        case 9l: retval = "e_intent_out"; break;
        case 10l: retval = "e_intent_inout"; break;
        case 11l: retval = "e_intrinsic"; break;
        case 12l: retval = "e_optional"; break;
        case 13l: retval = "e_extends"; break;
        case 14l: retval = "e_abstract"; break;
        case 15l: retval = "e_save"; break;
        case 16l: retval = "e_target"; break;
        case 17l: retval = "e_value"; break;
        case 18l: retval = "e_gnu_attribute__unused__"; break;
        case 19l: retval = "e_gnu_attribute__packed__"; break;
        case 20l: retval = "e_gnu_attribute__deprecated__"; break;
        case 21l: retval = "e_gnu_attribute__transparent_union__"; break;
        case 22l: retval = "e_gnu_attribute__noreturn__"; break;
        case 23l: retval = "e_gnu_attribute__const__"; break;
        case 24l: retval = "e_gnu_attribute__cdecl__"; break;
        case 25l: retval = "e_gnu_attribute__stdcall__"; break;
        case 26l: retval = "e_gnu_attribute__warn_unused_result__"; break;
        case 27l: retval = "e_gnu_attribute__nonnull__"; break;
        case 28l: retval = "e_gnu_attribute__sentinel__"; break;
        case 29l: retval = "e_address_space__"; break;
        case 30l: retval = "e_ocl_global__"; break;
        case 31l: retval = "e_ocl_local__"; break;
        case 32l: retval = "e_ocl_constant__"; break;
        case 33l: retval = "e_vector_type__"; break;
        case 34l: retval = "e_gnu_attribute__device__"; break;
        case 35l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgTypeModifier::type_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTypeModifier::type_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUPC_AccessModifier::upc_access_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:13171
/** Converts an enum of type SgUPC_AccessModifier::upc_access_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUPC_AccessModifier_upc_access_modifier_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_default"; break;
        case 2l: retval = "e_upc_strict"; break;
        case 3l: retval = "e_upc_relaxed"; break;
        case 4l: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgUPC_AccessModifier::upc_access_modifier_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUnaryOp::Sgop_mode is defined at frontend/SageIII/Cxx_Grammar.h:202978
/** Converts an enum of type SgUnaryOp::Sgop_mode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnaryOpSgop_mode(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "prefix"; break;
        case 1l: retval = "postfix"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgUnaryOp::Sgop_mode)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnaryOp::Sgop_mode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUnparse_Info::access_attr_enum is defined at frontend/SageIII/Cxx_Grammar.h:28363
/** Converts an enum of type SgUnparse_Info::access_attr_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnparse_Info_access_attr_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "a_unset_access"; break;
        case 2l: retval = "a_private_access"; break;
        case 3l: retval = "a_protected_access"; break;
        case 4l: retval = "a_public_access"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgUnparse_Info::access_attr_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnparse_Info::access_attr_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUnparse_Info::unparse_type_num is defined at frontend/SageIII/Cxx_Grammar.h:28202
/** Converts an enum of type SgUnparse_Info::unparse_type_num to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnparse_Info_unparse_type_num(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "b_enum_defaultValue"; break;
        case 1l: retval = "b_isPointerToSomething"; break;
        case 2l: retval = "b_isReferenceToSomething"; break;
        case 3l: retval = "b_inVarDecl"; break;
        case 4l: retval = "b_inArgList"; break;
        case 5l: retval = "b_SkipSemiColon"; break;
        case 6l: retval = "b_inEnumDecl"; break;
        case 7l: retval = "b_inTemplateList"; break;
        case 8l: retval = "b_SkipBaseType"; break;
        case 9l: retval = "b_inAggregateInitializer"; break;
        case 10l: retval = "b_isWithType"; break;
        case 11l: retval = "b_inConditional"; break;
        case 12l: retval = "b_SkipDefinition"; break;
        case 13l: retval = "b_SkipClassSpecifier"; break;
        case 14l: retval = "b_inEmbeddedDecl"; break;
        case 15l: retval = "b_SkipGlobal"; break;
        case 16l: retval = "b_SkipAtomic"; break;
        case 17l: retval = "b_PrintName"; break;
        case 18l: retval = "b_CheckAccess"; break;
        case 19l: retval = "b_SkipFunctionQualifier"; break;
        case 20l: retval = "b_isArrayType"; break;
        case 21l: retval = "b_inRhsExpr"; break;
        case 22l: retval = "b_SkipParen"; break;
        case 23l: retval = "b_isTypeSecondPart"; break;
        case 24l: retval = "b_isTypeFirstPart"; break;
        case 25l: retval = "b_SkipInitializer"; break;
        case 26l: retval = "b_SkipComments"; break;
        case 27l: retval = "b_SkipCPPDirectives"; break;
        case 28l: retval = "b_SkipEnumDefinition"; break;
        case 29l: retval = "b_SkipFunctionDefinition"; break;
        case 30l: retval = "b_SkipClassDefinition"; break;
        case 31l: retval = "b_AddSemiColonAfterDeclaration"; break;
        case 32l: retval = "b_SkipWhitespaces"; break;
        case 33l: retval = "b_SkipBasicBlock"; break;
        case 34l: retval = "b_outputClassTemplateName"; break;
        case 35l: retval = "b_outputCompilerGeneratedStatements"; break;
        case 36l: retval = "b_SkipConstantFoldedExpressions"; break;
        case 37l: retval = "b_forceQualifiedNames"; break;
        case 38l: retval = "b_SkipQualifiedNames"; break;
        case 39l: retval = "b_skipCheckAccess"; break;
        case 40l: retval = "b_requiresGlobalNameQualification"; break;
        case 41l: retval = "b_useTypeAttributes"; break;
        case 42l: retval = "b_SkipFormatting"; break;
        case 43l: retval = "b_outputFortranModFile"; break;
        case 44l: retval = "b_supressStrippedTypeName"; break;
        case 45l: retval = "b_prefixOperator"; break;
        case 46l: retval = "b_supressArrayBound"; break;
        case 47l: retval = "b_supressImplicitThisOperator"; break;
        case 48l: retval = "b_unparsedPartiallyUsingTokenStream"; break;
        case 49l: retval = "b_skipCompilerGeneratedSubExpressions"; break;
        case 50l: retval = "b_parentStatementListBeingUnparsedUsingPartialTokenSequence"; break;
        case 51l: retval = "b_cxx11_initialization_list"; break;
        case 52l: retval = "UNPARSE_TYPE_LAST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgUnparse_Info::unparse_type_num)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnparse_Info::unparse_type_num::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUntypedType::type_enum is defined at frontend/SageIII/Cxx_Grammar.h:108079
/** Converts an enum of type SgUntypedType::type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUntypedType_type_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_void"; break;
        case 2l: retval = "e_int"; break;
        case 3l: retval = "e_float"; break;
        case 4l: retval = "e_double"; break;
        case 5l: retval = "e_complex"; break;
        case 6l: retval = "e_char"; break;
        case 7l: retval = "e_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgUntypedType::type_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUntypedType::type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgVariableDeclaration::gnu_extension_declaration_attributes_enum is defined at frontend/SageIII/Cxx_Grammar.h:130275
/** Converts an enum of type SgVariableDeclaration::gnu_extension_declaration_attributes_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_gnu_attribute_unknown"; break;
        case 1l: retval = "e_gnu_attribute_unspecified"; break;
        case 2l: retval = "e_gnu_attribute__weak__"; break;
        case 3l: retval = "e_gnu_attribute__unused__"; break;
        case 4l: retval = "e_gnu_attribute__deprecated__"; break;
        case 5l: retval = "e_gnu_attribute__nocommon__"; break;
        case 6l: retval = "e_gnu_attribute__transparent_union__"; break;
        case 7l: retval = "e_last_gnu_declaration_attribute"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sg_File_Info::classifier is defined at frontend/SageIII/Cxx_Grammar.h:22062
/** Converts an enum of type Sg_File_Info::classifier to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySg_File_Info_classifier(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "e_transformation"; break;
        case 2l: retval = "e_compiler_generated"; break;
        case 4l: retval = "e_output_in_code_generation"; break;
        case 8l: retval = "e_shared"; break;
        case 16l: retval = "e_frontend_specific"; break;
        case 32l: retval = "e_source_position_unavailable_in_frontend"; break;
        case 64l: retval = "e_comment_or_directive"; break;
        case 128l: retval = "e_token"; break;
        case 256l: retval = "e_default_argument"; break;
        case 512l: retval = "e_implicit_cast"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sg_File_Info::classifier)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sg_File_Info::classifier::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sg_File_Info::p_fileflags is defined at frontend/SageIII/Cxx_Grammar.h:22312
/** Converts an enum of type Sg_File_Info::p_fileflags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySg_File_Info_p_fileflags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -6l: retval = "BAD_FILE_ID"; break;
        case -5l: retval = "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID"; break;
        case -4l: retval = "COMPILER_GENERATED_FILE_ID"; break;
        case -3l: retval = "TRANSFORMATION_FILE_ID"; break;
        case -2l: retval = "NULL_FILE_ID"; break;
        case -1l: retval = "COPY_FILE_ID"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Sg_File_Info::p_fileflags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sg_File_Info::p_fileflags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Snippet::InsertMechanism is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astSnippet/Snippet.h:319
/** Converts an enum of type Snippet::InsertMechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySnippetInsertMechanism(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "INSERT_BODY"; break;
        case 1l: retval = "INSERT_STMTS"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Snippet::InsertMechanism)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Snippet::InsertMechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Snippet::LocalDeclarationPosition is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astSnippet/Snippet.h:329
/** Converts an enum of type Snippet::LocalDeclarationPosition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySnippetLocalDeclarationPosition(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "LOCDECLS_AT_BEGINNING"; break;
        case 1l: retval = "LOCDECLS_AT_END"; break;
        case 2l: retval = "LOCDECLS_AT_CURSOR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Snippet::LocalDeclarationPosition)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Snippet::LocalDeclarationPosition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SqlDatabase::Driver is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseSupport/SqlDatabase.h:120
/** Converts an enum of type SqlDatabase::Driver to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySqlDatabaseDriver(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "NO_DRIVER"; break;
        case 1l: retval = "SQLITE3"; break;
        case 2l: retval = "POSTGRESQL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(SqlDatabase::Driver)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SqlDatabase::Driver::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// StringUtility::FileNameLocation is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/stringSupport/StringUtility.h:636
/** Converts an enum of type StringUtility::FileNameLocation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyStringUtilityFileNameLocation(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FILENAME_LOCATION_UNKNOWN"; break;
        case 1l: retval = "FILENAME_LOCATION_USER"; break;
        case 2l: retval = "FILENAME_LOCATION_LIBRARY"; break;
        case 3l: retval = "FILENAME_LOCATION_NOT_EXIST"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(StringUtility::FileNameLocation)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "StringUtility::FileNameLocation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// StringUtility::OSType is defined at mounts/GS-CAD/ROSE/sources/devel/src/util/stringSupport/StringUtility.h:523
/** Converts an enum of type StringUtility::OSType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyStringUtilityOSType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "OS_TYPE_UNKNOWN"; break;
        case 1l: retval = "OS_TYPE_LINUX"; break;
        case 2l: retval = "OS_TYPE_OSX"; break;
        case 3l: retval = "OS_TYPE_WINDOWS"; break;
        case 4l: retval = "OS_TPYE_WINDOWSXP"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(StringUtility::OSType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "StringUtility::OSType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// TaintLattice::Vertex is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/genericDataflow/simpleAnalyses/taintAnalysis.h:60
/** Converts an enum of type TaintLattice::Vertex to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTaintLatticeVertex(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "VERTEX_BOTTOM"; break;
        case 1l: retval = "VERTEX_UNTAINTED"; break;
        case 2l: retval = "VERTEX_TAINTED"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(TaintLattice::Vertex)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "TaintLattice::Vertex::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Task::State is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/qtWidgets/TaskSystem/TaskInterface.h:26
/** Converts an enum of type Task::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTaskState(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "BEFORE_START"; break;
        case 1l: retval = "RUNNING"; break;
        case 2l: retval = "FINISHED_SUCCESS"; break;
        case 3l: retval = "FINISHED_ERROR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(Task::State)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Task::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// TransformationSupport::operatorCodeType is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseSupport/transformationSupport.h:38
/** Converts an enum of type TransformationSupport::operatorCodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTransformationSupport_operatorCodeType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "FUNCTION_CALL_OPERATOR_CODE"; break;
        case 1l: retval = "ADD_OPERATOR_CODE"; break;
        case 2l: retval = "SUBT_OPERATOR_CODE"; break;
        case 3l: retval = "MULT_OPERATOR_CODE"; break;
        case 4l: retval = "DIV_OPERATOR_CODE"; break;
        case 5l: retval = "INTEGER_DIV_OPERATOR_CODE"; break;
        case 6l: retval = "MOD_OPERATOR_CODE"; break;
        case 7l: retval = "AND_OPERATOR_CODE"; break;
        case 8l: retval = "OR_OPERATOR_CODE"; break;
        case 9l: retval = "BITXOR_OPERATOR_CODE"; break;
        case 10l: retval = "BITAND_OPERATOR_CODE"; break;
        case 11l: retval = "BITOR_OPERATOR_CODE"; break;
        case 12l: retval = "EQ_OPERATOR_CODE"; break;
        case 13l: retval = "LT_OPERATOR_CODE"; break;
        case 14l: retval = "GT_OPERATOR_CODE"; break;
        case 15l: retval = "NE_OPERATOR_CODE"; break;
        case 16l: retval = "LE_OPERATOR_CODE"; break;
        case 17l: retval = "GE_OPERATOR_CODE"; break;
        case 18l: retval = "ASSIGN_OPERATOR_CODE"; break;
        case 19l: retval = "PLUS_ASSIGN_OPERATOR_CODE"; break;
        case 20l: retval = "MINUS_ASSIGN_OPERATOR_CODE"; break;
        case 21l: retval = "AND_ASSIGN_OPERATOR_CODE"; break;
        case 22l: retval = "IOR_ASSIGN_OPERATOR_CODE"; break;
        case 23l: retval = "MULT_ASSIGN_OPERATOR_CODE"; break;
        case 24l: retval = "DIV_ASSIGN_OPERATOR_CODE"; break;
        case 25l: retval = "MOD_ASSIGN_OPERATOR_CODE"; break;
        case 26l: retval = "XOR_ASSIGN_OPERATOR_CODE"; break;
        case 27l: retval = "PARENTHESIS_OPERATOR_CODE"; break;
        case 28l: retval = "BRACKET_OPERATOR_CODE"; break;
        case 29l: retval = "NOT_OPERATOR_CODE"; break;
        case 30l: retval = "DEREFERENCE_OPERATOR_CODE"; break;
        case 31l: retval = "ADDRESS_OPERATOR_CODE"; break;
        case 32l: retval = "LSHIFT_OPERATOR_CODE"; break;
        case 33l: retval = "RSHIFT_OPERATOR_CODE"; break;
        case 34l: retval = "LSHIFT_ASSIGN_OPERATOR_CODE"; break;
        case 35l: retval = "RSHIFT_ASSIGN_OPERATOR_CODE"; break;
        case 36l: retval = "PREFIX_PLUSPLUS_OPERATOR_CODE"; break;
        case 37l: retval = "POSTFIX_PLUSPLUS_OPERATOR_CODE"; break;
        case 38l: retval = "PREFIX_MINUSMINUS_OPERATOR_CODE"; break;
        case 39l: retval = "POSTFIX_MINUSMINUS_OPERATOR_CODE"; break;
        case 99l: retval = "OPERATOR_CODE_LAST_TAG"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(TransformationSupport::operatorCodeType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "TransformationSupport::operatorCodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// TraversalEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/ROSETTA/src/grammar.h:124
/** Converts an enum of type TraversalEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTraversalEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "DEF_TRAVERSAL"; break;
        case 1l: retval = "NO_TRAVERSAL"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(TraversalEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "TraversalEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// UnparseLanguageIndependentConstructs::token_sequence_position_enum_type is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h:41
/** Converts an enum of type UnparseLanguageIndependentConstructs::token_sequence_position_enum_type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_leading_whitespace_start"; break;
        case 1l: retval = "e_leading_whitespace_end"; break;
        case 2l: retval = "e_token_subsequence_start"; break;
        case 3l: retval = "e_token_subsequence_end"; break;
        case 4l: retval = "e_trailing_whitespace_start"; break;
        case 5l: retval = "e_trailing_whitespace_end"; break;
        case 6l: retval = "e_else_whitespace_start"; break;
        case 7l: retval = "e_else_whitespace_end"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "UnparseLanguageIndependentConstructs::token_sequence_position_enum_type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// UnparseLanguageIndependentConstructs::unparsed_as_enum_type is defined at mounts/GS-CAD/ROSE/sources/devel/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h:66
/** Converts an enum of type UnparseLanguageIndependentConstructs::unparsed_as_enum_type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unparsed_as_error"; break;
        case 1l: retval = "e_unparsed_as_AST"; break;
        case 2l: retval = "e_unparsed_as_partial_token_sequence"; break;
        case 3l: retval = "e_unparsed_as_token_stream"; break;
        case 4l: retval = "e_unparsed_as_last"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "UnparseLanguageIndependentConstructs::unparsed_as_enum_type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// VariantT is defined at frontend/SageIII/Cxx_Grammar.h:829
/** Converts an enum of type VariantT to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVariantT(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "V_SgAccessModifier"; break;
        case 2l: retval = "V_SgActualArgumentExpression"; break;
        case 3l: retval = "V_SgAddOp"; break;
        case 4l: retval = "V_SgAddressOfOp"; break;
        case 5l: retval = "V_SgAggregateInitializer"; break;
        case 6l: retval = "V_SgAliasSymbol"; break;
        case 7l: retval = "V_SgAllocateStatement"; break;
        case 8l: retval = "V_SgAndAssignOp"; break;
        case 9l: retval = "V_SgAndOp"; break;
        case 10l: retval = "V_SgArithmeticIfStatement"; break;
        case 11l: retval = "V_SgArrayType"; break;
        case 12l: retval = "V_SgArrowExp"; break;
        case 13l: retval = "V_SgArrowStarOp"; break;
        case 14l: retval = "V_SgAsmArmInstruction"; break;
        case 15l: retval = "V_SgAsmBasicString"; break;
        case 16l: retval = "V_SgAsmBinaryAdd"; break;
        case 17l: retval = "V_SgAsmBinaryAddPostupdate"; break;
        case 18l: retval = "V_SgAsmBinaryAddPreupdate"; break;
        case 19l: retval = "V_SgAsmBinaryAsr"; break;
        case 20l: retval = "V_SgAsmBinaryDivide"; break;
        case 21l: retval = "V_SgAsmBinaryExpression"; break;
        case 22l: retval = "V_SgAsmBinaryLsl"; break;
        case 23l: retval = "V_SgAsmBinaryLsr"; break;
        case 24l: retval = "V_SgAsmBinaryMod"; break;
        case 25l: retval = "V_SgAsmBinaryMultiply"; break;
        case 26l: retval = "V_SgAsmBinaryRor"; break;
        case 27l: retval = "V_SgAsmBinarySubtract"; break;
        case 28l: retval = "V_SgAsmBinarySubtractPostupdate"; break;
        case 29l: retval = "V_SgAsmBinarySubtractPreupdate"; break;
        case 30l: retval = "V_SgAsmBlock"; break;
        case 31l: retval = "V_SgAsmCoffStrtab"; break;
        case 32l: retval = "V_SgAsmCoffSymbol"; break;
        case 33l: retval = "V_SgAsmCoffSymbolList"; break;
        case 34l: retval = "V_SgAsmCoffSymbolTable"; break;
        case 35l: retval = "V_SgAsmCommonSubExpression"; break;
        case 36l: retval = "V_SgAsmControlFlagsExpression"; break;
        case 37l: retval = "V_SgAsmConstantExpression"; break;
        case 38l: retval = "V_SgAsmDOSExtendedHeader"; break;
        case 39l: retval = "V_SgAsmDOSFileHeader"; break;
        case 40l: retval = "V_SgAsmSynthesizedDataStructureDeclaration"; break;
        case 41l: retval = "V_SgAsmSynthesizedDeclaration"; break;
        case 42l: retval = "V_SgAsmDirectRegisterExpression"; break;
        case 43l: retval = "V_SgAsmDwarfAccessDeclaration"; break;
        case 44l: retval = "V_SgAsmDwarfArrayType"; break;
        case 45l: retval = "V_SgAsmDwarfBaseType"; break;
        case 46l: retval = "V_SgAsmDwarfCatchBlock"; break;
        case 47l: retval = "V_SgAsmDwarfClassTemplate"; break;
        case 48l: retval = "V_SgAsmDwarfClassType"; break;
        case 49l: retval = "V_SgAsmDwarfCommonBlock"; break;
        case 50l: retval = "V_SgAsmDwarfCommonInclusion"; break;
        case 51l: retval = "V_SgAsmDwarfCompilationUnit"; break;
        case 52l: retval = "V_SgAsmDwarfCompilationUnitList"; break;
        case 53l: retval = "V_SgAsmDwarfCondition"; break;
        case 54l: retval = "V_SgAsmDwarfConstType"; break;
        case 55l: retval = "V_SgAsmDwarfConstant"; break;
        case 56l: retval = "V_SgAsmDwarfConstruct"; break;
        case 57l: retval = "V_SgAsmDwarfConstructList"; break;
        case 58l: retval = "V_SgAsmDwarfDwarfProcedure"; break;
        case 59l: retval = "V_SgAsmDwarfEntryPoint"; break;
        case 60l: retval = "V_SgAsmDwarfEnumerationType"; break;
        case 61l: retval = "V_SgAsmDwarfEnumerator"; break;
        case 62l: retval = "V_SgAsmDwarfFileType"; break;
        case 63l: retval = "V_SgAsmDwarfFormalParameter"; break;
        case 64l: retval = "V_SgAsmDwarfFormatLabel"; break;
        case 65l: retval = "V_SgAsmDwarfFriend"; break;
        case 66l: retval = "V_SgAsmDwarfFunctionTemplate"; break;
        case 67l: retval = "V_SgAsmDwarfImportedDeclaration"; break;
        case 68l: retval = "V_SgAsmDwarfImportedModule"; break;
        case 69l: retval = "V_SgAsmDwarfImportedUnit"; break;
        case 70l: retval = "V_SgAsmDwarfInformation"; break;
        case 71l: retval = "V_SgAsmDwarfInheritance"; break;
        case 72l: retval = "V_SgAsmDwarfInlinedSubroutine"; break;
        case 73l: retval = "V_SgAsmDwarfInterfaceType"; break;
        case 74l: retval = "V_SgAsmDwarfLabel"; break;
        case 75l: retval = "V_SgAsmDwarfLexicalBlock"; break;
        case 76l: retval = "V_SgAsmDwarfLine"; break;
        case 77l: retval = "V_SgAsmDwarfLineList"; break;
        case 78l: retval = "V_SgAsmDwarfMacro"; break;
        case 79l: retval = "V_SgAsmDwarfMacroList"; break;
        case 80l: retval = "V_SgAsmDwarfMember"; break;
        case 81l: retval = "V_SgAsmDwarfModule"; break;
        case 82l: retval = "V_SgAsmDwarfMutableType"; break;
        case 83l: retval = "V_SgAsmDwarfNamelist"; break;
        case 84l: retval = "V_SgAsmDwarfNamelistItem"; break;
        case 85l: retval = "V_SgAsmDwarfNamespace"; break;
        case 86l: retval = "V_SgAsmDwarfPackedType"; break;
        case 87l: retval = "V_SgAsmDwarfPartialUnit"; break;
        case 88l: retval = "V_SgAsmDwarfPointerType"; break;
        case 89l: retval = "V_SgAsmDwarfPtrToMemberType"; break;
        case 90l: retval = "V_SgAsmDwarfReferenceType"; break;
        case 91l: retval = "V_SgAsmDwarfRestrictType"; break;
        case 92l: retval = "V_SgAsmDwarfSetType"; break;
        case 93l: retval = "V_SgAsmDwarfSharedType"; break;
        case 94l: retval = "V_SgAsmDwarfStringType"; break;
        case 95l: retval = "V_SgAsmDwarfStructureType"; break;
        case 96l: retval = "V_SgAsmDwarfSubprogram"; break;
        case 97l: retval = "V_SgAsmDwarfSubrangeType"; break;
        case 98l: retval = "V_SgAsmDwarfSubroutineType"; break;
        case 99l: retval = "V_SgAsmDwarfTemplateTypeParameter"; break;
        case 100l: retval = "V_SgAsmDwarfTemplateValueParameter"; break;
        case 101l: retval = "V_SgAsmDwarfThrownType"; break;
        case 102l: retval = "V_SgAsmDwarfTryBlock"; break;
        case 103l: retval = "V_SgAsmDwarfTypedef"; break;
        case 104l: retval = "V_SgAsmDwarfUnionType"; break;
        case 105l: retval = "V_SgAsmDwarfUnknownConstruct"; break;
        case 106l: retval = "V_SgAsmDwarfUnspecifiedParameters"; break;
        case 107l: retval = "V_SgAsmDwarfUnspecifiedType"; break;
        case 108l: retval = "V_SgAsmDwarfUpcRelaxedType"; break;
        case 109l: retval = "V_SgAsmDwarfUpcSharedType"; break;
        case 110l: retval = "V_SgAsmDwarfUpcStrictType"; break;
        case 111l: retval = "V_SgAsmDwarfVariable"; break;
        case 112l: retval = "V_SgAsmDwarfVariant"; break;
        case 113l: retval = "V_SgAsmDwarfVariantPart"; break;
        case 114l: retval = "V_SgAsmDwarfVolatileType"; break;
        case 115l: retval = "V_SgAsmDwarfWithStmt"; break;
        case 116l: retval = "V_SgAsmElfDynamicEntry"; break;
        case 117l: retval = "V_SgAsmElfDynamicEntryList"; break;
        case 118l: retval = "V_SgAsmElfDynamicSection"; break;
        case 119l: retval = "V_SgAsmElfEHFrameEntryCI"; break;
        case 120l: retval = "V_SgAsmElfEHFrameEntryCIList"; break;
        case 121l: retval = "V_SgAsmElfEHFrameEntryFD"; break;
        case 122l: retval = "V_SgAsmElfEHFrameEntryFDList"; break;
        case 123l: retval = "V_SgAsmElfEHFrameSection"; break;
        case 124l: retval = "V_SgAsmElfFileHeader"; break;
        case 125l: retval = "V_SgAsmElfNoteEntry"; break;
        case 126l: retval = "V_SgAsmElfNoteEntryList"; break;
        case 127l: retval = "V_SgAsmElfNoteSection"; break;
        case 128l: retval = "V_SgAsmElfRelocEntry"; break;
        case 129l: retval = "V_SgAsmElfRelocEntryList"; break;
        case 130l: retval = "V_SgAsmElfRelocSection"; break;
        case 131l: retval = "V_SgAsmElfSection"; break;
        case 132l: retval = "V_SgAsmElfSectionTable"; break;
        case 133l: retval = "V_SgAsmElfSectionTableEntry"; break;
        case 134l: retval = "V_SgAsmElfSegmentTable"; break;
        case 135l: retval = "V_SgAsmElfSegmentTableEntry"; break;
        case 136l: retval = "V_SgAsmElfSegmentTableEntryList"; break;
        case 137l: retval = "V_SgAsmElfStringSection"; break;
        case 138l: retval = "V_SgAsmElfStrtab"; break;
        case 139l: retval = "V_SgAsmElfSymbol"; break;
        case 140l: retval = "V_SgAsmElfSymbolList"; break;
        case 141l: retval = "V_SgAsmElfSymbolSection"; break;
        case 142l: retval = "V_SgAsmElfSymverDefinedAux"; break;
        case 143l: retval = "V_SgAsmElfSymverDefinedAuxList"; break;
        case 144l: retval = "V_SgAsmElfSymverDefinedEntry"; break;
        case 145l: retval = "V_SgAsmElfSymverDefinedEntryList"; break;
        case 146l: retval = "V_SgAsmElfSymverDefinedSection"; break;
        case 147l: retval = "V_SgAsmElfSymverEntry"; break;
        case 148l: retval = "V_SgAsmElfSymverEntryList"; break;
        case 149l: retval = "V_SgAsmElfSymverNeededAux"; break;
        case 150l: retval = "V_SgAsmElfSymverNeededAuxList"; break;
        case 151l: retval = "V_SgAsmElfSymverNeededEntry"; break;
        case 152l: retval = "V_SgAsmElfSymverNeededEntryList"; break;
        case 153l: retval = "V_SgAsmElfSymverNeededSection"; break;
        case 154l: retval = "V_SgAsmElfSymverSection"; break;
        case 155l: retval = "V_SgAsmExecutableFileFormat"; break;
        case 156l: retval = "V_SgAsmExprListExp"; break;
        case 157l: retval = "V_SgAsmExpression"; break;
        case 158l: retval = "V_SgAsmSynthesizedFieldDeclaration"; break;
        case 159l: retval = "V_SgAsmFloatType"; break;
        case 160l: retval = "V_SgAsmFloatValueExpression"; break;
        case 161l: retval = "V_SgAsmFunction"; break;
        case 163l: retval = "V_SgAsmGenericDLL"; break;
        case 164l: retval = "V_SgAsmGenericDLLList"; break;
        case 165l: retval = "V_SgAsmGenericFile"; break;
        case 166l: retval = "V_SgAsmGenericFileList"; break;
        case 167l: retval = "V_SgAsmGenericFormat"; break;
        case 168l: retval = "V_SgAsmGenericHeader"; break;
        case 169l: retval = "V_SgAsmGenericHeaderList"; break;
        case 170l: retval = "V_SgAsmGenericSection"; break;
        case 171l: retval = "V_SgAsmGenericSectionList"; break;
        case 172l: retval = "V_SgAsmGenericString"; break;
        case 173l: retval = "V_SgAsmGenericStrtab"; break;
        case 174l: retval = "V_SgAsmGenericSymbol"; break;
        case 175l: retval = "V_SgAsmGenericSymbolList"; break;
        case 176l: retval = "V_SgAsmIndirectRegisterExpression"; break;
        case 177l: retval = "V_SgAsmInstruction"; break;
        case 178l: retval = "V_SgAsmIntegerValueExpression"; break;
        case 179l: retval = "V_SgAsmIntegerType"; break;
        case 180l: retval = "V_SgAsmInterpretation"; break;
        case 181l: retval = "V_SgAsmInterpretationList"; break;
        case 182l: retval = "V_SgAsmLEEntryPoint"; break;
        case 183l: retval = "V_SgAsmLEEntryTable"; break;
        case 184l: retval = "V_SgAsmLEFileHeader"; break;
        case 185l: retval = "V_SgAsmLENameTable"; break;
        case 186l: retval = "V_SgAsmLEPageTable"; break;
        case 187l: retval = "V_SgAsmLEPageTableEntry"; break;
        case 188l: retval = "V_SgAsmLERelocTable"; break;
        case 189l: retval = "V_SgAsmLESection"; break;
        case 190l: retval = "V_SgAsmLESectionTable"; break;
        case 191l: retval = "V_SgAsmLESectionTableEntry"; break;
        case 192l: retval = "V_SgAsmM68kInstruction"; break;
        case 194l: retval = "V_SgAsmMemoryReferenceExpression"; break;
        case 195l: retval = "V_SgAsmMipsInstruction"; break;
        case 196l: retval = "V_SgAsmNEEntryPoint"; break;
        case 197l: retval = "V_SgAsmNEEntryTable"; break;
        case 198l: retval = "V_SgAsmNEFileHeader"; break;
        case 199l: retval = "V_SgAsmNEModuleTable"; break;
        case 200l: retval = "V_SgAsmNENameTable"; break;
        case 202l: retval = "V_SgAsmNERelocEntry"; break;
        case 203l: retval = "V_SgAsmNERelocTable"; break;
        case 204l: retval = "V_SgAsmNESection"; break;
        case 205l: retval = "V_SgAsmNESectionTable"; break;
        case 206l: retval = "V_SgAsmNESectionTableEntry"; break;
        case 207l: retval = "V_SgAsmNEStringTable"; break;
        case 208l: retval = "V_SgAsmNode"; break;
        case 209l: retval = "V_SgAsmOp"; break;
        case 210l: retval = "V_SgAsmOperandList"; break;
        case 211l: retval = "V_SgAsmPEExportDirectory"; break;
        case 212l: retval = "V_SgAsmPEExportEntry"; break;
        case 213l: retval = "V_SgAsmPEExportEntryList"; break;
        case 214l: retval = "V_SgAsmPEExportSection"; break;
        case 215l: retval = "V_SgAsmPEFileHeader"; break;
        case 216l: retval = "V_SgAsmPEImportDirectory"; break;
        case 217l: retval = "V_SgAsmPEImportDirectoryList"; break;
        case 218l: retval = "V_SgAsmPEImportItem"; break;
        case 219l: retval = "V_SgAsmPEImportItemList"; break;
        case 220l: retval = "V_SgAsmPEImportSection"; break;
        case 221l: retval = "V_SgAsmPERVASizePair"; break;
        case 222l: retval = "V_SgAsmPERVASizePairList"; break;
        case 223l: retval = "V_SgAsmPESection"; break;
        case 224l: retval = "V_SgAsmPESectionTable"; break;
        case 225l: retval = "V_SgAsmPESectionTableEntry"; break;
        case 226l: retval = "V_SgAsmPEStringSection"; break;
        case 227l: retval = "V_SgAsmPowerpcInstruction"; break;
        case 230l: retval = "V_SgAsmRegisterNames"; break;
        case 231l: retval = "V_SgAsmRegisterReferenceExpression"; break;
        case 232l: retval = "V_SgAsmRiscOperation"; break;
        case 233l: retval = "V_SgAsmScalarType"; break;
        case 236l: retval = "V_SgAsmStatement"; break;
        case 237l: retval = "V_SgAsmStaticData"; break;
        case 238l: retval = "V_SgAsmStmt"; break;
        case 239l: retval = "V_SgAsmStoredString"; break;
        case 240l: retval = "V_SgAsmStringStorage"; break;
        case 241l: retval = "V_SgAsmType"; break;
        case 242l: retval = "V_SgAsmUnaryArmSpecialRegisterList"; break;
        case 243l: retval = "V_SgAsmUnaryExpression"; break;
        case 244l: retval = "V_SgAsmUnaryMinus"; break;
        case 245l: retval = "V_SgAsmUnaryPlus"; break;
        case 246l: retval = "V_SgAsmUnaryRrx"; break;
        case 247l: retval = "V_SgAsmValueExpression"; break;
        case 248l: retval = "V_SgAsmVectorType"; break;
        case 249l: retval = "V_SgAsmX86Instruction"; break;
        case 250l: retval = "V_SgAsmBinaryAddressSymbol"; break;
        case 251l: retval = "V_SgAsmBinaryDataSymbol"; break;
        case 252l: retval = "V_SgAssertStmt"; break;
        case 253l: retval = "V_SgAssignInitializer"; break;
        case 254l: retval = "V_SgAssignOp"; break;
        case 255l: retval = "V_SgAssignStatement"; break;
        case 256l: retval = "V_SgAssignedGotoStatement"; break;
        case 257l: retval = "V_SgAssociateStatement"; break;
        case 258l: retval = "V_SgAsteriskShapeExp"; break;
        case 259l: retval = "V_SgAterm"; break;
        case 260l: retval = "V_SgAttribute"; break;
        case 261l: retval = "V_SgAttributeSpecificationStatement"; break;
        case 262l: retval = "V_SgBackspaceStatement"; break;
        case 263l: retval = "V_SgBaseClass"; break;
        case 264l: retval = "V_SgExpBaseClass"; break;
        case 265l: retval = "V_SgBaseClassModifier"; break;
        case 266l: retval = "V_SgBasicBlock"; break;
        case 267l: retval = "V_SgBidirectionalGraph"; break;
        case 268l: retval = "V_SgBinaryComposite"; break;
        case 269l: retval = "V_SgBinaryOp"; break;
        case 270l: retval = "V_SgBitAndOp"; break;
        case 271l: retval = "V_SgBitAttribute"; break;
        case 272l: retval = "V_SgBitComplementOp"; break;
        case 273l: retval = "V_SgBitOrOp"; break;
        case 274l: retval = "V_SgBitXorOp"; break;
        case 275l: retval = "V_SgBlockDataStatement"; break;
        case 276l: retval = "V_SgBoolValExp"; break;
        case 277l: retval = "V_SgBreakStmt"; break;
        case 278l: retval = "V_SgC_PreprocessorDirectiveStatement"; break;
        case 279l: retval = "V_SgCaseOptionStmt"; break;
        case 280l: retval = "V_SgCastExp"; break;
        case 281l: retval = "V_SgCatchOptionStmt"; break;
        case 282l: retval = "V_SgCatchStatementSeq"; break;
        case 283l: retval = "V_SgCharVal"; break;
        case 284l: retval = "V_SgClassDecl_attr"; break;
        case 285l: retval = "V_SgClassDeclaration"; break;
        case 286l: retval = "V_SgClassDefinition"; break;
        case 287l: retval = "V_SgClassNameRefExp"; break;
        case 288l: retval = "V_SgClassSymbol"; break;
        case 289l: retval = "V_SgClassType"; break;
        case 290l: retval = "V_SgClinkageDeclarationStatement"; break;
        case 291l: retval = "V_SgClinkageEndStatement"; break;
        case 292l: retval = "V_SgClinkageStartStatement"; break;
        case 293l: retval = "V_SgCloseStatement"; break;
        case 294l: retval = "V_SgColonShapeExp"; break;
        case 295l: retval = "V_SgCommaOpExp"; break;
        case 296l: retval = "V_SgCommonBlock"; break;
        case 297l: retval = "V_SgCommonBlockObject"; break;
        case 298l: retval = "V_SgCommonSymbol"; break;
        case 299l: retval = "V_SgComplexVal"; break;
        case 300l: retval = "V_SgComprehension"; break;
        case 302l: retval = "V_SgCompoundAssignOp"; break;
        case 303l: retval = "V_SgCompoundInitializer"; break;
        case 304l: retval = "V_SgCompoundLiteralExp"; break;
        case 305l: retval = "V_SgComputedGotoStatement"; break;
        case 306l: retval = "V_SgConcatenationOp"; break;
        case 307l: retval = "V_SgConditionalExp"; break;
        case 308l: retval = "V_SgConjugateOp"; break;
        case 309l: retval = "V_SgConstVolatileModifier"; break;
        case 310l: retval = "V_SgConstructorInitializer"; break;
        case 311l: retval = "V_SgContainsStatement"; break;
        case 312l: retval = "V_SgContinueStmt"; break;
        case 313l: retval = "V_SgCtorInitializerList"; break;
        case 314l: retval = "V_SgDataStatementGroup"; break;
        case 315l: retval = "V_SgDataStatementObject"; break;
        case 316l: retval = "V_SgDataStatementValue"; break;
        case 317l: retval = "V_SgDeadIfDirectiveStatement"; break;
        case 318l: retval = "V_SgDeallocateStatement"; break;
        case 319l: retval = "V_SgDeclarationModifier"; break;
        case 320l: retval = "V_SgDeclarationStatement"; break;
        case 321l: retval = "V_SgDeclType"; break;
        case 322l: retval = "V_SgDefaultOptionStmt"; break;
        case 323l: retval = "V_SgDefaultSymbol"; break;
        case 324l: retval = "V_SgDefineDirectiveStatement"; break;
        case 325l: retval = "V_SgDeleteExp"; break;
        case 326l: retval = "V_SgDerivedTypeStatement"; break;
        case 327l: retval = "V_SgDesignatedInitializer"; break;
        case 328l: retval = "V_SgDictionaryComprehension"; break;
        case 329l: retval = "V_SgDictionaryExp"; break;
        case 330l: retval = "V_SgDimensionObject"; break;
        case 332l: retval = "V_SgDirectedGraphEdge"; break;
        case 334l: retval = "V_SgDirectory"; break;
        case 335l: retval = "V_SgDirectoryList"; break;
        case 336l: retval = "V_SgDivAssignOp"; break;
        case 337l: retval = "V_SgDivideOp"; break;
        case 338l: retval = "V_SgDoWhileStmt"; break;
        case 339l: retval = "V_SgDotExp"; break;
        case 340l: retval = "V_SgDotStarOp"; break;
        case 341l: retval = "V_SgDoubleVal"; break;
        case 342l: retval = "V_SgElaboratedTypeModifier"; break;
        case 343l: retval = "V_SgElementwiseOp"; break;
        case 344l: retval = "V_SgElementwiseAddOp"; break;
        case 345l: retval = "V_SgElementwiseDivideOp"; break;
        case 346l: retval = "V_SgElementwiseLeftDivideOp"; break;
        case 347l: retval = "V_SgElementwiseMultiplyOp"; break;
        case 348l: retval = "V_SgElementwisePowerOp"; break;
        case 349l: retval = "V_SgElementwiseSubtractOp"; break;
        case 350l: retval = "V_SgElseDirectiveStatement"; break;
        case 351l: retval = "V_SgElseWhereStatement"; break;
        case 352l: retval = "V_SgElseifDirectiveStatement"; break;
        case 353l: retval = "V_SgEmptyDirectiveStatement"; break;
        case 354l: retval = "V_SgEndfileStatement"; break;
        case 355l: retval = "V_SgEndifDirectiveStatement"; break;
        case 356l: retval = "V_SgEntryStatement"; break;
        case 357l: retval = "V_SgEnumDeclaration"; break;
        case 358l: retval = "V_SgEnumFieldSymbol"; break;
        case 359l: retval = "V_SgEnumSymbol"; break;
        case 360l: retval = "V_SgEnumType"; break;
        case 361l: retval = "V_SgEnumVal"; break;
        case 362l: retval = "V_SgEqualityOp"; break;
        case 363l: retval = "V_SgEquivalenceStatement"; break;
        case 364l: retval = "V_SgErrorDirectiveStatement"; break;
        case 365l: retval = "V_SgExecStatement"; break;
        case 366l: retval = "V_SgExponentiationOp"; break;
        case 367l: retval = "V_SgExponentiationAssignOp"; break;
        case 368l: retval = "V_SgExprListExp"; break;
        case 369l: retval = "V_SgExprStatement"; break;
        case 370l: retval = "V_SgExpression"; break;
        case 371l: retval = "V_SgExpressionRoot"; break;
        case 372l: retval = "V_SgFile"; break;
        case 373l: retval = "V_SgFileList"; break;
        case 374l: retval = "V_SgFloatVal"; break;
        case 375l: retval = "V_SgFlushStatement"; break;
        case 376l: retval = "V_SgForAllStatement"; break;
        case 377l: retval = "V_SgForInitStatement"; break;
        case 378l: retval = "V_SgForStatement"; break;
        case 379l: retval = "V_SgFormatItem"; break;
        case 380l: retval = "V_SgFormatItemList"; break;
        case 381l: retval = "V_SgFormatStatement"; break;
        case 382l: retval = "V_SgFortranDo"; break;
        case 383l: retval = "V_SgFortranIncludeLine"; break;
        case 384l: retval = "V_SgFortranNonblockedDo"; break;
        case 385l: retval = "V_SgFuncDecl_attr"; break;
        case 386l: retval = "V_SgFunctionCallExp"; break;
        case 387l: retval = "V_SgFunctionDeclaration"; break;
        case 388l: retval = "V_SgFunctionDefinition"; break;
        case 389l: retval = "V_SgFunctionParameterScope"; break;
        case 390l: retval = "V_SgFunctionModifier"; break;
        case 391l: retval = "V_SgFunctionParameterList"; break;
        case 392l: retval = "V_SgFunctionParameterRefExp"; break;
        case 393l: retval = "V_SgFunctionParameterTypeList"; break;
        case 394l: retval = "V_SgFunctionRefExp"; break;
        case 395l: retval = "V_SgFunctionSymbol"; break;
        case 396l: retval = "V_SgFunctionType"; break;
        case 397l: retval = "V_SgFunctionTypeSymbol"; break;
        case 398l: retval = "V_SgFunctionTypeTable"; break;
        case 399l: retval = "V_SgTypeTable"; break;
        case 400l: retval = "V_SgGlobal"; break;
        case 401l: retval = "V_SgGotoStatement"; break;
        case 402l: retval = "V_SgGraph"; break;
        case 403l: retval = "V_SgGraphEdge"; break;
        case 404l: retval = "V_SgGraphEdgeList"; break;
        case 405l: retval = "V_SgGraphNode"; break;
        case 406l: retval = "V_SgGraphNodeList"; break;
        case 407l: retval = "V_SgGreaterOrEqualOp"; break;
        case 408l: retval = "V_SgGreaterThanOp"; break;
        case 409l: retval = "V_SgIOItemExpression"; break;
        case 410l: retval = "V_SgIOStatement"; break;
        case 411l: retval = "V_SgIdentDirectiveStatement"; break;
        case 412l: retval = "V_SgIfDirectiveStatement"; break;
        case 413l: retval = "V_SgIfStmt"; break;
        case 414l: retval = "V_SgIfdefDirectiveStatement"; break;
        case 415l: retval = "V_SgIfndefDirectiveStatement"; break;
        case 416l: retval = "V_SgImagPartOp"; break;
        case 417l: retval = "V_SgImplicitStatement"; break;
        case 418l: retval = "V_SgImpliedDo"; break;
        case 419l: retval = "V_SgImportStatement"; break;
        case 420l: retval = "V_SgIncidenceDirectedGraph"; break;
        case 421l: retval = "V_SgIncidenceUndirectedGraph"; break;
        case 422l: retval = "V_SgIncludeDirectiveStatement"; break;
        case 423l: retval = "V_SgIncludeNextDirectiveStatement"; break;
        case 424l: retval = "V_SgInitializedName"; break;
        case 425l: retval = "V_SgInitializer"; break;
        case 426l: retval = "V_SgInquireStatement"; break;
        case 427l: retval = "V_SgIntKeyedBidirectionalGraph"; break;
        case 428l: retval = "V_SgIntVal"; break;
        case 429l: retval = "V_SgIntegerDivideOp"; break;
        case 430l: retval = "V_SgIntegerDivideAssignOp"; break;
        case 431l: retval = "V_SgInterfaceBody"; break;
        case 432l: retval = "V_SgHeaderFileBody"; break;
        case 433l: retval = "V_SgInterfaceStatement"; break;
        case 434l: retval = "V_SgInterfaceSymbol"; break;
        case 435l: retval = "V_SgIntrinsicSymbol"; break;
        case 436l: retval = "V_SgIsOp"; break;
        case 437l: retval = "V_SgIsNotOp"; break;
        case 438l: retval = "V_SgIorAssignOp"; break;
        case 439l: retval = "V_SgKeyDatumPair"; break;
        case 440l: retval = "V_SgCudaKernelExecConfig"; break;
        case 441l: retval = "V_SgCudaKernelCallExp"; break;
        case 442l: retval = "V_SgLabelRefExp"; break;
        case 443l: retval = "V_SgLabelStatement"; break;
        case 444l: retval = "V_SgJavaLabelStatement"; break;
        case 445l: retval = "V_SgLabelSymbol"; break;
        case 446l: retval = "V_SgJavaLabelSymbol"; break;
        case 447l: retval = "V_SgLambdaCapture"; break;
        case 448l: retval = "V_SgLambdaCaptureList"; break;
        case 449l: retval = "V_SgLambdaExp"; break;
        case 450l: retval = "V_SgLambdaRefExp"; break;
        case 451l: retval = "V_SgLeftDivideOp"; break;
        case 452l: retval = "V_SgLessOrEqualOp"; break;
        case 453l: retval = "V_SgLessThanOp"; break;
        case 454l: retval = "V_SgLineDirectiveStatement"; break;
        case 455l: retval = "V_SgLinemarkerDirectiveStatement"; break;
        case 456l: retval = "V_SgLinkageModifier"; break;
        case 457l: retval = "V_SgListComprehension"; break;
        case 458l: retval = "V_SgListExp"; break;
        case 459l: retval = "V_SgLocatedNode"; break;
        case 460l: retval = "V_SgLocatedNodeSupport"; break;
        case 461l: retval = "V_SgLongDoubleVal"; break;
        case 462l: retval = "V_SgLongIntVal"; break;
        case 463l: retval = "V_SgLongLongIntVal"; break;
        case 464l: retval = "V_SgLshiftAssignOp"; break;
        case 465l: retval = "V_SgLshiftOp"; break;
        case 466l: retval = "V_SgMagicColonExp"; break;
        case 467l: retval = "V_SgMatrixExp"; break;
        case 468l: retval = "V_SgMatrixTransposeOp"; break;
        case 469l: retval = "V_SgMatlabForStatement"; break;
        case 470l: retval = "V_SgMemberFunctionDeclaration"; break;
        case 471l: retval = "V_SgMemberFunctionRefExp"; break;
        case 472l: retval = "V_SgMemberFunctionSymbol"; break;
        case 473l: retval = "V_SgMemberFunctionType"; break;
        case 474l: retval = "V_SgMembershipOp"; break;
        case 475l: retval = "V_SgMicrosoftAttributeDeclaration"; break;
        case 476l: retval = "V_SgMinusAssignOp"; break;
        case 477l: retval = "V_SgMinusMinusOp"; break;
        case 478l: retval = "V_SgMinusOp"; break;
        case 479l: retval = "V_SgModAssignOp"; break;
        case 480l: retval = "V_SgModOp"; break;
        case 481l: retval = "V_SgModifier"; break;
        case 482l: retval = "V_SgModifierNodes"; break;
        case 483l: retval = "V_SgModifierType"; break;
        case 484l: retval = "V_SgModuleStatement"; break;
        case 485l: retval = "V_SgModuleSymbol"; break;
        case 486l: retval = "V_SgMultAssignOp"; break;
        case 487l: retval = "V_SgMultiplyOp"; break;
        case 488l: retval = "V_SgName"; break;
        case 489l: retval = "V_SgNameGroup"; break;
        case 490l: retval = "V_SgNamedType"; break;
        case 491l: retval = "V_SgNamelistStatement"; break;
        case 492l: retval = "V_SgNamespaceAliasDeclarationStatement"; break;
        case 493l: retval = "V_SgNamespaceDeclarationStatement"; break;
        case 494l: retval = "V_SgNamespaceDefinitionStatement"; break;
        case 495l: retval = "V_SgNamespaceSymbol"; break;
        case 496l: retval = "V_SgNaryOp"; break;
        case 497l: retval = "V_SgNaryBooleanOp"; break;
        case 498l: retval = "V_SgNaryComparisonOp"; break;
        case 499l: retval = "V_SgNewExp"; break;
        case 500l: retval = "V_SgNode"; break;
        case 501l: retval = "V_SgNoexceptOp"; break;
        case 502l: retval = "V_SgNotEqualOp"; break;
        case 503l: retval = "V_SgNotOp"; break;
        case 504l: retval = "V_SgNonMembershipOp"; break;
        case 505l: retval = "V_SgNullExpression"; break;
        case 506l: retval = "V_SgNullptrValExp"; break;
        case 507l: retval = "V_SgNullStatement"; break;
        case 508l: retval = "V_SgNullifyStatement"; break;
        case 509l: retval = "V_SgOmpAtomicStatement"; break;
        case 510l: retval = "V_SgOmpBarrierStatement"; break;
        case 511l: retval = "V_SgOmpCriticalStatement"; break;
        case 512l: retval = "V_SgOmpClauseBodyStatement"; break;
        case 513l: retval = "V_SgOmpBodyStatement"; break;
        case 514l: retval = "V_SgOmpDoStatement"; break;
        case 515l: retval = "V_SgOmpFlushStatement"; break;
        case 516l: retval = "V_SgOmpForStatement"; break;
        case 517l: retval = "V_SgOmpMasterStatement"; break;
        case 518l: retval = "V_SgOmpOrderedStatement"; break;
        case 519l: retval = "V_SgOmpParallelStatement"; break;
        case 520l: retval = "V_SgOmpSectionStatement"; break;
        case 521l: retval = "V_SgOmpSectionsStatement"; break;
        case 522l: retval = "V_SgOmpSingleStatement"; break;
        case 523l: retval = "V_SgOmpTaskStatement"; break;
        case 524l: retval = "V_SgOmpTaskwaitStatement"; break;
        case 525l: retval = "V_SgOmpThreadprivateStatement"; break;
        case 526l: retval = "V_SgOmpWorkshareStatement"; break;
        case 527l: retval = "V_SgOmpTargetStatement"; break;
        case 528l: retval = "V_SgOmpTargetDataStatement"; break;
        case 529l: retval = "V_SgOmpSimdStatement"; break;
        case 530l: retval = "V_SgOmpClause"; break;
        case 531l: retval = "V_SgOmpBeginClause"; break;
        case 532l: retval = "V_SgOmpCollapseClause"; break;
        case 533l: retval = "V_SgOmpCopyinClause"; break;
        case 534l: retval = "V_SgOmpCopyprivateClause"; break;
        case 535l: retval = "V_SgOmpDefaultClause"; break;
        case 536l: retval = "V_SgOmpEndClause"; break;
        case 537l: retval = "V_SgOmpExpressionClause"; break;
        case 538l: retval = "V_SgOmpFirstprivateClause"; break;
        case 539l: retval = "V_SgOmpIfClause"; break;
        case 540l: retval = "V_SgOmpDeviceClause"; break;
        case 541l: retval = "V_SgOmpLastprivateClause"; break;
        case 542l: retval = "V_SgOmpNowaitClause"; break;
        case 543l: retval = "V_SgOmpNumThreadsClause"; break;
        case 544l: retval = "V_SgOmpOrderedClause"; break;
        case 545l: retval = "V_SgOmpPrivateClause"; break;
        case 546l: retval = "V_SgOmpReductionClause"; break;
        case 547l: retval = "V_SgOmpScheduleClause"; break;
        case 548l: retval = "V_SgOmpSharedClause"; break;
        case 549l: retval = "V_SgOmpUntiedClause"; break;
        case 550l: retval = "V_SgOmpVariablesClause"; break;
        case 551l: retval = "V_SgOmpMapClause"; break;
        case 552l: retval = "V_SgOmpSafelenClause"; break;
        case 553l: retval = "V_SgOmpLinearClause"; break;
        case 554l: retval = "V_SgOmpUniformClause"; break;
        case 555l: retval = "V_SgOmpAlignedClause"; break;
        case 556l: retval = "V_SgOpenclAccessModeModifier"; break;
        case 557l: retval = "V_SgOpenStatement"; break;
        case 558l: retval = "V_SgOptions"; break;
        case 559l: retval = "V_SgOrOp"; break;
        case 560l: retval = "V_SgParameterStatement"; break;
        case 561l: retval = "V_SgPartialFunctionModifierType"; break;
        case 562l: retval = "V_SgPartialFunctionType"; break;
        case 563l: retval = "V_SgPassStatement"; break;
        case 564l: retval = "V_SgPlusAssignOp"; break;
        case 565l: retval = "V_SgPlusPlusOp"; break;
        case 566l: retval = "V_SgPntrArrRefExp"; break;
        case 567l: retval = "V_SgPointerAssignOp"; break;
        case 568l: retval = "V_SgPointerDerefExp"; break;
        case 569l: retval = "V_SgPointerMemberType"; break;
        case 570l: retval = "V_SgPointerType"; break;
        case 571l: retval = "V_SgPowerOp"; break;
        case 572l: retval = "V_SgPragma"; break;
        case 573l: retval = "V_SgPragmaDeclaration"; break;
        case 574l: retval = "V_SgPrintStatement"; break;
        case 575l: retval = "V_SgProcedureHeaderStatement"; break;
        case 576l: retval = "V_SgProgramHeaderStatement"; break;
        case 577l: retval = "V_SgProject"; break;
        case 578l: retval = "V_SgPseudoDestructorRefExp"; break;
        case 579l: retval = "V_SgPythonGlobalStmt"; break;
        case 580l: retval = "V_SgPythonPrintStmt"; break;
        case 581l: retval = "V_SgQualifiedName"; break;
        case 582l: retval = "V_SgQualifiedNameType"; break;
        case 583l: retval = "V_SgRangeExp"; break;
        case 584l: retval = "V_SgReadStatement"; break;
        case 585l: retval = "V_SgRealPartOp"; break;
        case 586l: retval = "V_SgRefExp"; break;
        case 587l: retval = "V_SgReferenceType"; break;
        case 588l: retval = "V_SgRenamePair"; break;
        case 589l: retval = "V_SgRenameSymbol"; break;
        case 590l: retval = "V_SgReturnStmt"; break;
        case 591l: retval = "V_SgRewindStatement"; break;
        case 592l: retval = "V_SgRshiftAssignOp"; break;
        case 593l: retval = "V_SgRshiftOp"; break;
        case 594l: retval = "V_SgRvalueReferenceType"; break;
        case 595l: retval = "V_SgJavaUnsignedRshiftAssignOp"; break;
        case 596l: retval = "V_SgJavaUnsignedRshiftOp"; break;
        case 597l: retval = "V_SgScopeOp"; break;
        case 598l: retval = "V_SgScopeStatement"; break;
        case 599l: retval = "V_SgSequenceStatement"; break;
        case 600l: retval = "V_SgSetComprehension"; break;
        case 601l: retval = "V_SgShortVal"; break;
        case 602l: retval = "V_SgSizeOfOp"; break;
        case 603l: retval = "V_SgAlignOfOp"; break;
        case 604l: retval = "V_SgJavaInstanceOfOp"; break;
        case 605l: retval = "V_SgSourceFile"; break;
        case 606l: retval = "V_SgSpawnStmt"; break;
        case 607l: retval = "V_SgJavaThrowStatement"; break;
        case 608l: retval = "V_SgJavaForEachStatement"; break;
        case 609l: retval = "V_SgJavaSynchronizedStatement"; break;
        case 610l: retval = "V_SgJavaParameterizedType"; break;
        case 611l: retval = "V_SgJavaWildcardType"; break;
        case 612l: retval = "V_SgSpecialFunctionModifier"; break;
        case 613l: retval = "V_SgStatement"; break;
        case 614l: retval = "V_SgStaticAssertionDeclaration"; break;
        case 615l: retval = "V_SgStmtDeclarationStatement"; break;
        case 616l: retval = "V_SgStatementExpression"; break;
        case 617l: retval = "V_SgStatementFunctionStatement"; break;
        case 618l: retval = "V_SgStopOrPauseStatement"; break;
        case 619l: retval = "V_SgStorageModifier"; break;
        case 620l: retval = "V_SgStringConversion"; break;
        case 621l: retval = "V_SgStringKeyedBidirectionalGraph"; break;
        case 622l: retval = "V_SgStringVal"; break;
        case 623l: retval = "V_SgSubscriptExpression"; break;
        case 624l: retval = "V_SgSubtractOp"; break;
        case 625l: retval = "V_SgSupport"; break;
        case 626l: retval = "V_SgSwitchStatement"; break;
        case 627l: retval = "V_SgSymbol"; break;
        case 628l: retval = "V_SgSymbolTable"; break;
        case 629l: retval = "V_SgTemplateArgument"; break;
        case 630l: retval = "V_SgTemplateArgumentList"; break;
        case 631l: retval = "V_SgTemplateDeclaration"; break;
        case 632l: retval = "V_SgTemplateClassDeclaration"; break;
        case 633l: retval = "V_SgTemplateClassSymbol"; break;
        case 634l: retval = "V_SgTemplateFunctionDeclaration"; break;
        case 635l: retval = "V_SgTemplateFunctionRefExp"; break;
        case 636l: retval = "V_SgTemplateFunctionSymbol"; break;
        case 637l: retval = "V_SgTemplateMemberFunctionDeclaration"; break;
        case 638l: retval = "V_SgTemplateMemberFunctionRefExp"; break;
        case 639l: retval = "V_SgTemplateMemberFunctionSymbol"; break;
        case 640l: retval = "V_SgTemplateTypedefDeclaration"; break;
        case 641l: retval = "V_SgTemplateTypedefSymbol"; break;
        case 642l: retval = "V_SgTemplateVariableDeclaration"; break;
        case 643l: retval = "V_SgTemplateVariableSymbol"; break;
        case 644l: retval = "V_SgTemplateClassDefinition"; break;
        case 645l: retval = "V_SgTemplateFunctionDefinition"; break;
        case 646l: retval = "V_SgTemplateInstantiationDecl"; break;
        case 647l: retval = "V_SgTemplateInstantiationDefn"; break;
        case 648l: retval = "V_SgTemplateInstantiationDirectiveStatement"; break;
        case 649l: retval = "V_SgTemplateInstantiationFunctionDecl"; break;
        case 650l: retval = "V_SgTemplateInstantiationMemberFunctionDecl"; break;
        case 651l: retval = "V_SgTemplateInstantiationTypedefDeclaration"; break;
        case 652l: retval = "V_SgTemplateParameter"; break;
        case 653l: retval = "V_SgTemplateParameterVal"; break;
        case 654l: retval = "V_SgTemplateParameterList"; break;
        case 655l: retval = "V_SgTemplateSymbol"; break;
        case 656l: retval = "V_SgTemplateType"; break;
        case 657l: retval = "V_SgThisExp"; break;
        case 658l: retval = "V_SgTypeTraitBuiltinOperator"; break;
        case 659l: retval = "V_SgSuperExp"; break;
        case 660l: retval = "V_SgThrowOp"; break;
        case 661l: retval = "V_SgToken"; break;
        case 662l: retval = "V_SgTryStmt"; break;
        case 663l: retval = "V_SgTupleExp"; break;
        case 664l: retval = "V_SgType"; break;
        case 665l: retval = "V_SgTypeBool"; break;
        case 666l: retval = "V_SgTypeChar"; break;
        case 667l: retval = "V_SgTypeComplex"; break;
        case 668l: retval = "V_SgTypeDefault"; break;
        case 669l: retval = "V_SgTypeExpression"; break;
        case 670l: retval = "V_SgTypeLabel"; break;
        case 671l: retval = "V_SgTypeDouble"; break;
        case 672l: retval = "V_SgTypeEllipse"; break;
        case 673l: retval = "V_SgTypeFloat"; break;
        case 674l: retval = "V_SgTypeGlobalVoid"; break;
        case 675l: retval = "V_SgTypeIdOp"; break;
        case 676l: retval = "V_SgTypeImaginary"; break;
        case 677l: retval = "V_SgTypeInt"; break;
        case 678l: retval = "V_SgTypeLong"; break;
        case 679l: retval = "V_SgTypeLongDouble"; break;
        case 680l: retval = "V_SgTypeLongLong"; break;
        case 681l: retval = "V_SgTypeModifier"; break;
        case 682l: retval = "V_SgTypeMatrix"; break;
        case 683l: retval = "V_SgTypeTuple"; break;
        case 684l: retval = "V_SgTypeNullptr"; break;
        case 685l: retval = "V_SgTypeOfType"; break;
        case 686l: retval = "V_SgTypeShort"; break;
        case 687l: retval = "V_SgTypeSigned128bitInteger"; break;
        case 688l: retval = "V_SgTypeSignedChar"; break;
        case 689l: retval = "V_SgTypeSignedInt"; break;
        case 690l: retval = "V_SgTypeSignedLong"; break;
        case 691l: retval = "V_SgTypeSignedLongLong"; break;
        case 692l: retval = "V_SgTypeSignedShort"; break;
        case 693l: retval = "V_SgTypeString"; break;
        case 694l: retval = "V_SgTypeUnknown"; break;
        case 695l: retval = "V_SgTypeUnsigned128bitInteger"; break;
        case 696l: retval = "V_SgTypeUnsignedChar"; break;
        case 697l: retval = "V_SgTypeUnsignedInt"; break;
        case 698l: retval = "V_SgTypeUnsignedLong"; break;
        case 699l: retval = "V_SgTypeUnsignedLongLong"; break;
        case 700l: retval = "V_SgTypeUnsignedShort"; break;
        case 701l: retval = "V_SgTypeVoid"; break;
        case 702l: retval = "V_SgTypeWchar"; break;
        case 703l: retval = "V_SgTypedefDeclaration"; break;
        case 704l: retval = "V_SgTypedefSeq"; break;
        case 705l: retval = "V_SgTypedefSymbol"; break;
        case 706l: retval = "V_SgTypedefType"; break;
        case 707l: retval = "V_SgUPC_AccessModifier"; break;
        case 708l: retval = "V_SgUnaryAddOp"; break;
        case 709l: retval = "V_SgUnaryOp"; break;
        case 710l: retval = "V_SgUndefDirectiveStatement"; break;
        case 711l: retval = "V_SgUndirectedGraphEdge"; break;
        case 712l: retval = "V_SgUnknownArrayOrFunctionReference"; break;
        case 713l: retval = "V_SgUnknownFile"; break;
        case 715l: retval = "V_SgUnparse_Info"; break;
        case 716l: retval = "V_SgUnsignedCharVal"; break;
        case 717l: retval = "V_SgUnsignedIntVal"; break;
        case 718l: retval = "V_SgUnsignedLongLongIntVal"; break;
        case 719l: retval = "V_SgUnsignedLongVal"; break;
        case 720l: retval = "V_SgUnsignedShortVal"; break;
        case 721l: retval = "V_SgUntypedNode"; break;
        case 722l: retval = "V_SgUntypedExpression"; break;
        case 723l: retval = "V_SgUntypedUnaryOperator"; break;
        case 724l: retval = "V_SgUntypedBinaryOperator"; break;
        case 725l: retval = "V_SgUntypedValueExpression"; break;
        case 726l: retval = "V_SgUntypedArrayReferenceExpression"; break;
        case 727l: retval = "V_SgUntypedOtherExpression"; break;
        case 728l: retval = "V_SgUntypedFunctionCallOrArrayReferenceExpression"; break;
        case 729l: retval = "V_SgUntypedStatement"; break;
        case 730l: retval = "V_SgUntypedNamedStatement"; break;
        case 731l: retval = "V_SgUntypedAssignmentStatement"; break;
        case 732l: retval = "V_SgUntypedFunctionCallStatement"; break;
        case 733l: retval = "V_SgUntypedBlockStatement"; break;
        case 734l: retval = "V_SgUntypedOtherStatement"; break;
        case 735l: retval = "V_SgUntypedDeclarationStatement"; break;
        case 736l: retval = "V_SgUntypedInitializedName"; break;
        case 737l: retval = "V_SgUntypedImplicitDeclaration"; break;
        case 738l: retval = "V_SgUntypedVariableDeclaration"; break;
        case 739l: retval = "V_SgUntypedProgramHeaderDeclaration"; break;
        case 740l: retval = "V_SgUntypedFunctionDeclaration"; break;
        case 741l: retval = "V_SgUntypedSubroutineDeclaration"; break;
        case 742l: retval = "V_SgUntypedReferenceExpression"; break;
        case 743l: retval = "V_SgUntypedType"; break;
        case 744l: retval = "V_SgUntypedArrayType"; break;
        case 745l: retval = "V_SgUntypedAttribute"; break;
        case 746l: retval = "V_SgUntypedFile"; break;
        case 747l: retval = "V_SgUntypedScope"; break;
        case 748l: retval = "V_SgUntypedFunctionScope"; break;
        case 749l: retval = "V_SgUntypedModuleScope"; break;
        case 750l: retval = "V_SgUntypedGlobalScope"; break;
        case 751l: retval = "V_SgUntypedModuleDeclaration"; break;
        case 752l: retval = "V_SgUntypedStatementList"; break;
        case 753l: retval = "V_SgUntypedDeclarationStatementList"; break;
        case 754l: retval = "V_SgUntypedFunctionDeclarationList"; break;
        case 755l: retval = "V_SgUntypedInitializedNameList"; break;
        case 756l: retval = "V_SgUpcBarrierStatement"; break;
        case 757l: retval = "V_SgUpcBlocksizeofExpression"; break;
        case 758l: retval = "V_SgUpcElemsizeofExpression"; break;
        case 759l: retval = "V_SgUpcFenceStatement"; break;
        case 760l: retval = "V_SgUpcForAllStatement"; break;
        case 761l: retval = "V_SgUpcLocalsizeofExpression"; break;
        case 762l: retval = "V_SgUpcMythread"; break;
        case 763l: retval = "V_SgUpcNotifyStatement"; break;
        case 764l: retval = "V_SgUpcThreads"; break;
        case 765l: retval = "V_SgUpcWaitStatement"; break;
        case 766l: retval = "V_SgUseStatement"; break;
        case 767l: retval = "V_SgUserDefinedBinaryOp"; break;
        case 768l: retval = "V_SgUserDefinedUnaryOp"; break;
        case 769l: retval = "V_SgUsingDeclarationStatement"; break;
        case 770l: retval = "V_SgUsingDirectiveStatement"; break;
        case 771l: retval = "V_SgValueExp"; break;
        case 772l: retval = "V_SgVarArgCopyOp"; break;
        case 773l: retval = "V_SgVarArgEndOp"; break;
        case 774l: retval = "V_SgVarArgOp"; break;
        case 775l: retval = "V_SgVarArgStartOneOperandOp"; break;
        case 776l: retval = "V_SgVarArgStartOp"; break;
        case 777l: retval = "V_SgVarRefExp"; break;
        case 778l: retval = "V_SgVariableDeclaration"; break;
        case 779l: retval = "V_SgVariableDefinition"; break;
        case 780l: retval = "V_SgVariableSymbol"; break;
        case 781l: retval = "V_SgVariantExpression"; break;
        case 782l: retval = "V_SgVariantStatement"; break;
        case 783l: retval = "V_SgWaitStatement"; break;
        case 784l: retval = "V_SgWarningDirectiveStatement"; break;
        case 785l: retval = "V_SgWithStatement"; break;
        case 786l: retval = "V_SgWcharVal"; break;
        case 787l: retval = "V_SgWhereStatement"; break;
        case 788l: retval = "V_SgWhileStmt"; break;
        case 789l: retval = "V_SgWriteStatement"; break;
        case 790l: retval = "V_SgXorAssignOp"; break;
        case 791l: retval = "V_SgYieldExpression"; break;
        case 792l: retval = "V_Sg_File_Info"; break;
        case 793l: retval = "V_SgTypeCAFTeam"; break;
        case 794l: retval = "V_SgCAFWithTeamStatement"; break;
        case 795l: retval = "V_SgCAFCoExpression"; break;
        case 796l: retval = "V_SgCallExpression"; break;
        case 797l: retval = "V_SgTypeCrayPointer"; break;
        case 798l: retval = "V_SgJavaImportStatement"; break;
        case 799l: retval = "V_SgJavaPackageDeclaration"; break;
        case 800l: retval = "V_SgJavaPackageStatement"; break;
        case 801l: retval = "V_SgJavaImportStatementList"; break;
        case 802l: retval = "V_SgJavaClassDeclarationList"; break;
        case 803l: retval = "V_SgJavaMemberValuePair"; break;
        case 804l: retval = "V_SgJavaAnnotation"; break;
        case 805l: retval = "V_SgJavaMarkerAnnotation"; break;
        case 806l: retval = "V_SgJavaSingleMemberAnnotation"; break;
        case 807l: retval = "V_SgJavaNormalAnnotation"; break;
        case 808l: retval = "V_SgJavaTypeExpression"; break;
        case 809l: retval = "V_SgJavaQualifiedType"; break;
        case 810l: retval = "V_SgClassExp"; break;
        case 811l: retval = "V_SgJavaUnionType"; break;
        case 812l: retval = "V_SgJavaParameterType"; break;
        case 813l: retval = "V_SgAsyncStmt"; break;
        case 814l: retval = "V_SgFinishStmt"; break;
        case 815l: retval = "V_SgAtStmt"; break;
        case 816l: retval = "V_SgHereExp"; break;
        case 818l: retval = "V_SgNumVariants"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(VariantT)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VariantT::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// VirtualBinCFG::EdgeConditionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/virtualCFG/virtualBinCFG.h:16
/** Converts an enum of type VirtualBinCFG::EdgeConditionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualBinCFG_EdgeConditionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "eckUnconditional"; break;
        case 1l: retval = "eckTrue"; break;
        case 2l: retval = "eckFalse"; break;
        case 3l: retval = "eckCaseLabel"; break;
        case 4l: retval = "eckDefault"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(VirtualBinCFG::EdgeConditionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualBinCFG::EdgeConditionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// VirtualCFG::EdgeConditionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/virtualCFG/virtualCFG.h:48
/** Converts an enum of type VirtualCFG::EdgeConditionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualCFG_EdgeConditionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "eckUnconditional"; break;
        case 1l: retval = "eckTrue"; break;
        case 2l: retval = "eckFalse"; break;
        case 3l: retval = "eckCaseLabel"; break;
        case 4l: retval = "eckDefault"; break;
        case 5l: retval = "eckDoConditionPassed"; break;
        case 6l: retval = "eckDoConditionFailed"; break;
        case 7l: retval = "eckForallIndicesInRange"; break;
        case 8l: retval = "eckForallIndicesNotInRange"; break;
        case 9l: retval = "eckComputedGotoCaseLabel"; break;
        case 10l: retval = "eckArithmeticIfLess"; break;
        case 11l: retval = "eckArithmeticIfEqual"; break;
        case 12l: retval = "eckArithmeticIfGreater"; break;
        case 13l: retval = "eckInterprocedural"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(VirtualCFG::EdgeConditionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualCFG::EdgeConditionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// WarningType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astProcessing/AstAttributeMechanism.C:21
/** Converts an enum of type WarningType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyWarningType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "HAS_MEMORY_LEAK"; break;
        case 1l: retval = "HAS_UNKNOWN_OWNERSHIP"; break;
        case 2l: retval = "HAS_NULL_COPY"; break;
        case 3l: retval = "HAS_SELF_COPY"; break;
        case 4l: retval = "HAS_NO_CLASS_NAME"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(WarningType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "WarningType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86BranchPrediction is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:105
/** Converts an enum of type X86BranchPrediction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86BranchPrediction(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_branch_prediction_none"; break;
        case 1l: retval = "x86_branch_prediction_taken"; break;
        case 2l: retval = "x86_branch_prediction_not_taken"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86BranchPrediction)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86BranchPrediction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86Exception is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:121
/** Converts an enum of type X86Exception to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Exception(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_exception_int"; break;
        case 1l: retval = "x86_exception_sysenter"; break;
        case 2l: retval = "x86_exception_syscall"; break;
        case 3l: retval = "x86_exception_de"; break;
        case 4l: retval = "x86_exception_db"; break;
        case 5l: retval = "x86_exception_bp"; break;
        case 6l: retval = "x86_exception_of"; break;
        case 7l: retval = "x86_exception_br"; break;
        case 8l: retval = "x86_exception_ud"; break;
        case 9l: retval = "x86_exception_nm"; break;
        case 10l: retval = "x86_exception_df"; break;
        case 11l: retval = "x86_exception_ts"; break;
        case 12l: retval = "x86_exception_np"; break;
        case 13l: retval = "x86_exception_ss"; break;
        case 14l: retval = "x86_exception_gp"; break;
        case 15l: retval = "x86_exception_pf"; break;
        case 16l: retval = "x86_exception_mf"; break;
        case 17l: retval = "x86_exception_ac"; break;
        case 18l: retval = "x86_exception_mc"; break;
        case 19l: retval = "x86_exception_xm"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86Exception)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Exception::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86Flag is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:83
/** Converts an enum of type X86Flag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Flag(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_flag_cf"; break;
        case 2l: retval = "x86_flag_pf"; break;
        case 4l: retval = "x86_flag_af"; break;
        case 6l: retval = "x86_flag_zf"; break;
        case 7l: retval = "x86_flag_sf"; break;
        case 8l: retval = "x86_flag_tf"; break;
        case 9l: retval = "x86_flag_if"; break;
        case 10l: retval = "x86_flag_df"; break;
        case 11l: retval = "x86_flag_of"; break;
        case 12l: retval = "x86_flag_iopl"; break;
        case 14l: retval = "x86_flag_nt"; break;
        case 16l: retval = "x86_flag_rf"; break;
        case 17l: retval = "x86_flag_vm"; break;
        case 18l: retval = "x86_flag_ac"; break;
        case 19l: retval = "x86_flag_vif"; break;
        case 20l: retval = "x86_flag_vip"; break;
        case 21l: retval = "x86_flag_id"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86Flag)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Flag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86Flags is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:74
/** Converts an enum of type X86Flags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Flags(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_flags_status"; break;
        case 1l: retval = "x86_flags_fpstatus"; break;
        case 2l: retval = "x86_flags_fptag"; break;
        case 3l: retval = "x86_flags_fpctl"; break;
        case 4l: retval = "x86_flags_mxcsr"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86Flags)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Flags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86GeneralPurposeRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:41
/** Converts an enum of type X86GeneralPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86GeneralPurposeRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_gpr_ax"; break;
        case 1l: retval = "x86_gpr_cx"; break;
        case 2l: retval = "x86_gpr_dx"; break;
        case 3l: retval = "x86_gpr_bx"; break;
        case 4l: retval = "x86_gpr_sp"; break;
        case 5l: retval = "x86_gpr_bp"; break;
        case 6l: retval = "x86_gpr_si"; break;
        case 7l: retval = "x86_gpr_di"; break;
        case 8l: retval = "x86_gpr_r8"; break;
        case 9l: retval = "x86_gpr_r9"; break;
        case 10l: retval = "x86_gpr_r10"; break;
        case 11l: retval = "x86_gpr_r11"; break;
        case 12l: retval = "x86_gpr_r12"; break;
        case 13l: retval = "x86_gpr_r13"; break;
        case 14l: retval = "x86_gpr_r14"; break;
        case 15l: retval = "x86_gpr_r15"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86GeneralPurposeRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86GeneralPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86InstructionKind is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/AssemblerX86Init.h:22
/** Converts an enum of type X86InstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86InstructionKind(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_unknown_instruction"; break;
        case 1l: retval = "x86_aaa"; break;
        case 2l: retval = "x86_aad"; break;
        case 3l: retval = "x86_aam"; break;
        case 4l: retval = "x86_aas"; break;
        case 5l: retval = "x86_adc"; break;
        case 6l: retval = "x86_add"; break;
        case 7l: retval = "x86_addpd"; break;
        case 8l: retval = "x86_addps"; break;
        case 9l: retval = "x86_addsd"; break;
        case 10l: retval = "x86_addss"; break;
        case 11l: retval = "x86_addsubpd"; break;
        case 12l: retval = "x86_addsubps"; break;
        case 13l: retval = "x86_and"; break;
        case 14l: retval = "x86_andnpd"; break;
        case 15l: retval = "x86_andnps"; break;
        case 16l: retval = "x86_andpd"; break;
        case 17l: retval = "x86_andps"; break;
        case 18l: retval = "x86_arpl"; break;
        case 19l: retval = "x86_blendpd"; break;
        case 20l: retval = "x86_blendps"; break;
        case 21l: retval = "x86_blendvpd"; break;
        case 22l: retval = "x86_blendvps"; break;
        case 23l: retval = "x86_bound"; break;
        case 24l: retval = "x86_bsf"; break;
        case 25l: retval = "x86_bsr"; break;
        case 26l: retval = "x86_bswap"; break;
        case 27l: retval = "x86_bt"; break;
        case 28l: retval = "x86_btc"; break;
        case 29l: retval = "x86_btr"; break;
        case 30l: retval = "x86_bts"; break;
        case 31l: retval = "x86_call"; break;
        case 32l: retval = "x86_cbw"; break;
        case 33l: retval = "x86_cdq"; break;
        case 34l: retval = "x86_cdqe"; break;
        case 35l: retval = "x86_clc"; break;
        case 36l: retval = "x86_cld"; break;
        case 37l: retval = "x86_clflush"; break;
        case 38l: retval = "x86_clgi"; break;
        case 39l: retval = "x86_cli"; break;
        case 40l: retval = "x86_clts"; break;
        case 41l: retval = "x86_cmc"; break;
        case 42l: retval = "x86_cmova"; break;
        case 43l: retval = "x86_cmovae"; break;
        case 44l: retval = "x86_cmovb"; break;
        case 45l: retval = "x86_cmovbe"; break;
        case 46l: retval = "x86_cmove"; break;
        case 47l: retval = "x86_cmovg"; break;
        case 48l: retval = "x86_cmovge"; break;
        case 49l: retval = "x86_cmovl"; break;
        case 50l: retval = "x86_cmovle"; break;
        case 51l: retval = "x86_cmovne"; break;
        case 52l: retval = "x86_cmovno"; break;
        case 53l: retval = "x86_cmovns"; break;
        case 54l: retval = "x86_cmovo"; break;
        case 55l: retval = "x86_cmovpe"; break;
        case 56l: retval = "x86_cmovpo"; break;
        case 57l: retval = "x86_cmovs"; break;
        case 58l: retval = "x86_cmp"; break;
        case 59l: retval = "x86_cmppd"; break;
        case 60l: retval = "x86_cmpps"; break;
        case 61l: retval = "x86_cmpsb"; break;
        case 62l: retval = "x86_cmpsd"; break;
        case 63l: retval = "x86_cmpsq"; break;
        case 64l: retval = "x86_cmpss"; break;
        case 65l: retval = "x86_cmpsw"; break;
        case 66l: retval = "x86_cmpxchg"; break;
        case 67l: retval = "x86_cmpxchg16b"; break;
        case 68l: retval = "x86_cmpxchg8b"; break;
        case 69l: retval = "x86_comisd"; break;
        case 70l: retval = "x86_comiss"; break;
        case 71l: retval = "x86_cpuid"; break;
        case 72l: retval = "x86_cqo"; break;
        case 73l: retval = "x86_crc32"; break;
        case 74l: retval = "x86_cvtdq2pd"; break;
        case 75l: retval = "x86_cvtdq2ps"; break;
        case 76l: retval = "x86_cvtpd2dq"; break;
        case 77l: retval = "x86_cvtpd2pi"; break;
        case 78l: retval = "x86_cvtpd2ps"; break;
        case 79l: retval = "x86_cvtpi2pd"; break;
        case 80l: retval = "x86_cvtpi2ps"; break;
        case 81l: retval = "x86_cvtps2dq"; break;
        case 82l: retval = "x86_cvtps2pd"; break;
        case 83l: retval = "x86_cvtps2pi"; break;
        case 84l: retval = "x86_cvtsd2si"; break;
        case 85l: retval = "x86_cvtsd2ss"; break;
        case 86l: retval = "x86_cvtsi2sd"; break;
        case 87l: retval = "x86_cvtsi2ss"; break;
        case 88l: retval = "x86_cvtss2sd"; break;
        case 89l: retval = "x86_cvtss2si"; break;
        case 90l: retval = "x86_cvttpd2dq"; break;
        case 91l: retval = "x86_cvttpd2pi"; break;
        case 92l: retval = "x86_cvttps2dq"; break;
        case 93l: retval = "x86_cvttps2pi"; break;
        case 94l: retval = "x86_cvttsd2si"; break;
        case 95l: retval = "x86_cvttss2si"; break;
        case 96l: retval = "x86_cwd"; break;
        case 97l: retval = "x86_cwde"; break;
        case 98l: retval = "x86_daa"; break;
        case 99l: retval = "x86_das"; break;
        case 100l: retval = "x86_dec"; break;
        case 101l: retval = "x86_div"; break;
        case 102l: retval = "x86_divpd"; break;
        case 103l: retval = "x86_divps"; break;
        case 104l: retval = "x86_divsd"; break;
        case 105l: retval = "x86_divss"; break;
        case 106l: retval = "x86_dppd"; break;
        case 107l: retval = "x86_dpps"; break;
        case 108l: retval = "x86_emms"; break;
        case 109l: retval = "x86_enter"; break;
        case 110l: retval = "x86_extractps"; break;
        case 111l: retval = "x86_extrq"; break;
        case 112l: retval = "x86_f2xm1"; break;
        case 113l: retval = "x86_fabs"; break;
        case 114l: retval = "x86_fadd"; break;
        case 115l: retval = "x86_faddp"; break;
        case 116l: retval = "x86_farcall"; break;
        case 117l: retval = "x86_farjmp"; break;
        case 118l: retval = "x86_fbld"; break;
        case 119l: retval = "x86_fbstp"; break;
        case 120l: retval = "x86_fchs"; break;
        case 121l: retval = "x86_fcmovb"; break;
        case 122l: retval = "x86_fcmovbe"; break;
        case 123l: retval = "x86_fcmove"; break;
        case 124l: retval = "x86_fcmovnb"; break;
        case 125l: retval = "x86_fcmovnbe"; break;
        case 126l: retval = "x86_fcmovne"; break;
        case 127l: retval = "x86_fcmovnu"; break;
        case 128l: retval = "x86_fcmovu"; break;
        case 129l: retval = "x86_fcom"; break;
        case 130l: retval = "x86_fcomi"; break;
        case 131l: retval = "x86_fcomip"; break;
        case 132l: retval = "x86_fcomp"; break;
        case 133l: retval = "x86_fcompp"; break;
        case 134l: retval = "x86_fcos"; break;
        case 135l: retval = "x86_fdecstp"; break;
        case 136l: retval = "x86_fdiv"; break;
        case 137l: retval = "x86_fdivp"; break;
        case 138l: retval = "x86_fdivr"; break;
        case 139l: retval = "x86_fdivrp"; break;
        case 140l: retval = "x86_femms"; break;
        case 141l: retval = "x86_ffree"; break;
        case 142l: retval = "x86_fiadd"; break;
        case 143l: retval = "x86_ficom"; break;
        case 144l: retval = "x86_ficomp"; break;
        case 145l: retval = "x86_fidiv"; break;
        case 146l: retval = "x86_fidivr"; break;
        case 147l: retval = "x86_fild"; break;
        case 148l: retval = "x86_fimul"; break;
        case 149l: retval = "x86_fincstp"; break;
        case 150l: retval = "x86_fist"; break;
        case 151l: retval = "x86_fistp"; break;
        case 152l: retval = "x86_fisttp"; break;
        case 153l: retval = "x86_fisub"; break;
        case 154l: retval = "x86_fisubr"; break;
        case 155l: retval = "x86_fld"; break;
        case 156l: retval = "x86_fld1"; break;
        case 157l: retval = "x86_fldcw"; break;
        case 158l: retval = "x86_fldenv"; break;
        case 159l: retval = "x86_fldl2e"; break;
        case 160l: retval = "x86_fldl2t"; break;
        case 161l: retval = "x86_fldlg2"; break;
        case 162l: retval = "x86_fldln2"; break;
        case 163l: retval = "x86_fldpi"; break;
        case 164l: retval = "x86_fldz"; break;
        case 165l: retval = "x86_fmul"; break;
        case 166l: retval = "x86_fmulp"; break;
        case 167l: retval = "x86_fnclex"; break;
        case 168l: retval = "x86_fninit"; break;
        case 169l: retval = "x86_fnop"; break;
        case 170l: retval = "x86_fnsave"; break;
        case 171l: retval = "x86_fnstcw"; break;
        case 172l: retval = "x86_fnstenv"; break;
        case 173l: retval = "x86_fnstsw"; break;
        case 174l: retval = "x86_fpatan"; break;
        case 175l: retval = "x86_fprem"; break;
        case 176l: retval = "x86_fprem1"; break;
        case 177l: retval = "x86_fptan"; break;
        case 178l: retval = "x86_frndint"; break;
        case 179l: retval = "x86_frstor"; break;
        case 180l: retval = "x86_fscale"; break;
        case 181l: retval = "x86_fsin"; break;
        case 182l: retval = "x86_fsincos"; break;
        case 183l: retval = "x86_fsqrt"; break;
        case 184l: retval = "x86_fst"; break;
        case 185l: retval = "x86_fstp"; break;
        case 186l: retval = "x86_fsub"; break;
        case 187l: retval = "x86_fsubp"; break;
        case 188l: retval = "x86_fsubr"; break;
        case 189l: retval = "x86_fsubrp"; break;
        case 190l: retval = "x86_ftst"; break;
        case 191l: retval = "x86_fucom"; break;
        case 192l: retval = "x86_fucomi"; break;
        case 193l: retval = "x86_fucomip"; break;
        case 194l: retval = "x86_fucomp"; break;
        case 195l: retval = "x86_fucompp"; break;
        case 196l: retval = "x86_fwait"; break;
        case 197l: retval = "x86_fxam"; break;
        case 198l: retval = "x86_fxch"; break;
        case 199l: retval = "x86_fxrstor"; break;
        case 200l: retval = "x86_fxsave"; break;
        case 201l: retval = "x86_fxtract"; break;
        case 202l: retval = "x86_fyl2x"; break;
        case 203l: retval = "x86_fyl2xp1"; break;
        case 204l: retval = "x86_getsec"; break;
        case 205l: retval = "x86_haddpd"; break;
        case 206l: retval = "x86_haddps"; break;
        case 207l: retval = "x86_hlt"; break;
        case 208l: retval = "x86_hsubpd"; break;
        case 209l: retval = "x86_hsubps"; break;
        case 210l: retval = "x86_idiv"; break;
        case 211l: retval = "x86_imul"; break;
        case 212l: retval = "x86_in"; break;
        case 213l: retval = "x86_inc"; break;
        case 214l: retval = "x86_insb"; break;
        case 215l: retval = "x86_insd"; break;
        case 216l: retval = "x86_insertps"; break;
        case 217l: retval = "x86_insertq"; break;
        case 218l: retval = "x86_insw"; break;
        case 219l: retval = "x86_int"; break;
        case 220l: retval = "x86_int1"; break;
        case 221l: retval = "x86_int3"; break;
        case 222l: retval = "x86_into"; break;
        case 223l: retval = "x86_invd"; break;
        case 224l: retval = "x86_invept"; break;
        case 225l: retval = "x86_invlpg"; break;
        case 226l: retval = "x86_invlpga"; break;
        case 227l: retval = "x86_invvpid"; break;
        case 228l: retval = "x86_iret"; break;
        case 229l: retval = "x86_ja"; break;
        case 230l: retval = "x86_jae"; break;
        case 231l: retval = "x86_jb"; break;
        case 232l: retval = "x86_jbe"; break;
        case 233l: retval = "x86_jcxz"; break;
        case 234l: retval = "x86_je"; break;
        case 235l: retval = "x86_jecxz"; break;
        case 236l: retval = "x86_jg"; break;
        case 237l: retval = "x86_jge"; break;
        case 238l: retval = "x86_jl"; break;
        case 239l: retval = "x86_jle"; break;
        case 240l: retval = "x86_jmp"; break;
        case 241l: retval = "x86_jmpe"; break;
        case 242l: retval = "x86_jne"; break;
        case 243l: retval = "x86_jno"; break;
        case 244l: retval = "x86_jns"; break;
        case 245l: retval = "x86_jo"; break;
        case 246l: retval = "x86_jpe"; break;
        case 247l: retval = "x86_jpo"; break;
        case 248l: retval = "x86_jrcxz"; break;
        case 249l: retval = "x86_js"; break;
        case 250l: retval = "x86_lahf"; break;
        case 251l: retval = "x86_lar"; break;
        case 252l: retval = "x86_lddqu"; break;
        case 253l: retval = "x86_ldmxcsr"; break;
        case 254l: retval = "x86_lds"; break;
        case 255l: retval = "x86_lea"; break;
        case 256l: retval = "x86_leave"; break;
        case 257l: retval = "x86_les"; break;
        case 258l: retval = "x86_lfence"; break;
        case 259l: retval = "x86_lfs"; break;
        case 260l: retval = "x86_lgdt"; break;
        case 261l: retval = "x86_lgs"; break;
        case 262l: retval = "x86_lidt"; break;
        case 263l: retval = "x86_lldt"; break;
        case 264l: retval = "x86_lmsw"; break;
        case 265l: retval = "x86_lock"; break;
        case 266l: retval = "x86_lodsb"; break;
        case 267l: retval = "x86_lodsd"; break;
        case 268l: retval = "x86_lodsq"; break;
        case 269l: retval = "x86_lodsw"; break;
        case 270l: retval = "x86_loop"; break;
        case 271l: retval = "x86_loopnz"; break;
        case 272l: retval = "x86_loopz"; break;
        case 273l: retval = "x86_lsl"; break;
        case 274l: retval = "x86_lss"; break;
        case 275l: retval = "x86_ltr"; break;
        case 276l: retval = "x86_lzcnt"; break;
        case 277l: retval = "x86_maskmovq"; break;
        case 278l: retval = "x86_maxpd"; break;
        case 279l: retval = "x86_maxps"; break;
        case 280l: retval = "x86_maxsd"; break;
        case 281l: retval = "x86_maxss"; break;
        case 282l: retval = "x86_mfence"; break;
        case 283l: retval = "x86_minpd"; break;
        case 284l: retval = "x86_minps"; break;
        case 285l: retval = "x86_minsd"; break;
        case 286l: retval = "x86_minss"; break;
        case 287l: retval = "x86_monitor"; break;
        case 288l: retval = "x86_mov"; break;
        case 289l: retval = "x86_movapd"; break;
        case 290l: retval = "x86_movaps"; break;
        case 291l: retval = "x86_movbe"; break;
        case 292l: retval = "x86_movd"; break;
        case 293l: retval = "x86_movddup"; break;
        case 294l: retval = "x86_movdq2q"; break;
        case 295l: retval = "x86_movdqa"; break;
        case 296l: retval = "x86_movdqu"; break;
        case 297l: retval = "x86_movhlps"; break;
        case 298l: retval = "x86_movhpd"; break;
        case 299l: retval = "x86_movhps"; break;
        case 300l: retval = "x86_movlhps"; break;
        case 301l: retval = "x86_movlpd"; break;
        case 302l: retval = "x86_movlps"; break;
        case 303l: retval = "x86_movmskpd"; break;
        case 304l: retval = "x86_movmskps"; break;
        case 305l: retval = "x86_movntdq"; break;
        case 306l: retval = "x86_movntdqa"; break;
        case 307l: retval = "x86_movnti"; break;
        case 308l: retval = "x86_movntpd"; break;
        case 309l: retval = "x86_movntps"; break;
        case 310l: retval = "x86_movntq"; break;
        case 311l: retval = "x86_movntsd"; break;
        case 312l: retval = "x86_movntss"; break;
        case 313l: retval = "x86_movq"; break;
        case 314l: retval = "x86_movq2dq"; break;
        case 315l: retval = "x86_movsb"; break;
        case 316l: retval = "x86_movsd"; break;
        case 317l: retval = "x86_movsd_sse"; break;
        case 318l: retval = "x86_movshdup"; break;
        case 319l: retval = "x86_movsldup"; break;
        case 320l: retval = "x86_movsq"; break;
        case 321l: retval = "x86_movss"; break;
        case 322l: retval = "x86_movsw"; break;
        case 323l: retval = "x86_movsx"; break;
        case 324l: retval = "x86_movsxd"; break;
        case 325l: retval = "x86_movupd"; break;
        case 326l: retval = "x86_movups"; break;
        case 327l: retval = "x86_movzx"; break;
        case 328l: retval = "x86_mpsadbw"; break;
        case 329l: retval = "x86_mul"; break;
        case 330l: retval = "x86_mulpd"; break;
        case 331l: retval = "x86_mulps"; break;
        case 332l: retval = "x86_mulsd"; break;
        case 333l: retval = "x86_mulss"; break;
        case 334l: retval = "x86_mwait"; break;
        case 335l: retval = "x86_neg"; break;
        case 336l: retval = "x86_nop"; break;
        case 337l: retval = "x86_not"; break;
        case 338l: retval = "x86_or"; break;
        case 339l: retval = "x86_orpd"; break;
        case 340l: retval = "x86_orps"; break;
        case 341l: retval = "x86_out"; break;
        case 342l: retval = "x86_outs"; break;
        case 343l: retval = "x86_outsb"; break;
        case 344l: retval = "x86_outsd"; break;
        case 345l: retval = "x86_outsw"; break;
        case 346l: retval = "x86_pabsb"; break;
        case 347l: retval = "x86_pabsd"; break;
        case 348l: retval = "x86_pabsw"; break;
        case 349l: retval = "x86_packssdw"; break;
        case 350l: retval = "x86_packsswb"; break;
        case 351l: retval = "x86_packusdw"; break;
        case 352l: retval = "x86_packuswb"; break;
        case 353l: retval = "x86_paddb"; break;
        case 354l: retval = "x86_paddd"; break;
        case 355l: retval = "x86_paddq"; break;
        case 356l: retval = "x86_paddsb"; break;
        case 357l: retval = "x86_paddsw"; break;
        case 358l: retval = "x86_paddusb"; break;
        case 359l: retval = "x86_paddusw"; break;
        case 360l: retval = "x86_paddw"; break;
        case 361l: retval = "x86_palignr"; break;
        case 362l: retval = "x86_pand"; break;
        case 363l: retval = "x86_pandn"; break;
        case 364l: retval = "x86_pause"; break;
        case 365l: retval = "x86_pavgb"; break;
        case 366l: retval = "x86_pavgusb"; break;
        case 367l: retval = "x86_pavgw"; break;
        case 368l: retval = "x86_pblendvb"; break;
        case 369l: retval = "x86_pblendw"; break;
        case 370l: retval = "x86_pcmpeqb"; break;
        case 371l: retval = "x86_pcmpeqd"; break;
        case 372l: retval = "x86_pcmpeqq"; break;
        case 373l: retval = "x86_pcmpeqw"; break;
        case 374l: retval = "x86_pcmpestri"; break;
        case 375l: retval = "x86_pcmpestrm"; break;
        case 376l: retval = "x86_pcmpgtb"; break;
        case 377l: retval = "x86_pcmpgtd"; break;
        case 378l: retval = "x86_pcmpgtq"; break;
        case 379l: retval = "x86_pcmpgtw"; break;
        case 380l: retval = "x86_pcmpistri"; break;
        case 381l: retval = "x86_pcmpistrm"; break;
        case 382l: retval = "x86_pextrb"; break;
        case 383l: retval = "x86_pextrd"; break;
        case 384l: retval = "x86_pextrq"; break;
        case 385l: retval = "x86_pextrw"; break;
        case 386l: retval = "x86_pf2id"; break;
        case 387l: retval = "x86_pf2iw"; break;
        case 388l: retval = "x86_pfacc"; break;
        case 389l: retval = "x86_pfadd"; break;
        case 390l: retval = "x86_pfcmpeq"; break;
        case 391l: retval = "x86_pfcmpge"; break;
        case 392l: retval = "x86_pfcmpgt"; break;
        case 393l: retval = "x86_pfmax"; break;
        case 394l: retval = "x86_pfmin"; break;
        case 395l: retval = "x86_pfmul"; break;
        case 396l: retval = "x86_pfnacc"; break;
        case 397l: retval = "x86_pfpnacc"; break;
        case 398l: retval = "x86_pfrcp"; break;
        case 399l: retval = "x86_pfrcpit1"; break;
        case 400l: retval = "x86_pfrcpit2"; break;
        case 401l: retval = "x86_pfrsqit1"; break;
        case 402l: retval = "x86_pfrsqrt"; break;
        case 403l: retval = "x86_pfsub"; break;
        case 404l: retval = "x86_pfsubr"; break;
        case 405l: retval = "x86_phaddd"; break;
        case 406l: retval = "x86_phaddsw"; break;
        case 407l: retval = "x86_phaddw"; break;
        case 408l: retval = "x86_phminposuw"; break;
        case 409l: retval = "x86_phsubd"; break;
        case 410l: retval = "x86_phsubsw"; break;
        case 411l: retval = "x86_phsubw"; break;
        case 412l: retval = "x86_pi2fd"; break;
        case 413l: retval = "x86_pi2fw"; break;
        case 414l: retval = "x86_pinsrb"; break;
        case 415l: retval = "x86_pinsrd"; break;
        case 416l: retval = "x86_pinsrq"; break;
        case 417l: retval = "x86_pinsrw"; break;
        case 418l: retval = "x86_pmaddubsw"; break;
        case 419l: retval = "x86_pmaddwd"; break;
        case 420l: retval = "x86_pmaxsb"; break;
        case 421l: retval = "x86_pmaxsd"; break;
        case 422l: retval = "x86_pmaxsw"; break;
        case 423l: retval = "x86_pmaxub"; break;
        case 424l: retval = "x86_pmaxud"; break;
        case 425l: retval = "x86_pmaxuw"; break;
        case 426l: retval = "x86_pminsb"; break;
        case 427l: retval = "x86_pminsd"; break;
        case 428l: retval = "x86_pminsw"; break;
        case 429l: retval = "x86_pminub"; break;
        case 430l: retval = "x86_pminud"; break;
        case 431l: retval = "x86_pminuw"; break;
        case 432l: retval = "x86_pmovmskb"; break;
        case 433l: retval = "x86_pmovsxbd"; break;
        case 434l: retval = "x86_pmovsxbq"; break;
        case 435l: retval = "x86_pmovsxbw"; break;
        case 436l: retval = "x86_pmovsxdq"; break;
        case 437l: retval = "x86_pmovsxwd"; break;
        case 438l: retval = "x86_pmovsxwq"; break;
        case 439l: retval = "x86_pmovzxbd"; break;
        case 440l: retval = "x86_pmovzxbq"; break;
        case 441l: retval = "x86_pmovzxbw"; break;
        case 442l: retval = "x86_pmovzxdq"; break;
        case 443l: retval = "x86_pmovzxwd"; break;
        case 444l: retval = "x86_pmovzxwq"; break;
        case 445l: retval = "x86_pmuldq"; break;
        case 446l: retval = "x86_pmulhrsw"; break;
        case 447l: retval = "x86_pmulhrw"; break;
        case 448l: retval = "x86_pmulhuw"; break;
        case 449l: retval = "x86_pmulhw"; break;
        case 450l: retval = "x86_pmulld"; break;
        case 451l: retval = "x86_pmullw"; break;
        case 452l: retval = "x86_pmuludq"; break;
        case 453l: retval = "x86_pop"; break;
        case 454l: retval = "x86_popa"; break;
        case 455l: retval = "x86_popad"; break;
        case 456l: retval = "x86_popcnt"; break;
        case 457l: retval = "x86_popf"; break;
        case 458l: retval = "x86_popfd"; break;
        case 459l: retval = "x86_popfq"; break;
        case 460l: retval = "x86_por"; break;
        case 461l: retval = "x86_prefetch"; break;
        case 462l: retval = "x86_prefetchnta"; break;
        case 463l: retval = "x86_prefetcht0"; break;
        case 464l: retval = "x86_prefetcht1"; break;
        case 465l: retval = "x86_prefetcht2"; break;
        case 466l: retval = "x86_prefetchw"; break;
        case 467l: retval = "x86_psadbw"; break;
        case 468l: retval = "x86_pshufb"; break;
        case 469l: retval = "x86_pshufd"; break;
        case 470l: retval = "x86_pshufhw"; break;
        case 471l: retval = "x86_pshuflw"; break;
        case 472l: retval = "x86_pshufw"; break;
        case 473l: retval = "x86_psignb"; break;
        case 474l: retval = "x86_psignd"; break;
        case 475l: retval = "x86_psignw"; break;
        case 476l: retval = "x86_pslld"; break;
        case 477l: retval = "x86_pslldq"; break;
        case 478l: retval = "x86_psllq"; break;
        case 479l: retval = "x86_psllw"; break;
        case 480l: retval = "x86_psrad"; break;
        case 481l: retval = "x86_psraq"; break;
        case 482l: retval = "x86_psraw"; break;
        case 483l: retval = "x86_psrld"; break;
        case 484l: retval = "x86_psrldq"; break;
        case 485l: retval = "x86_psrlq"; break;
        case 486l: retval = "x86_psrlw"; break;
        case 487l: retval = "x86_psubb"; break;
        case 488l: retval = "x86_psubd"; break;
        case 489l: retval = "x86_psubq"; break;
        case 490l: retval = "x86_psubsb"; break;
        case 491l: retval = "x86_psubsw"; break;
        case 492l: retval = "x86_psubusb"; break;
        case 493l: retval = "x86_psubusw"; break;
        case 494l: retval = "x86_psubw"; break;
        case 495l: retval = "x86_pswapd"; break;
        case 496l: retval = "x86_ptest"; break;
        case 497l: retval = "x86_punpckhbw"; break;
        case 498l: retval = "x86_punpckhdq"; break;
        case 499l: retval = "x86_punpckhqdq"; break;
        case 500l: retval = "x86_punpckhwd"; break;
        case 501l: retval = "x86_punpcklbw"; break;
        case 502l: retval = "x86_punpckldq"; break;
        case 503l: retval = "x86_punpcklqdq"; break;
        case 504l: retval = "x86_punpcklwd"; break;
        case 505l: retval = "x86_push"; break;
        case 506l: retval = "x86_pusha"; break;
        case 507l: retval = "x86_pushad"; break;
        case 508l: retval = "x86_pushf"; break;
        case 509l: retval = "x86_pushfd"; break;
        case 510l: retval = "x86_pushfq"; break;
        case 511l: retval = "x86_pxor"; break;
        case 512l: retval = "x86_rcl"; break;
        case 513l: retval = "x86_rcpps"; break;
        case 514l: retval = "x86_rcpss"; break;
        case 515l: retval = "x86_rcr"; break;
        case 516l: retval = "x86_rdmsr"; break;
        case 517l: retval = "x86_rdpmc"; break;
        case 518l: retval = "x86_rdtsc"; break;
        case 519l: retval = "x86_rdtscp"; break;
        case 520l: retval = "x86_rep_insb"; break;
        case 521l: retval = "x86_rep_insd"; break;
        case 522l: retval = "x86_rep_insw"; break;
        case 523l: retval = "x86_rep_lodsb"; break;
        case 524l: retval = "x86_rep_lodsd"; break;
        case 525l: retval = "x86_rep_lodsq"; break;
        case 526l: retval = "x86_rep_lodsw"; break;
        case 527l: retval = "x86_rep_movsb"; break;
        case 528l: retval = "x86_rep_movsd"; break;
        case 529l: retval = "x86_rep_movsq"; break;
        case 530l: retval = "x86_rep_movsw"; break;
        case 531l: retval = "x86_rep_outsb"; break;
        case 532l: retval = "x86_rep_outsd"; break;
        case 533l: retval = "x86_rep_outsw"; break;
        case 534l: retval = "x86_rep_stosb"; break;
        case 535l: retval = "x86_rep_stosd"; break;
        case 536l: retval = "x86_rep_stosq"; break;
        case 537l: retval = "x86_rep_stosw"; break;
        case 538l: retval = "x86_repe_cmpsb"; break;
        case 539l: retval = "x86_repe_cmpsd"; break;
        case 540l: retval = "x86_repe_cmpsq"; break;
        case 541l: retval = "x86_repe_cmpsw"; break;
        case 542l: retval = "x86_repe_scasb"; break;
        case 543l: retval = "x86_repe_scasd"; break;
        case 544l: retval = "x86_repe_scasq"; break;
        case 545l: retval = "x86_repe_scasw"; break;
        case 546l: retval = "x86_repne_cmpsb"; break;
        case 547l: retval = "x86_repne_cmpsd"; break;
        case 548l: retval = "x86_repne_cmpsq"; break;
        case 549l: retval = "x86_repne_cmpsw"; break;
        case 550l: retval = "x86_repne_scasb"; break;
        case 551l: retval = "x86_repne_scasd"; break;
        case 552l: retval = "x86_repne_scasq"; break;
        case 553l: retval = "x86_repne_scasw"; break;
        case 554l: retval = "x86_ret"; break;
        case 555l: retval = "x86_retf"; break;
        case 556l: retval = "x86_rol"; break;
        case 557l: retval = "x86_ror"; break;
        case 558l: retval = "x86_roundpd"; break;
        case 559l: retval = "x86_roundps"; break;
        case 560l: retval = "x86_roundsd"; break;
        case 561l: retval = "x86_roundss"; break;
        case 562l: retval = "x86_rsm"; break;
        case 563l: retval = "x86_rsqrtps"; break;
        case 564l: retval = "x86_rsqrtss"; break;
        case 565l: retval = "x86_sahf"; break;
        case 566l: retval = "x86_salc"; break;
        case 567l: retval = "x86_sar"; break;
        case 568l: retval = "x86_sbb"; break;
        case 569l: retval = "x86_scasb"; break;
        case 570l: retval = "x86_scasd"; break;
        case 571l: retval = "x86_scasq"; break;
        case 572l: retval = "x86_scasw"; break;
        case 573l: retval = "x86_seta"; break;
        case 574l: retval = "x86_setae"; break;
        case 575l: retval = "x86_setb"; break;
        case 576l: retval = "x86_setbe"; break;
        case 577l: retval = "x86_sete"; break;
        case 578l: retval = "x86_setg"; break;
        case 579l: retval = "x86_setge"; break;
        case 580l: retval = "x86_setl"; break;
        case 581l: retval = "x86_setle"; break;
        case 582l: retval = "x86_setne"; break;
        case 583l: retval = "x86_setno"; break;
        case 584l: retval = "x86_setns"; break;
        case 585l: retval = "x86_seto"; break;
        case 586l: retval = "x86_setpe"; break;
        case 587l: retval = "x86_setpo"; break;
        case 588l: retval = "x86_sets"; break;
        case 589l: retval = "x86_sfence"; break;
        case 590l: retval = "x86_sgdt"; break;
        case 591l: retval = "x86_shl"; break;
        case 592l: retval = "x86_shld"; break;
        case 593l: retval = "x86_shr"; break;
        case 594l: retval = "x86_shrd"; break;
        case 595l: retval = "x86_shufpd"; break;
        case 596l: retval = "x86_shufps"; break;
        case 597l: retval = "x86_sidt"; break;
        case 598l: retval = "x86_skinit"; break;
        case 599l: retval = "x86_sldt"; break;
        case 600l: retval = "x86_smsw"; break;
        case 601l: retval = "x86_sqrtpd"; break;
        case 602l: retval = "x86_sqrtps"; break;
        case 603l: retval = "x86_sqrtsd"; break;
        case 604l: retval = "x86_sqrtss"; break;
        case 605l: retval = "x86_stc"; break;
        case 606l: retval = "x86_std"; break;
        case 607l: retval = "x86_stgi"; break;
        case 608l: retval = "x86_sti"; break;
        case 609l: retval = "x86_stmxcsr"; break;
        case 610l: retval = "x86_stos"; break;
        case 611l: retval = "x86_stosb"; break;
        case 612l: retval = "x86_stosd"; break;
        case 613l: retval = "x86_stosq"; break;
        case 614l: retval = "x86_stosw"; break;
        case 615l: retval = "x86_str"; break;
        case 616l: retval = "x86_sub"; break;
        case 617l: retval = "x86_subpd"; break;
        case 618l: retval = "x86_subps"; break;
        case 619l: retval = "x86_subsd"; break;
        case 620l: retval = "x86_subss"; break;
        case 621l: retval = "x86_swapgs"; break;
        case 622l: retval = "x86_syscall"; break;
        case 623l: retval = "x86_sysenter"; break;
        case 624l: retval = "x86_sysexit"; break;
        case 625l: retval = "x86_sysret"; break;
        case 626l: retval = "x86_test"; break;
        case 627l: retval = "x86_ucomisd"; break;
        case 628l: retval = "x86_ucomiss"; break;
        case 629l: retval = "x86_ud2"; break;
        case 630l: retval = "x86_unpckhpd"; break;
        case 631l: retval = "x86_unpckhps"; break;
        case 632l: retval = "x86_unpcklpd"; break;
        case 633l: retval = "x86_unpcklps"; break;
        case 634l: retval = "x86_verr"; break;
        case 635l: retval = "x86_verw"; break;
        case 636l: retval = "x86_vmcall"; break;
        case 637l: retval = "x86_vmclear"; break;
        case 638l: retval = "x86_vmlaunch"; break;
        case 639l: retval = "x86_vmload"; break;
        case 640l: retval = "x86_vmmcall"; break;
        case 641l: retval = "x86_vmoff"; break;
        case 642l: retval = "x86_vmptrld"; break;
        case 643l: retval = "x86_vmptrst"; break;
        case 644l: retval = "x86_vmread"; break;
        case 645l: retval = "x86_vmresume"; break;
        case 646l: retval = "x86_vmrun"; break;
        case 647l: retval = "x86_vmsave"; break;
        case 648l: retval = "x86_vmwrite"; break;
        case 649l: retval = "x86_vmxoff"; break;
        case 650l: retval = "x86_vmxon"; break;
        case 651l: retval = "x86_wait"; break;
        case 652l: retval = "x86_wbinvd"; break;
        case 653l: retval = "x86_wrmsr"; break;
        case 654l: retval = "x86_xadd"; break;
        case 655l: retval = "x86_xchg"; break;
        case 656l: retval = "x86_xgetbv"; break;
        case 657l: retval = "x86_xlatb"; break;
        case 658l: retval = "x86_xor"; break;
        case 659l: retval = "x86_xorpd"; break;
        case 660l: retval = "x86_xorps"; break;
        case 661l: retval = "x86_xrstor"; break;
        case 662l: retval = "x86_xsave"; break;
        case 663l: retval = "x86_xsetbv"; break;
        case 664l: retval = "x86_last_instruction"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86InstructionKind)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86InstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86InstructionSize is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:9
/** Converts an enum of type X86InstructionSize to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86InstructionSize(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_insnsize_none"; break;
        case 1l: retval = "x86_insnsize_16"; break;
        case 2l: retval = "x86_insnsize_32"; break;
        case 3l: retval = "x86_insnsize_64"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86InstructionSize)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86InstructionSize::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86RegisterClass is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:17
/** Converts an enum of type X86RegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86RegisterClass(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_regclass_gpr"; break;
        case 1l: retval = "x86_regclass_segment"; break;
        case 2l: retval = "x86_regclass_cr"; break;
        case 3l: retval = "x86_regclass_dr"; break;
        case 4l: retval = "x86_regclass_st"; break;
        case 5l: retval = "x86_regclass_xmm"; break;
        case 6l: retval = "x86_regclass_ip"; break;
        case 7l: retval = "x86_regclass_flags"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86RegisterClass)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86RegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86RepeatPrefix is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:113
/** Converts an enum of type X86RepeatPrefix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86RepeatPrefix(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_repeat_none"; break;
        case 1l: retval = "x86_repeat_repne"; break;
        case 2l: retval = "x86_repeat_repe"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86RepeatPrefix)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86RepeatPrefix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86SegmentRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:30
/** Converts an enum of type X86SegmentRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86SegmentRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_segreg_es"; break;
        case 1l: retval = "x86_segreg_cs"; break;
        case 2l: retval = "x86_segreg_ss"; break;
        case 3l: retval = "x86_segreg_ds"; break;
        case 4l: retval = "x86_segreg_fs"; break;
        case 5l: retval = "x86_segreg_gs"; break;
        case 16l: retval = "x86_segreg_none"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86SegmentRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86SegmentRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86StRegister is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/InstructionEnumsX86.h:61
/** Converts an enum of type X86StRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86StRegister(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "x86_st_0"; break;
        case 1l: retval = "x86_st_1"; break;
        case 2l: retval = "x86_st_2"; break;
        case 3l: retval = "x86_st_3"; break;
        case 4l: retval = "x86_st_4"; break;
        case 5l: retval = "x86_st_5"; break;
        case 6l: retval = "x86_st_6"; break;
        case 7l: retval = "x86_st_7"; break;
        case 8l: retval = "x86_st_nregs"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(X86StRegister)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86StRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// __ptrace_request is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/Disassemblers/BinaryDebugger.C:10
/** Converts an enum of type __ptrace_request to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify__ptrace_request(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PTRACE_ATTACH"; break;
        case 1l: retval = "PTRACE_CONT"; break;
        case 2l: retval = "PTRACE_DETACH"; break;
        case 3l: retval = "PTRACE_GETREGS"; break;
        case 4l: retval = "PTRACE_GETFPREGS"; break;
        case 5l: retval = "PTRACE_KILL"; break;
        case 6l: retval = "PTRACE_SETREGS"; break;
        case 7l: retval = "PTRACE_SINGLESTEP"; break;
        case 8l: retval = "PTRACE_TRACEME"; break;
        case 9l: retval = "PTRACE_PEEKUSER"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(__ptrace_request)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "__ptrace_request::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::edge_dbg_data_t is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:358
/** Converts an enum of type boost::edge_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_edge_dbg_data_t(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "edge_dbg_data"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(boost::edge_dbg_data_t)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::edge_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::graph_dbg_data_t is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:361
/** Converts an enum of type boost::graph_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_graph_dbg_data_t(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "graph_dbg_data"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(boost::graph_dbg_data_t)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::graph_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::vertex_callgraph_t is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/CallGraphAnalysisMySQL/Callgraph.h:34
/** Converts an enum of type boost::vertex_callgraph_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_callgraph_t(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "vertex_callgraph"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(boost::vertex_callgraph_t)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_callgraph_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::vertex_classhierarchy_t is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/CallGraphAnalysisMySQL/Classhierarchy.h:32
/** Converts an enum of type boost::vertex_classhierarchy_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_classhierarchy_t(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "vertex_classhierarchy"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(boost::vertex_classhierarchy_t)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_classhierarchy_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::vertex_dbg_data_t is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:355
/** Converts an enum of type boost::vertex_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_dbg_data_t(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "vertex_dbg_data"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(boost::vertex_dbg_data_t)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// controlEnum is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseExtensions/dataStructureTraversal/exampleTest.C:4
/** Converts an enum of type controlEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_controlEnum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "BEGGINING_OF_ENUM"; break;
        case 1l: retval = "typeInt"; break;
        case 2l: retval = "typeChar"; break;
        case 3l: retval = "typeTestStruct"; break;
        case 4l: retval = "END_OF_ENUM"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(controlEnum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "controlEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// defaultEnumFunctionType is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C:18
/** Converts an enum of type defaultEnumFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_defaultEnumFunctionType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_unknown"; break;
        case 1l: retval = "e_constructor"; break;
        case 2l: retval = "e_destructor"; break;
        case 3l: retval = "e_copy_constructor"; break;
        case 4l: retval = "e_assignment_operator"; break;
        case 5l: retval = "e_last_type"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(defaultEnumFunctionType)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "defaultEnumFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// klt_tile_desc_t::tile_kind_e is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/KLT/include/KLT/RTL/tile.h:7
/** Converts an enum of type klt_tile_desc_t::tile_kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_klt_tile_desc_t_tile_kind_e(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_tile_static"; break;
        case 1l: retval = "e_tile_dynamic"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(klt_tile_desc_t::tile_kind_e)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "klt_tile_desc_t::tile_kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// language_enum is defined at mounts/GS-CAD/ROSE/sources/devel/src/roseSupport/utility_functions.C:611
/** Converts an enum of type language_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_language_enum(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "e_none"; break;
        case 1l: retval = "e_c"; break;
        case 2l: retval = "e_cxx"; break;
        case 3l: retval = "e_fortran"; break;
        case 4l: retval = "e_last_language"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(language_enum)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "language_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// omp_sched_t is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/SageIII/omp.h:20
/** Converts an enum of type omp_sched_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_omp_sched_t(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1l: retval = "omp_sched_static"; break;
        case 2l: retval = "omp_sched_dynamic"; break;
        case 3l: retval = "omp_sched_guided"; break;
        case 4l: retval = "omp_sched_auto"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(omp_sched_t)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "omp_sched_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ops is defined at mounts/GS-CAD/ROSE/sources/devel/src/frontend/ECJ_ROSE_Connection/JavaParserActionROSE.C:4086
/** Converts an enum of type ops to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_ops(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "ERROR_OPERATOR"; break;
        case 2l: retval = "AND"; break;
        case 3l: retval = "OR"; break;
        case 4l: retval = "LESS"; break;
        case 5l: retval = "LESS_EQUAL"; break;
        case 6l: retval = "GREATER"; break;
        case 7l: retval = "GREATER_EQUAL"; break;
        case 8l: retval = "XOR"; break;
        case 9l: retval = "DIVIDE"; break;
        case 10l: retval = "LEFT_SHIFT"; break;
        case 13l: retval = "MINUS"; break;
        case 14l: retval = "PLUS"; break;
        case 15l: retval = "MULTIPLY"; break;
        case 16l: retval = "REMAINDER"; break;
        case 17l: retval = "RIGHT_SHIFT"; break;
        case 19l: retval = "UNSIGNED_RIGHT_SHIFT"; break;
        case 100l: retval = "OR_OR"; break;
        case 101l: retval = "AND_AND"; break;
        case 102l: retval = "LAST_OPERATOR"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ops)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ops::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ssa_unfiltered_cfg::ReachingDef::Type is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/programAnalysis/ssaUnfilteredCfg/reachingDefUnfilteredCfg.h:20
/** Converts an enum of type ssa_unfiltered_cfg::ReachingDef::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_ssa_unfiltered_cfgReachingDefType(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0l: retval = "PHI_FUNCTION"; break;
        case 1l: retval = "ORIGINAL_DEF"; break;
        case 2l: retval = "EXPANDED_DEF"; break;
        case 3l: retval = "EXTERNAL_DEF"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(ssa_unfiltered_cfg::ReachingDef::Type)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ssa_unfiltered_cfg::ReachingDef::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// yytokentype is defined at mounts/GS-CAD/ROSE/sources/devel/src/midend/astMatching/matcherparser.h:47
/** Converts an enum of type yytokentype to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_yytokentype(long int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 258l: retval = "ALTERNATION"; break;
        case 259l: retval = "NOT"; break;
        case 260l: retval = "AND"; break;
        case 261l: retval = "XOR"; break;
        case 262l: retval = "OR"; break;
        case 263l: retval = "NEQ"; break;
        case 264l: retval = "EQ"; break;
        case 265l: retval = "C_NEQ"; break;
        case 266l: retval = "C_EQ"; break;
        case 267l: retval = "WHERE"; break;
        case 268l: retval = "TRUE"; break;
        case 269l: retval = "FALSE"; break;
        case 270l: retval = "IDENT"; break;
        case 271l: retval = "VARIABLE"; break;
        case 272l: retval = "INTEGER"; break;
        case 273l: retval = "SQ_STRING"; break;
        case 274l: retval = "NULL_NODE"; break;
        case 275l: retval = "DOTDOT"; break;
    }
    if (retval.empty()) {
        std::ostringstream ss;
        ss <<"(yytokentype)" <<n;
        retval = ss.str();
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "yytokentype::" + retval;
    }
    return retval;
}

} //namespace
